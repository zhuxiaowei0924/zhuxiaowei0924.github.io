<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>linux就该这么学-12:使用Samba或NFS实现文件共享</title>
    <url>/2021/02/11/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-12-%E4%BD%BF%E7%94%A8Samba%E6%88%96NFS%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<h1 id="1-SAMBA文件共享服务"><a href="#1-SAMBA文件共享服务" class="headerlink" title="1.SAMBA文件共享服务"></a>1.SAMBA文件共享服务</h1><p>Samba服务程序现在已经成为在Linux系统与Windows系统之间共享文件的最佳选择。</p>
<p>首先需要先通过Yum软件仓库来安装Samba服务程序：</p>
<a id="more"></a> 

<pre><code>[root@linuxprobe ~ ]# yum install samba</code></pre>
<p> Samba服务程序中的参数以及作用:</p>
<pre><code>[global]                                    #全局参数。

    workgroup = MYGROUP                        #工作组名称

    server string = Samba Server Version %v    #服务器介绍信息，参数%v为显示SMB版本号

    log file = /var/log/samba/log.%m        #定义日志文件的存放位置与名称，参数%m为来访的主机名

    max log size = 50                        #定义日志文件的最大容量为50KB

    security = user                            #安全验证的方式，总共有4种

    #share：来访主机无需验证口令；比较方便，但安全性很差

    #user：需验证来访主机提供的口令后才可以访问；提升了安全性

    #server：使用独立的远程主机验证来访主机提供的口令（集中管理账户）

    #domain：使用域控制器进行身份验证

    passdb backend = tdbsam                    #定义用户后台的类型，共有3种

    #smbpasswd：使用smbpasswd命令为系统用户设置Samba服务程序的密码

    #tdbsam：创建数据库文件并使用pdbedit命令建立Samba服务程序的用户

    #ldapsam：基于LDAP服务进行账户验证

    load printers = yes                        #设置在Samba服务启动时是否共享打印机设备

    cups options = raw                        #打印机的选项

[homes]                                        #共享参数

    comment = Home Directories                #描述信息

    browseable = no                            #指定共享信息是否在“网上邻居”中可见

    writable = yes                            #定义是否可以执行写入操作，与“read only”相反

[printers]                                    #打印机共享参数

    comment = All Printers    

    path = /var/spool/samba                    #共享文件的实际路径(重要)。

    browseable = no    
    guest ok = no                            #是否所有人可见，等同于&quot;public&quot;参数。

    writable = no    

    printable = yes    

[root@linuxprobe ~]# cat /etc/samba/smb.conf</code></pre>
<h2 id="1-1配置共享资源"><a href="#1-1配置共享资源" class="headerlink" title="1.1配置共享资源"></a>1.1配置共享资源</h2><p>用于设置Samba服务程序的参数以及作用：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>[database]</td>
<td>共享名称为database</td>
</tr>
<tr>
<td>comment = Do not arbitrarily modify the database file</td>
<td>警告用户不要随意修改数据库</td>
</tr>
<tr>
<td>path = /home/database</td>
<td>共享目录为/home/database</td>
</tr>
<tr>
<td>public = no</td>
<td>关闭“所有人可见”</td>
</tr>
<tr>
<td>writable = yes</td>
<td>允许写入操作</td>
</tr>
</tbody></table>
<p>第1步：创建用于访问共享资源的账户信息。在RHEL 7系统中，Samba服务程序默认使用的是用户口令认证模式（user）。这种认证模式可以确保仅让有密码且受信任的用户访问共享资源，而且验证过程也十分简单。不过，只有建立账户信息数据库之后，才能使用用户口令认证模式。另外，Samba服务程序的数据库要求账户必须在当前系统中已经存在，否则日后创建文件时将导致文件的权限属性混乱不堪，由此引发错误。</p>
<p>pdbedit命令用于管理SMB服务程序的账户信息数据库，格式为“pdbedit [选项] 账户”。在第一次把账户信息写入到数据库时需要使用-a参数，以后在执行修改密码、删除账户等操作时就不再需要该参数了。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-a 用户名</td>
<td>建立Samba用户</td>
</tr>
<tr>
<td>-x 用户名</td>
<td>删除Samba用户</td>
</tr>
<tr>
<td>-L</td>
<td>列出用户列表</td>
</tr>
<tr>
<td>-Lv</td>
<td>列出用户详细信息的列表</td>
</tr>
</tbody></table>
<pre><code>[root@linuxprobe ~]# id linuxprobe
uid=1000(linuxprobe) gid=1000(linuxprobe) groups=1000(linuxprobe)
[root@linuxprobe ~]# pdbedit -a -u linuxprobe
new password:此处输入该账户在Samba服务数据库中的密码
retype new password:再次输入密码进行确认
Unix username: linuxprobe
NT username: 
Account Flags: [U ]
……
Logon hours : FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code></pre>
<p>第2步：创建用于共享资源的文件目录。</p>
<pre><code>[root@linuxprobe ~]# mkdir /home/database
[root@linuxprobe ~]# chown -Rf linuxprobe:linuxprobe /home/database
[root@linuxprobe ~]# semanage fcontext -a -t samba_share_t /home/database
[root@linuxprobe ~]# restorecon -Rv /home/database
restorecon reset /home/database context unconfined_u:object_r:home_root_t:s0-&gt;unconfined_u:object_r:samba_share_t:s0</code></pre>
<p>第3步：设置SELinux服务与策略，使其允许通过Samba服务程序访问普通用户家目录。</p>
<pre><code>[root@linuxprobe ~]# getsebool -a | grep samba
samba_create_home_dirs --&gt; off
samba_domain_controller --&gt; off
samba_enable_home_dirs --&gt; off
……
[root@linuxprobe ~]# setsebool -P samba_enable_home_dirs on</code></pre>
<p>第4步：在Samba服务程序的主配置文件中，写入共享信息。在原始的配置文件中，[homes]参数为来访用户的家目录共享信息，[printers]参数为共享的打印机设备可以手动删除，这没有任何问题。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/samba/smb.conf 
[global]
 workgroup = MYGROUP
 server string = Samba Server Version %v
 log file = /var/log/samba/log.%m
 max log size = 50
 security = user
 passdb backend = tdbsam
 load printers = yes
 cups options = raw
[database]
 comment = Do not arbitrarily modify the database file
 path = /home/database
 public = no
 writable = yes</code></pre>
<p>第5步：Samba服务程序的配置工作基本完毕。接下来重启smb服务（Samba服务程序在Linux系统中的名字为smb）并清空iptables防火墙。</p>
<pre><code>[root@linuxprobe ~]# systemctl restart smb
[root@linuxprobe ~]# systemctl enable smb
 ln -s &#39;/usr/lib/systemd/system/smb.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/smb.service&#39;
[root@linuxprobe ~]# iptables -F
[root@linuxprobe ~]# service iptables save
iptables: Saving firewall rules to /etc/sysconfig/iptables:[ OK ]</code></pre>
<h2 id="1-2windows挂载共享"><a href="#1-2windows挂载共享" class="headerlink" title="1.2windows挂载共享"></a>1.2windows挂载共享</h2><p>Samba服务器和Windows客户端使用的操作系统以及IP地址（举例）：</p>
<p>| 主机名称 | 操作系统 | IP地址 |<br>| — | — |<br>| Samba共享服务器 |     RHEL 7 | 192.168.10.10 |<br>| Linux客户端 | RHEL 7 | 192.168.10.20 |<br>| Windows客户端 | Windows 7 | 192.168.10.30 |</p>
<p>要在Windows系统中访问共享资源，只需在Windows的“运行”命令框中输入两个反斜杠，然后再加服务器的IP地址即可：</p>
<img src="/2021/02/11/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-12-%E4%BD%BF%E7%94%A8Samba%E6%88%96NFS%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/1.png" class>

<p>在RHEL 7系统中，Samba服务程序使用的果然是独立的账户信息数据库。所以，即便在Linux系统中有一个linuxprobe账户，Samba服务程序使用的账户信息数据库中也有一个同名的linuxprobe账户，大家也一定要弄清楚它们各自所对应的密码。</p>
<img src="/2021/02/11/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-12-%E4%BD%BF%E7%94%A8Samba%E6%88%96NFS%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/2.jpg" class>

<p>正确输入linuxprobe账户名以及使用pdbedit命令设置的密码后，就可以登录到共享界面中了!</p>
<p>由于Windows系统的缓存原因，有可能您在第二次登录时提供了正确的账户和密码，依然会报错，这时只需要重新启动一下Windows客户端就没问题了!</p>
<h2 id="1-3linux挂载共享"><a href="#1-3linux挂载共享" class="headerlink" title="1.3linux挂载共享"></a>1.3linux挂载共享</h2><p> Samba共享服务器和Linux客户端各自使用的操作系统以及IP地址：</p>
<p>| 主机名称 | 操作系统 | IP地址 |<br>| — | — |<br>| Samba共享服务器 |     RHEL 7 | 192.168.10.10 |<br>| Linux客户端 | RHEL 7 | 192.168.10.20 |<br>| Windows客户端 | Windows 7 | 192.168.10.30 |</p>
<pre><code>[root@linuxprobe ~]# yum install cifs-utils
Loaded plugins: langpacks, product-id, subscription-manager
rhel | 4.1 kB 00:00 
Resolving Dependencies
--&gt; Running transaction check
---&gt; Package cifs-utils.x86_64 0:6.2-6.el7 will be installed
--&gt; Finished Dependency Resolution
Dependencies Resolved
……
Installed:
 cifs-utils.x86_64 0:6.2-6.el7 
Complete!</code></pre>
<p>在Linux客户端，按照Samba服务的用户名、密码、共享域的顺序将相关信息写入到一个认证文件中。为了保证不被其他人随意看到，最后把这个认证文件的权限修改为仅root管理员才能够读写：</p>
<pre><code>[root@linuxprobe ~]# vim auth.smb
username=linuxprobe
password=redhat
domain=MYGROUP
[root@linuxprobe ~]# chmod -Rf 600 auth.smb</code></pre>
<p>现在，在Linux客户端上创建一个用于挂载Samba服务共享资源的目录，并把挂载信息写入到/etc/fstab文件中，以确保共享挂载信息在服务器重启后依然生效：</p>
<pre><code>[root@linuxprobe ~]# mkdir /database
[root@linuxprobe ~]# vim /etc/fstab
/dev/mapper/rhel-swap swap swap defaults 0 0
/dev/cdrom /media/cdrom iso9660 defaults 0 0 
//192.168.10.10/database /database cifs credentials=/root/auth.smb 0 0
[root@linuxprobe ~]# mount -a</code></pre>
<p>Linux客户端成功地挂载了Samba服务的共享资源。进入到挂载目录/database后就可以看到Windows系统访问Samba服务程序时留下来的文件了（即文件Memo.txt）。当然，我们也可以对该文件进行读写操作并保存。</p>
<pre><code>[root@linuxprobe ~]# cat /database/Memo.txt</code></pre>
<h1 id="2-NFS网络文件系统"><a href="#2-NFS网络文件系统" class="headerlink" title="2.NFS网络文件系统"></a>2.NFS网络文件系统</h1><p>NFS服务：用于两台linux主机进行共享文件；</p>
<pre><code>[root@linuxprobe ~]# yum install nfs-utils</code></pre>
<p>| 主机名称 | 操作系统 | IP地址 |<br>| — | — |<br>| Linux服务端 |     RHEL 7 | 192.168.10.10 |<br>| Linux客户端 | RHEL 7 | 192.168.10.20 |</p>
<pre><code>[root@linuxprobe ~]# iptables -F
[root@linuxprobe ~]# service iptables save
iptables: Saving firewall rules to /etc/sysconfig/iptables:[ OK ]</code></pre>
<p>第2步：在NFS服务器上建立用于NFS文件共享的目录，并设置足够的权限确保其他人也有写入权限。</p>
<pre><code>[root@linuxprobe ~]# mkdir /nfsfile
[root@linuxprobe ~]# chmod -Rf 777 /nfsfile
[root@linuxprobe ~]# echo &quot;welcome to linuxprobe.com&quot; &gt; /nfsfile/readme</code></pre>
<p>第3步：NFS服务程序的配置文件为/etc/exports，默认情况下里面没有任何内容。我们可以按照“共享目录的路径 允许访问的NFS客户端（共享权限参数）”的格式，定义要共享的目录与相应的权限。</p>
<p>用于配置NFS服务程序配置文件的参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ro</td>
<td>只读</td>
</tr>
<tr>
<td>rw</td>
<td>读写</td>
</tr>
<tr>
<td>root_squash</td>
<td>当NFS客户端以root管理员访问时，映射为NFS服务器的匿名用户</td>
</tr>
<tr>
<td>no_root_squash</td>
<td>当NFS客户端以root管理员访问时，映射为NFS服务器的root管理员</td>
</tr>
<tr>
<td>all_squash</td>
<td>无论NFS客户端使用什么账户访问，均映射为NFS服务器的匿名用户</td>
</tr>
<tr>
<td>sync</td>
<td>同时将数据写入到内存与硬盘中，保证不丢失数据</td>
</tr>
<tr>
<td>async</td>
<td>优先将数据保存到内存，然后再写入硬盘；这样效率更高，但可能会丢失数据</td>
</tr>
</tbody></table>
<p>请注意，NFS客户端地址与权限之间没有空格。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/exports
/nfsfile 192.168.10.*(rw,sync,root_squash)</code></pre>
<p>第4步：启动和启用NFS服务程序。由于在使用NFS服务进行文件共享之前，需要使用RPC（Remote Procedure Call，远程过程调用）服务将NFS服务器的IP地址和端口号等信息发送给客户端。因此，在启动NFS服务之前，还需要顺带重启并启用rpcbind服务程序，并将这两个服务一并加入开机启动项中。</p>
<pre><code>[root@linuxprobe ~]# systemctl restart rpcbind
[root@linuxprobe ~]# systemctl enable rpcbind
[root@linuxprobe ~]# systemctl start nfs-server
[root@linuxprobe ~]# systemctl enable nfs-server</code></pre>
<p>NFS客户端的配置步骤也十分简单。先使用showmount命令（以及必要的参数，见表12-8）查询NFS服务器的远程共享信息，其输出格式为“共享的目录名称 允许使用客户端地址”。</p>
<p>showmount命令中可用的参数以及作用：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-e</td>
<td>显示NFS服务器的共享列表</td>
</tr>
<tr>
<td>-a</td>
<td>显示本机挂载的文件资源的情况NFS资源的情况</td>
</tr>
<tr>
<td>-v</td>
<td>显示版本号</td>
</tr>
</tbody></table>
<pre><code>[root@linuxprobe ~]# showmount -e 192.168.10.10
Export list for 192.168.10.10:
/nfsfile 192.168.10.*</code></pre>
<p>然后在NFS客户端创建一个挂载目录。使用mount命令并结合-t参数，指定要挂载的文件系统的类型，并在命令后面写上服务器的IP地址、服务器上的共享目录以及要挂载到本地系统（即客户端）的目录。</p>
<pre><code>[root@linuxprobe ~]# mkdir /nfsfile
[root@linuxprobe ~]# mount -t nfs 192.168.10.10:/nfsfile /nfsfile</code></pre>
<p>如果希望NFS文件共享服务能一直有效，则需要将其写入到fstab文件中：</p>
<pre><code>[root@linuxprobe ~]# cat /nfsfile/readme
    welcome to linuxprobe.com
[root@linuxprobe ~]# vim /etc/fstab
    ……
    /dev/cdrom /media/cdrom iso9660 defaults 0 0 
    192.168.10.10:/nfsfile /nfsfile nfs defaults 0 0</code></pre>
<h1 id="3-AutoFs自动挂载服务"><a href="#3-AutoFs自动挂载服务" class="headerlink" title="3.AutoFs自动挂载服务"></a>3.AutoFs自动挂载服务</h1><pre><code>[root@linuxprobe ~]# yum install autofs</code></pre>
<p>在autofs服务程序的主配置文件中需要按照“挂载目录 <strong>子配置文件</strong>”的格式进行填写。挂载目录是设备挂载位置的上一级目录。例如，光盘设备一般挂载到/media/cdrom目录中，那么挂载目录写成/media即可。对应的<strong>子配置文件</strong>则是对这个挂载目录内的挂载设备信息作进一步的说明。<strong>子配置文件</strong>需要用户自行定义，文件名字没有严格要求，但后缀建议以.misc结束。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/auto.master
#
# Sample auto.master file
# This is an automounter map and it has the following format
# key [ -mount-options-separated-by-comma ] location
# For details of the format look at autofs(5).
#
/media /etc/iso.misc
/misc /etc/auto.misc
#
# NOTE: mounts done from a hosts map will be mounted with the
# &quot;nosuid&quot; and &quot;nodev&quot; options unless the &quot;suid&quot; and &quot;dev&quot;
# options are explicitly given.
……
    +auto.master</code></pre>
<p>在子配置文件中，应按照“挂载目录 挂载文件类型及权限 :设备名称”的格式进行填写，挂载目录写为iso，而-fstype为文件系统格式参数，iso9660为光盘设备格式，ro、nosuid及nodev为光盘设备具体的权限参数，/dev/cdrom则是定义要挂载的设备名称:</p>
<pre><code>[root@linuxprobe ~]# vim /etc/iso.misc
iso   -fstype=iso9660,ro,nosuid,nodev :/dev/cdrom
[root@linuxprobe ~]# systemctl start autofs 
[root@linuxprobe ~]# systemctl enable autofs 

[root@linuxprobe ~]# df -h
Filesystem Size Used Avail Use% Mounted on
/dev/mapper/rhel-root 18G 3.0G 15G 17% /
tmpfs 914M 0 914M 0% /sys/fs/cgroup
/dev/sda1 497M 119M 379M 24% /boot
[root@linuxprobe ~]# cd /media
[root@linuxprobe media]# ls
[root@linuxprobe media]# cd iso
[root@linuxprobe iso]# ls -l
total 812
dr-xr-xr-x. 4 root root 2048 May 7 2017 addons
dr-xr-xr-x. 3 root root 2048 May 7 2017 EFI
[root@linuxprobe ~]# df -h
Filesystem Size Used Avail Use% Mounted on
/dev/cdrom 3.5G 3.5G 0 100% /media/iso</code></pre>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第12章节：使用Samba或NFS实现文件共享</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学-14：使用DHCP动态管理主机地址</title>
    <url>/2021/02/15/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-14%EF%BC%9A%E4%BD%BF%E7%94%A8DHCP%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h1 id="1-动态主机地址管理协议"><a href="#1-动态主机地址管理协议" class="headerlink" title="1.动态主机地址管理协议"></a>1.动态主机地址管理协议</h1><p>DHCP：Dynamic Host Configuration Protocol，动态主机配置协议；该协议用于自动管理局域网内主机的IP地址、子网掩码、网关地址及DNS地址等参数，可以有效地提升IP地址的利用率，提高配置效率，并降低管理与维护成本。</p>
<a id="more"></a>

<pre><code>作用域：一个完整的IP地址段，DHCP协议根据作用域来管理网络的分布、分配IP地址及其他配置参数。

超级作用域：用于管理处于同一个物理网络中的多个逻辑子网段。超级作用域中包含了可以统一管理的作用域列表。

排除范围：把作用域中的某些IP地址排除，确保这些IP地址不会分配给DHCP客户端。

地址池：在定义了DHCP的作用域并应用了排除范围后，剩余的用来动态分配给DHCP客户端的IP地址范围。

租约：DHCP客户端能够使用动态分配的IP地址的时间。

预约：保证网络中的特定设备总是获取到相同的IP地址。</code></pre>
<h1 id="2-部署dhcpd服务程序"><a href="#2-部署dhcpd服务程序" class="headerlink" title="2.部署dhcpd服务程序"></a>2.部署dhcpd服务程序</h1><pre><code>[root@linuxprobe ~]# yum install dhcp</code></pre>
<p>查看dhcpd服务程序的配置文件内容：</p>
<pre><code>[root@linuxprobe ~]# cat /etc/dhcp/dhcpd.conf</code></pre>
<p>dhcp的服务程序的配置文件中只有3行注释语句，这意味着我们需要自行编写这个文件。如果读者不知道怎么编写，可以看一下配置文件中第2行的参考示例文件，其组成架构如图：</p>
<img src="/2021/02/15/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-14%EF%BC%9A%E4%BD%BF%E7%94%A8DHCP%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80/1.png" class>

<p>一个标准的配置文件应该包括全局配置参数、子网网段声明、地址配置选项以及地址配置参数。其中，全局配置参数用于定义dhcpd服务程序的整体运行参数；子网网段声明用于配置整个子网段的地址属性。</p>
<p>dhcpd服务程序配置文件中使用的常见参数以及作用:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ddns-update-style 类型</td>
<td>定义DNS服务动态更新的类型，类型包括：none（不支持动态更新）、interim（互动更新模式）与ad-hoc（特殊更新模式）</td>
</tr>
<tr>
<td>allow/ignore client-updates</td>
<td>允许/忽略客户端更新DNS记录</td>
</tr>
<tr>
<td>default-lease-time 21600</td>
<td>默认超时时间</td>
</tr>
<tr>
<td>max-lease-time 43200</td>
<td>最大超时时间</td>
</tr>
<tr>
<td>option domain-name-servers 8.8.8.8</td>
<td>定义DNS服务器地址</td>
</tr>
<tr>
<td>option domain-name “domain.org”</td>
<td>定义DNS域名</td>
</tr>
<tr>
<td>range</td>
<td>定义用于分配的IP地址池</td>
</tr>
<tr>
<td>option subnet-mask</td>
<td>定义客户端的子网掩码</td>
</tr>
<tr>
<td>option routers</td>
<td>定义客户端的网关地址</td>
</tr>
<tr>
<td>broadcast-address 广播地址</td>
<td>定义客户端的广播地址</td>
</tr>
<tr>
<td>ntp-server IP地址</td>
<td>定义客户端的网络时间服务器（NTP）</td>
</tr>
<tr>
<td>nis-servers IP地址</td>
<td>定义客户端的NIS域服务器的地址</td>
</tr>
<tr>
<td>hardware 硬件类型 MAC地址</td>
<td>指定网卡接口的类型与MAC地址</td>
</tr>
<tr>
<td>server-name 主机名</td>
<td>向DHCP客户端通知DHCP服务器的主机名</td>
</tr>
<tr>
<td>fixed-address IP地址</td>
<td>将某个固定的IP地址分配给指定主机</td>
</tr>
<tr>
<td>time-offset 偏移差</td>
<td>指定客户端与格林尼治时间的偏移差</td>
</tr>
</tbody></table>
<h1 id="3-自动管理IP地址"><a href="#3-自动管理IP地址" class="headerlink" title="3.自动管理IP地址"></a>3.自动管理IP地址</h1><p>DHCP协议的设计初衷是为了更高效地集中管理局域网内的IP地址资源。DHCP服务器会自动把IP地址、子网掩码、网关、DNS地址等网络信息分配给有需要的客户端，而且当客户端的租约时间到期后还可以自动回收所分配的IP地址，以便交给新加入的客户端。</p>
<p>DHCP服务器以及客户端的配置信息：</p>
<table>
<thead>
<tr>
<th>主机类型</th>
<th>操作系统</th>
<th>IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>DHCP服务器</td>
<td>RHEL 7</td>
<td>192.168.10.1</td>
</tr>
<tr>
<td>DHCP客户机</td>
<td>RHEL 7</td>
<td>DHCP自动获取地址</td>
</tr>
</tbody></table>
<p>作用域一般是个完整的IP地址段，而地址池中的IP地址才是真正供客户端使用的，因此地址池应该小于或等于作用域的IP地址范围。另外，由于VMware Workstation虚拟机软件自带DHCP服务，为了避免与自己配置的dhcpd服务程序产生冲突，应该将虚拟机软件（包括服务器和客户端）自带的DHCP功能关闭。</p>
<img src="/2021/02/15/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-14%EF%BC%9A%E4%BD%BF%E7%94%A8DHCP%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80/2.png" class>

<img src="/2021/02/15/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-14%EF%BC%9A%E4%BD%BF%E7%94%A8DHCP%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80/3.jpg" class>

<p>此外还要注意，DHCP客户端与服务器需要处于同一种网络模式—仅主机模式（Hostonly），否则就会产生物理隔离，从而无法获取IP地址。</p>
<p>在确认DHCP服务器的IP地址等网络信息配置妥当后就可以配置dhcpd服务程序了。请注意，在配置dhcpd服务程序时，配置文件中的每行参数后面都需要以分号（;）结尾，这是规定。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/dhcp/dhcpd.conf
ddns-update-style none;
ignore client-updates;
subnet 192.168.10.0 netmask 255.255.255.0 &#123;
range 192.168.10.50 192.168.10.150;
option subnet-mask 255.255.255.0;
option routers 192.168.10.1;
option domain-name &quot;linuxprobe.com&quot;;
option domain-name-servers 192.168.10.1;
default-lease-time 21600;
max-lease-time 43200;
&#125;</code></pre>
<p>dhcpd服务程序配置文件中使用的参数以及作用：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ddns-update-style none;</td>
<td>设置DNS服务不自动进行动态更新</td>
</tr>
<tr>
<td>ignore client-updates;</td>
<td>忽略客户端更新DNS记录</td>
</tr>
<tr>
<td>subnet 192.168.10.0 netmask 255.255.255.0 {</td>
<td>作用域为192.168.10.0/24网段</td>
</tr>
<tr>
<td>range 192.168.10.50 192.168.10.150;</td>
<td>IP地址池为192.168.10.50-150（约100个IP地址）</td>
</tr>
<tr>
<td>option subnet-mask 255.255.255.0;</td>
<td>定义客户端默认的子网掩码</td>
</tr>
<tr>
<td>option routers 192.168.10.1;</td>
<td>定义客户端的网关地址</td>
</tr>
<tr>
<td>option domain-name “linuxprobe.com”;</td>
<td>定义默认的搜索域</td>
</tr>
<tr>
<td>option domain-name-servers 192.168.10.1;</td>
<td>定义客户端的DNS地址</td>
</tr>
<tr>
<td>default-lease-time 21600;</td>
<td>定义默认租约时间（单位：秒）</td>
</tr>
<tr>
<td>max-lease-time 43200;</td>
<td>定义最大预约时间（单位：秒）</td>
</tr>
<tr>
<td>}</td>
<td>结束符</td>
</tr>
</tbody></table>
<p>把配置过的dhcpd服务加入到开机启动项中，以确保当服务器下次开机后dhcpd服务依然能自动启动，并顺利地为客户端分配IP地址等信息：</p>
<pre><code>[root@linuxprobe ~]# systemctl start dhcpd
[root@linuxprobe ~]# systemctl enable dhcpd
 ln -s &#39;/usr/lib/systemd/system/dhcpd.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/dhcpd.service&#39;</code></pre>
<p>把dhcpd服务程序配置妥当之后就可以开启客户端来检验IP分配效果了。重启客户端的网卡服务后即可看到自动分配到的IP地址：</p>
<img src="/2021/02/15/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-14%EF%BC%9A%E4%BD%BF%E7%94%A8DHCP%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80/4.jpg" class>

<h1 id="4-分配固定IP地址"><a href="#4-分配固定IP地址" class="headerlink" title="4.分配固定IP地址"></a>4.分配固定IP地址</h1><p>在DHCP协议中有个术语是“预约”，它用来确保局域网中特定的设备总是获取到固定的IP地址。换句话说，就是dhcpd服务程序会把某个IP地址私藏下来，只将其用于相匹配的特定设备。</p>
<p>要想把某个IP地址与某台主机进行绑定，就需要用到这台主机的MAC地址。</p>
<img src="/2021/02/15/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-14%EF%BC%9A%E4%BD%BF%E7%94%A8DHCP%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80/5.jpg" class>

<p>也可以启动dhcpd服务程序，为主机分配一个IP地址，这样就会在DHCP服务器本地的日志文件中保存这次的IP地址分配记录，然后通过查看日志文件，获悉主机的MAC地址：</p>
<pre><code>[root@linuxprobe ~]# tail -f /var/log/messages 
Mar 30 05:33:17 localhost dhcpd: Copyright 2004-2013 Internet Systems Consortium.
Mar 30 05:33:17 localhost dhcpd: All rights reserved.
Mar 30 05:33:17 localhost dhcpd: For info, please visit https://www.isc.org/software/dhcp/
Mar 30 05:33:17 localhost dhcpd: Not searching LDAP since ldap-server, ldap-port and ldap-base-dn were not specified in the config file
Mar 30 05:33:17 localhost dhcpd: Wrote 0 leases to leases file.
Mar 30 05:33:17 localhost dhcpd: Listening on LPF/eno16777728/00:0c:29:c4:a4:09/192.168.10.0/24
Mar 30 05:33:17 localhost dhcpd: Sending on LPF/eno16777728/00:0c:29:c4:a4:09/192.168.10.0/24
Mar 30 05:33:17 localhost dhcpd: Sending on Socket/fallback/fallback-net
Mar 30 05:33:26 localhost dhcpd: DHCPDISCOVER from **00:0c:29:27:c6:12** via eno16777728</code></pre>
<p>在dhcpd服务程序的配置文件中，按照如下格式将IP地址与MAC地址进行绑定（MAC地址的间隔符为冒号（:））：</p>
<img src="/2021/02/15/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-14%EF%BC%9A%E4%BD%BF%E7%94%A8DHCP%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80/6.png" class>

<p>确认参数填写正确后就可以保存退出配置文件，然后就可以重启dhcpd服务程序了：</p>
<pre><code>[root@linuxprobe ~]# systemctl restart dhcpd</code></pre>
<p>需要说明的是，如果刚刚为这台主机分配了IP地址，则它的IP地址租约时间还没有到期，因此不会立即换成新绑定的IP地址。要想立即查看绑定效果，则需要重启一下客户端的网络服务：</p>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第14章节：使用DHCP动态管理主机地址</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：使用RAID与LVM磁盘阵列技术</title>
    <url>/2021/02/02/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8RAID%E4%B8%8ELVM%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>RAID：Redundant Array of Independent Disks，独立冗余磁盘阵列；<br>LVM：Logical Volume Manager，逻辑卷管理器；</p>
<a id="more"></a>

<h1 id="1-RAID-0"><a href="#1-RAID-0" class="headerlink" title="1.RAID 0"></a>1.RAID 0</h1><img src="/2021/02/02/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8RAID%E4%B8%8ELVM%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E6%8A%80%E6%9C%AF/1.png" class>

<h1 id="2-RAID-1"><a href="#2-RAID-1" class="headerlink" title="2.RAID 1"></a>2.RAID 1</h1><img src="/2021/02/02/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8RAID%E4%B8%8ELVM%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E6%8A%80%E6%9C%AF/2.jpg" class>

<h1 id="3-RAID-5"><a href="#3-RAID-5" class="headerlink" title="3.RAID 5"></a>3.RAID 5</h1><img src="/2021/02/02/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8RAID%E4%B8%8ELVM%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E6%8A%80%E6%9C%AF/3.png" class>

<h1 id="4-RAID-10"><a href="#4-RAID-10" class="headerlink" title="4.RAID 10"></a>4.RAID 10</h1><img src="/2021/02/02/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8RAID%E4%B8%8ELVM%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E6%8A%80%E6%9C%AF/4.png" class>

<p>mdadm命令用于管理Linux系统中的软件RAID硬盘阵列，格式为“mdadm [模式] &lt;RAID设备名称&gt; [选项] [成员设备名称]”.</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>检测设备名称</td>
</tr>
<tr>
<td>-n</td>
<td>指定设备数量</td>
</tr>
<tr>
<td>-l</td>
<td>指定RAID级别</td>
</tr>
<tr>
<td>-C</td>
<td>创建</td>
</tr>
<tr>
<td>-v</td>
<td>显示过程</td>
</tr>
<tr>
<td>-D</td>
<td>查看详细信息</td>
</tr>
<tr>
<td>-r</td>
<td>移除设备</td>
</tr>
<tr>
<td>-S</td>
<td>停止RAID磁盘阵列</td>
</tr>
</tbody></table>
<p>-C参数代表创建一个RAID阵列卡；-v参数显示创建的过程，同时在后面追加一个设备名称/dev/md0，这样/dev/md0就是创建后的RAID磁盘阵列的名称；-a yes参数代表自动创建设备文件；-n 4参数代表使用4块硬盘来部署这个RAID磁盘阵列；而-l 10参数则代表RAID 10方案；最后再加上4块硬盘设备的名称就搞定了。</p>
<pre><code>[root@linuxprobe ~]# mdadm -Cv /dev/md0 -a yes -n 4 -l 10 /dev/sdb /dev/sdc /dev/sdd /dev/sde</code></pre>
<p>之后格式化mkfs.ext4，创建挂载点mkdir /RAID，查看详细信息mdadm -D /dev/md0，并把挂载信息写入配置文件。</p>
<h1 id="5-磁盘阵列-备份盘"><a href="#5-磁盘阵列-备份盘" class="headerlink" title="5.磁盘阵列+备份盘"></a>5.磁盘阵列+备份盘</h1><p>在下面的命令中，参数-n 3代表创建这个RAID 5磁盘阵列所需的硬盘数，参数-l 5代表RAID的级别，而参数-x 1则代表有一块备份盘。当查看/dev/md0（即RAID 5磁盘阵列的名称）磁盘阵列的时候就能看到有一块备份盘在等待中了：</p>
<pre><code>mdadm -Cv /dev/md0 -n 3 -l 5 -x 1 /dev/sdb /dev/sdc /dev/sdd /dev/sde</code></pre>
<h1 id="6-部署逻辑卷"><a href="#6-部署逻辑卷" class="headerlink" title="6.部署逻辑卷"></a>6.部署逻辑卷</h1>

<pre><code>[root@linuxprobe ~]# pvcreate /dev/sdb /dev/sdc
[root@linuxprobe ~]# vgcreate storage /dev/sdb /dev/sdc
[root@linuxprobe ~]# lvcreate -n vo -l 37 storage（在对逻辑卷进行切割时有两种计量单位。第一种是以容量为单位，所使用的参数为-L。例如，使用-L 150M生成一个大小为150MB的逻辑卷。另外一种是以基本单元的个数为单位，所使用的参数为-l。每个基本单元的大小默认为4MB。例如，使用-l 37可以生成一个大小为37×4MB=148MB的逻辑卷。）</code></pre>
<p>之后再格式化，挂载，写入配置文件中即可！</p>
<h1 id="7-扩容逻辑卷"><a href="#7-扩容逻辑卷" class="headerlink" title="7.扩容逻辑卷"></a>7.扩容逻辑卷</h1><p>扩展前请一定要记得卸载设备和挂载点的关联。</p>
<pre><code>[root@linuxprobe ~]# lvextend -L 290M /dev/storage/vo （逻辑卷vo扩展至290MB）
[root@linuxprobe ~]# e2fsck -f /dev/storage/vo （检查硬盘完整性）
[root@linuxprobe ~]# resize2fs /dev/storage/vo （重置硬盘容量）</code></pre>
<p>之后mount -a挂载硬盘设备即可！</p>
<h1 id="8-缩小逻辑卷"><a href="#8-缩小逻辑卷" class="headerlink" title="8.缩小逻辑卷"></a>8.缩小逻辑卷</h1><p>扩展前请一定要记得卸载设备和挂载点的关联。</p>
<pre><code>[root@linuxprobe ~]# e2fsck -f /dev/storage/vo
[root@linuxprobe ~]# resize2fs /dev/storage/vo 120M
[root@linuxprobe ~]# lvreduce -L 120M /dev/storage/vo</code></pre>
<p>之后mount -a挂载硬盘设备即可！</p>
<h1 id="9-逻辑卷快照"><a href="#9-逻辑卷快照" class="headerlink" title="9.逻辑卷快照"></a>9.逻辑卷快照</h1><p>LVM的快照卷功能有两个特点：</p>
<pre><code>快照卷的容量必须等同于逻辑卷的容量；

快照卷仅一次有效，一旦执行还原操作后则会被立即自动删除。

[root@linuxprobe ~]#  lvcreate -L 120M -s -n SNAP /dev/storage/vo （使用-s参数生成一个快照卷，使用-L参数指定切割的大小。另外，还需要在命令后面写上是针对哪个逻辑卷执行的快照操作。）
[root@linuxprobe ~]# umount /linuxprobe （记得先卸载掉逻辑卷设备与目录的挂载。）
[root@linuxprobe ~]# lvconvert --merge /dev/storage/SNAP
[root@linuxprobe ~]# mount -a</code></pre>
<h1 id="10-删除逻辑卷"><a href="#10-删除逻辑卷" class="headerlink" title="10.删除逻辑卷"></a>10.删除逻辑卷</h1><pre><code>[root@linuxprobe ~]# umount /linuxprobe （取消逻辑卷与目录的挂载关联）
[root@linuxprobe ~]# vim /etc/fstab （删除配置文件中永久生效的设备参数）
[root@linuxprobe ~]# lvremove /dev/storage/vo （删除逻辑卷设备，需要输入y来确认操作）
[root@linuxprobe ~]# vgremove storage （删除卷组，此处只写卷组名称即可，不需要设备的绝对路径）
[root@linuxprobe ~]# pvremove /dev/sdb /dev/sdc （删除物理卷设备）</code></pre>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第7章节：使用RAID与LVM磁盘阵列技术</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：使用ssh服务管理远程主机</title>
    <url>/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="1-配置网卡服务"><a href="#1-配置网卡服务" class="headerlink" title="1.配置网卡服务"></a>1.配置网卡服务</h1><p>介绍了SSH协议与sshd服务程序的理论知识、Linux系统的远程管理方法以及在系统中配置服务程序的方法，并采用实验的形式演示了使用基于密码验证的sshd服务程序进行远程登录，以及使用screen服务程序远程管理Linux系统的不间断会话等技术。</p>
<a id="more"></a>

<h1 id="1-1配置网卡参数"><a href="#1-1配置网卡参数" class="headerlink" title="1.1配置网卡参数"></a>1.1配置网卡参数</h1><img src="/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/1.png" class>

<img src="/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/2.png" class>

<img src="/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/3.png" class>

<img src="/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/4.png" class>

<img src="/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/5.png" class>

<img src="/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/6.png" class>

<img src="/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/7.png" class>

<img src="/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/8.png" class>

<p>用Vim编辑器将网卡配置文件中的ONBOOT参数修改成yes，这样在系统重启后网卡就被激活了:</p>
<pre><code>[root@linuxprobe ~]# vim /etc/sysconfig/network-scripts/ifcfg-eno16777736
TYPE=Ethernet
BOOTPROTO=none
...
ONBOOT=yes</code></pre>
<p>修改完Linux系统中的服务配置文件后,要手动重启相应的服务:</p>
<pre><code>[root@linuxprobe ~]# systemctl restart network</code></pre>
<h2 id="1-2创建网络会话"><a href="#1-2创建网络会话" class="headerlink" title="1.2创建网络会话"></a>1.2创建网络会话</h2><p>NetworkManager：是一种动态管理网络配置的守护进程，能够让网络设备保持连接状态；可以使用nmcli命令来管理Network Manager服务。</p>
<p>可以使用nmcli命令并按照“connection add con-name type ifname”的格式来创建网络会话。</p>
<p>使用con-name参数指定使用的网络会话名称company，然后依次用ifname参数指定网卡名称，用autoconnect no参数设置该网络会话默认不被自动激活，以及用ip4及gw4参数手动指定网络的IP地址：</p>
<pre><code>[root@linuxprobe ~]# nmcli connection add con-name company ifname eno16777736 autoconnect no type ethernet ip4 192.168.10.10/24 gw4 192.168.10.1</code></pre>
<p>使用con-name参数指定网络会话名称house，使用外部DHCP服务器自动获得IP地址，不需要进行手动指定：</p>
<pre><code>[root@linuxprobe ~]# nmcli connection add con-name house type ethernet ifname eno16777736</code></pre>
<p>使配置过的网络会话生效：</p>
<pre><code>[root@linuxprobe ~]# nmcli connection up house </code></pre>
<h2 id="1-3绑定两块网卡"><a href="#1-3绑定两块网卡" class="headerlink" title="1.3绑定两块网卡"></a>1.3绑定两块网卡</h2><img src="/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/9.png" class>

<img src="/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/10.png" class>

<p>使用Vim文本编辑器来配置网卡设备的绑定参数：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/sysconfig/network-scripts/ifcfg-eno16777736
TYPE=Ethernet
BOOTPROTO=none
ONBOOT=yes
USERCTL=no
DEVICE=eno16777736
MASTER=bond0
SLAVE=yes
[root@linuxprobe ~]# vim /etc/sysconfig/network-scripts/ifcfg-eno33554968
TYPE=Ethernet
BOOTPROTO=none
ONBOOT=yes
USERCTL=no
DEVICE=eno33554968
MASTER=bond0
SLAVE=yes</code></pre>
<p>将绑定后的设备命名为bond0并把IP地址等信息填写进去，这样当用户访问相应服务的时候，实际上就是由这两块网卡设备在共同提供服务：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/sysconfig/network-scripts/ifcfg-bond0
TYPE=Ethernet
BOOTPROTO=none
ONBOOT=yes
USERCTL=no
DEVICE=bond0
IPADDR=192.168.10.10
PREFIX=24
DNS=192.168.10.1
NM_CONTROLLED=no</code></pre>
<p>让Linux内核支持网卡绑定驱动。常见的网卡绑定驱动有三种模式—mode0、mode1和mode6。下面以绑定两块网卡为例，讲解使用的情景。</p>
<pre><code>mode0（平衡负载模式）：平时两块网卡均工作，且自动备援，但需要在与服务器本地网卡相连的交换机设备上进行端口聚合来支持绑定技术。

mode1（自动备援模式）：平时只有一块网卡工作，在它故障后自动替换为另外的网卡。

mode6（平衡负载模式）：平时两块网卡均工作，且自动备援，无须交换机设备提供辅助支持。</code></pre>
<p>使用Vim文本编辑器创建一个用于网卡绑定的驱动文件，使得绑定后的bond0网卡设备能够支持绑定技术（bonding）；同时定义网卡以mode6模式进行绑定，且出现故障时自动切换的时间为100毫秒：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/modprobe.d/bond.conf
alias bond0 bonding
options bond0 miimon=100 mode=6</code></pre>
<p>重启网络服务后网卡绑定操作即可成功。正常情况下只有bond0网卡设备才会有IP地址等信息：</p>
<pre><code>[root@linuxprobe ~]# systemctl restart network</code></pre>
<h1 id="2-远程控制服务"><a href="#2-远程控制服务" class="headerlink" title="2.远程控制服务"></a>2.远程控制服务</h1><h2 id="2-1配置sshd服务"><a href="#2-1配置sshd服务" class="headerlink" title="2.1配置sshd服务"></a>2.1配置sshd服务</h2><p>想要使用SSH协议来远程管理Linux系统，则需要部署配置sshd服务程序。sshd是基于SSH协议开发的一款远程管理服务程序，不仅使用起来方便快捷，而且能够提供两种安全验证的方法：</p>
<pre><code>基于口令的验证—用账户和密码来验证登录；

基于密钥的验证—需要在本地生成密钥对，然后把密钥对中的公钥上传至服务器，并与服务器中的公钥进行比较；该方式相较来说更安全。</code></pre>
<p>sshd服务的配置信息保存在/etc/ssh/sshd_config文件中；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Port 22</td>
<td>默认的sshd服务端口</td>
</tr>
<tr>
<td>ListenAddress 0.0.0.0</td>
<td>设定sshd服务器监听的IP地址</td>
</tr>
<tr>
<td>Protocol 2</td>
<td>SSH协议的版本号</td>
</tr>
<tr>
<td>HostKey /tc/ssh/ssh_host_key</td>
<td>SSH协议版本为1时，DES私钥存放的位置</td>
</tr>
<tr>
<td>HostKey /etc/ssh/ssh_host_rsa_key</td>
<td>SSH协议版本为2时，RSA私钥存放的位置</td>
</tr>
<tr>
<td>HostKey /etc/ssh/ssh_host_dsa_key</td>
<td>SSH协议版本为2时，DSA私钥存放的位置</td>
</tr>
<tr>
<td>PermitRootLogin yes</td>
<td>设定是否允许root管理员直接登录</td>
</tr>
<tr>
<td>StrictModes yes</td>
<td>当远程用户的私钥改变时直接拒绝连接</td>
</tr>
<tr>
<td>MaxAuthTries 6</td>
<td>最大密码尝试次数</td>
</tr>
<tr>
<td>MaxSessions 10</td>
<td>最大终端数</td>
</tr>
<tr>
<td>PasswordAuthentication yes</td>
<td>是否允许密码验证</td>
</tr>
<tr>
<td>PermitEmptyPasswords no</td>
<td>是否允许空密码登录（很不安全）</td>
</tr>
</tbody></table>
<pre><code>[root@linuxprobe ~]# ssh 192.168.10.10
The authenticity of host &#39;192.168.10.10 (192.168.10.10)&#39; can&#39;t be established.
ECDSA key fingerprint is 4f:a7:91:9e:8d:6f:b9:48:02:32:61:95:48:ed:1e:3f.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &#39;192.168.10.10&#39; (ECDSA) to the list of known hosts.
root@192.168.10.10&#39;s password:此处输入远程主机root管理员的密码
Last login: Wed Apr 15 15:54:21 2017 from 192.168.10.10
[root@linuxprobe ~]# 
[root@linuxprobe ~]# exit
logout
Connection to 192.168.10.10 closed.</code></pre>
<p>禁止以root管理员的身份远程登录到服务器：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/ssh/sshd_config 
 ………………省略部分输出信息………………
 46 
 47 #LoginGraceTime 2m
 **48 PermitRootLogin no**
 49 #StrictModes yes
 50 #MaxAuthTries 6
 51 #MaxSessions 10
 52
 ………………省略部分输出信息………………</code></pre>
<p>让新配置文件生效，则需要手动重启相应的服务程序；最好也将这个服务程序加入到开机启动项中：</p>
<pre><code>[root@linuxprobe ~]# systemctl restart sshd
[root@linuxprobe ~]# systemctl enable sshd</code></pre>
<h2 id="2-2安全密钥验证"><a href="#2-2安全密钥验证" class="headerlink" title="2.2安全密钥验证"></a>2.2安全密钥验证</h2><p>第1步：在客户端主机中生成“密钥对”。</p>
<pre><code>[root@linuxprobe ~]# ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa):按回车键或设置密钥的存储路径
Created directory &#39;/root/.ssh&#39;.
Enter passphrase (empty for no passphrase):直接按回车键或设置密钥的密码
Enter same passphrase again:再次按回车键或设置密钥的密码
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
40:32:48:18:e4:ac:c0:c3:c1:ba:7c:6c:3a:a8:b5:22 root@linuxprobe.com
The key&#39;s randomart image is:
    +--[ RSA 2048]----+
    |+*..o .          |
    |*.o  +           |
    |o*    .          |
    |+ .    .         |
    |o..     S        |
    |.. +             |
    |. =              |
    |E+ .             |
    |+.o              |
    +-----------------+</code></pre>
<p>第2步：把客户端主机中生成的公钥文件传送至远程主机：</p>
<pre><code>[root@linuxprobe ~]# ssh-copy-id 192.168.10.10
The authenticity of host &#39;192.168.10.20 (192.168.10.10)&#39; can&#39;t be established.
ECDSA key fingerprint is 4f:a7:91:9e:8d:6f:b9:48:02:32:61:95:48:ed:1e:3f.
Are you sure you want to continue connecting (yes/no)? yes
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@192.168.10.10&#39;s password:此处输入远程服务器密码
Number of key(s) added: 1
Now try logging into the machine, with: &quot;ssh &#39;192.168.10.10&#39;&quot;
and check to make sure that only the key(s) you wanted were added.</code></pre>
<p>第3步：对服务器进行设置，使其只允许密钥验证，拒绝传统的口令验证方式。记得在修改配置文件后保存并重启sshd服务程序。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/ssh/sshd_config 
 ………………省略部分输出信息………………
 74 
 75 # To disable tunneled clear text passwords, change to no here!
 76 #PasswordAuthentication yes
 77 #PermitEmptyPasswords no
 **78 PasswordAuthentication no**
 79 
 ………………省略部分输出信息………………
[root@linuxprobe ~]# systemctl restart sshd</code></pre>
<p>第4步：在客户端尝试登录到服务器，此时无须输入密码也可成功登录。</p>
<pre><code>[root@linuxprobe ~]# ssh 192.168.10.10
Last login: Mon Apr 13 19:34:13 2017</code></pre>
<h2 id="2-3远程传输命令"><a href="#2-3远程传输命令" class="headerlink" title="2.3远程传输命令"></a>2.3远程传输命令</h2><p>scp（secure copy）是一个基于SSH协议在网络之间进行安全传输的命令，其格式为“scp [参数] 本地文件 远程帐户@远程IP地址:远程目录；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-v</td>
<td>显示详细的连接进度</td>
</tr>
<tr>
<td>-p</td>
<td>指定远程主机的sshd端口号</td>
</tr>
<tr>
<td>-r</td>
<td>用于传送文件夹</td>
</tr>
<tr>
<td>-6</td>
<td>使用IPv6协议</td>
</tr>
</tbody></table>
<p>在使用scp命令把文件从本地复制到远程主机时，首先需要以绝对路径的形式写清本地文件的存放位置：</p>
<pre><code>[root@linuxprobe ~]# echo &quot;Welcome to LinuxProbe.Com&quot; &gt; readme.txt
[root@linuxprobe ~]# scp /root/readme.txt 192.168.10.20:/home
root@192.168.10.20&#39;s password:此处输入远程服务器中root管理员的密码
readme.txt 100% 26 0.0KB/s 00:00</code></pre>
<p>使用scp命令把远程主机上的文件下载到本地主机，其命令格式为“scp [参数] 远程用户@远程IP地址:远程文件 本地目录”:</p>
<pre><code>[root@linuxprobe ~]# scp 192.168.10.20:/etc/redhat-release /root
root@192.168.10.20&#39;s password:此处输入远程服务器中root管理员的密码
redhat-release 100% 52 0.1KB/s 00:00 
[root@linuxprobe ~]# cat redhat-release 
Red Hat Enterprise Linux Server release 7.0 (Maipo)</code></pre>
<h1 id="3-不间断会话服务"><a href="#3-不间断会话服务" class="headerlink" title="3.不间断会话服务"></a>3.不间断会话服务</h1><p>screen是一款能够实现多窗口远程控制的开源服务程序，简单来说就是为了解决网络异常中断或为了同时控制多个远程终端窗口而设计的程序。用户还可以使用screen服务程序同时在多个远程会话中自由切换，能够做到实现如下功能。</p>
<pre><code>会话恢复：即便网络中断，也可让会话随时恢复，确保用户不会失去对远程会话的控制。

多窗口：每个会话都是独立运行的，拥有各自独立的输入输出终端窗口，终端窗口内显示过的信息也将被分开隔离保存，以便下次使用时依然能看到之前的操作记录。

会话共享：当多个用户同时登录到远程服务器时，便可以使用会话共享功能让用户之间的输入输出信息共享。</code></pre>
<h2 id="3-1管理远程会话"><a href="#3-1管理远程会话" class="headerlink" title="3.1管理远程会话"></a>3.1管理远程会话</h2><p>screen命令：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-S</td>
<td>创建会话窗口</td>
</tr>
<tr>
<td>-d</td>
<td>将指定会话进行离线处理</td>
</tr>
<tr>
<td>-r</td>
<td>恢复指定会话</td>
</tr>
<tr>
<td>-x</td>
<td>一次性恢复所有会话</td>
</tr>
<tr>
<td>-ls</td>
<td>显示当前已有会话</td>
</tr>
<tr>
<td>-wipe</td>
<td>将目前无法使用的会话删除</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第9章节：使用ssh服务管理远程主机</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：使用win10主机ping通虚拟机</title>
    <url>/2021/02/09/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8win10%E4%B8%BB%E6%9C%BAping%E9%80%9A%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p>在win10系统中安装了vm12版本，Linux我选用的是redhat 7版本；成功安装redhat 7后，将linux虚拟机的IP地址固定：</p>
<a id="more"></a>

<img src="/2021/02/09/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8win10%E4%B8%BB%E6%9C%BAping%E9%80%9A%E8%99%9A%E6%8B%9F%E6%9C%BA/1.png" class>

<p>linux虚拟机的外部连接方式为NAT模式，在linux虚拟机中能够ping通自己的IP，但无法ping通win10系统的IP，win10系统也无法ping通linux虚拟机IP。</p>
<img src="/2021/02/09/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8win10%E4%B8%BB%E6%9C%BAping%E9%80%9A%E8%99%9A%E6%8B%9F%E6%9C%BA/2.png" class>

<p>解决方法如下：</p>
<p>1.首先确认了本机的网络有无VMware Network Adapter VMnet8这两个网络：</p>
<img src="/2021/02/09/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8win10%E4%B8%BB%E6%9C%BAping%E9%80%9A%E8%99%9A%E6%8B%9F%E6%9C%BA/3.png" class>

<p>有以上两个网络的话，跳过此步骤；没有的话，则将VM虚拟机卸载，之后清理完之后再重新安装VM虚拟机软件。</p>
<p>2.安装好虚拟机后，打开终端，输入：vim /etc/sysconfig/network-scripts/ifcfg-eno16777728（网卡名称），编辑下网卡文件，将BOOTPROTO的值修改为static，并添加参数：IPADDR，GATEWAR，NETMASK，NM_CONTROLLED。IPADDR，GATEWAR这两个设置注意网段要与VMware Network Adapter VMnet8 的一致：</p>
<img src="/2021/02/09/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8win10%E4%B8%BB%E6%9C%BAping%E9%80%9A%E8%99%9A%E6%8B%9F%E6%9C%BA/4.png" class>

<p>3.设置好之后，保存退出；之后重启系统，用linux虚拟机ping下win10系统IP地址，测试是否能够ping通，如果可以，那就ok了。</p>
<p>linux虚拟机ping win10系统：</p>
<img src="/2021/02/09/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8win10%E4%B8%BB%E6%9C%BAping%E9%80%9A%E8%99%9A%E6%8B%9F%E6%9C%BA/5.png" class>

<p>win10系统ping linux虚拟机：</p>
<img src="/2021/02/09/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8win10%E4%B8%BB%E6%9C%BAping%E9%80%9A%E8%99%9A%E6%8B%9F%E6%9C%BA/6.png" class>



















]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>使用win10主机ping通虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：存储结构与磁盘划分</title>
    <url>/2021/02/01/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E7%A3%81%E7%9B%98%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<h1 id="1-一切从“-”开始"><a href="#1-一切从“-”开始" class="headerlink" title="1.一切从“/”开始"></a>1.一切从“/”开始</h1><p>Linux系统中的一切文件都是从“根（/）”目录开始的，并按照文件系统层次化标准（FHS）采用树形结构来存放文件，以及定义了常见目录的用途。另外，Linux系统中的文件和目录名称是严格区分大小写的。  </p>
<a id="more"></a>

<table>
<thead>
<tr>
<th>目录名称</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>/boot</td>
<td>开机所需文件—内核、开机菜单以及所需配置文件等</td>
</tr>
<tr>
<td>/dev</td>
<td>以文件形式存放任何设备与接口</td>
</tr>
<tr>
<td>/etc</td>
<td>配置文件</td>
</tr>
<tr>
<td>/home</td>
<td>用户主目录</td>
</tr>
<tr>
<td>/media</td>
<td>用于挂载设备文件的目录</td>
</tr>
</tbody></table>
<p>主分区或扩展分区的编号从1开始，到4结束；逻辑分区从编号5开始。</p>
<p>mount命令用于挂载文件系统，格式为“mount 文件系统 挂载目录”；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>挂载所有在/etc/fstab中定义的文件系统</td>
</tr>
<tr>
<td>-t</td>
<td>指定文件系统的类型</td>
</tr>
</tbody></table>
<p>如果想让硬件设备和目录永久地进行自动关联，就必须把挂载信息按照指定的填写格式“设备文件 挂载目录 格式类型 权限选项 是否备份 是否自检”（各字段的意义见表6-4）写入到/etc/fstab文件中。</p>
<p>umount命令用于撤销已经挂载的设备文件，格式为“umount [挂载点/设备文件]”。</p>
<h2 id="1-1添加硬盘设备"><a href="#1-1添加硬盘设备" class="headerlink" title="1.1添加硬盘设备"></a>1.1添加硬盘设备</h2><p>1.fdisk命令：用于管理磁盘分区，格式为“fdisk  [磁盘名称]”，它提供了集添加、删除、转换分区等功能于一身的“一站式分区服务”；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>m</td>
<td>查看全部可用的参数</td>
</tr>
<tr>
<td>n</td>
<td>添加新的分区</td>
</tr>
<tr>
<td>d</td>
<td>删除某个分区</td>
</tr>
<tr>
<td>p</td>
<td>查看分区表信息</td>
</tr>
<tr>
<td>w</td>
<td>保存并退出</td>
</tr>
<tr>
<td>q</td>
<td>不保存直接退出</td>
</tr>
</tbody></table>
<p>2.mkfs：存储设备进行分区后进行格式化操作；</p>
<p>3.mount：挂载存储设备；</p>
<p>4.du：查看文件数据占用量；du -sh /*命令来查看在Linux系统根目录下所有一级目录分别占用的空间大小。</p>
<p>如果想让这个设备文件的挂载永久有效，则需要把挂载的信息写入到配置文件中：</p>
<h2 id="1-2添加交换分区"><a href="#1-2添加交换分区" class="headerlink" title="1.2添加交换分区"></a>1.2添加交换分区</h2><p>SWAP（交换）分区是一种通过在硬盘中预先划分一定的空间，然后将把内存中暂时不常用的数据临时存放到硬盘中，以便腾出物理内存空间让更活跃的程序服务来使用的技术，其设计目的是为了解决真实物理内存不足的问题。但由于交换分区毕竟是通过硬盘设备读写数据的，速度肯定要比物理内存慢，所以只有当真实的物理内存耗尽后才会调用交换分区的资源。</p>
<p>生产环境中，交换分区的大小一般为真实物理内存的1.5～2倍；</p>
<pre><code>（1）fdisk
（2）mkswap:SWAP分区专用的格式化命令；
（3）free -m：用于查看交换分区的大小；
（4）将相关信息写入配置文件（/etc/fstab），并保存！如：/dev/sdb2 swap swap defaults 0 0 </code></pre>
<h2 id="1-3磁盘容量配额"><a href="#1-3磁盘容量配额" class="headerlink" title="1.3磁盘容量配额"></a>1.3磁盘容量配额</h2><p>使用quota命令进行磁盘容量配额管理，从而限制用户的硬盘可用容量或所能创建的最大文件个数。quota命令还有软限制和硬限制的功能。</p>
<p>软限制：当达到软限制时会提示用户，但仍允许用户在限定的额度内继续使用。</p>
<p>硬限制：当达到硬限制时会提示用户，且强制终止用户的操作。</p>
<p>1.xfs_quota：-c参数用于以参数的形式设置要执行的命令；-x参数是专家模式，让运维人员能够对quota服务进行更多复杂的配置。</p>
<pre><code>[root@linuxprobe ~]# xfs_quota -x -c &#39;limit bsoft=3m bhard=6m isoft=3 ihard=6 tom&#39; /boot
[root@linuxprobe ~]# xfs_quota -x -c report /boot</code></pre>
<p>2.edquota：用于编辑用户的quota配额限制，格式为“edquota [参数] [用户] ”。-u参数表示要针对哪个用户进行设置；-g参数表示要针对哪个用户组进行设置。</p>
<h2 id="1-4软硬方式链接"><a href="#1-4软硬方式链接" class="headerlink" title="1.4软硬方式链接"></a>1.4软硬方式链接</h2><p>硬链接： 是指针，所有的硬链接都是指向同一个磁盘块； 删除一个指针不会真正删除文件，只有把所有的指针都删除才会真正删除文件。<br>软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。</p>
<p>1.ln：用于创建链接文件，格式为“ln [选项] 目标”；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-s</td>
<td>创建“符号链接”（如果不带-s参数，则默认创建硬链接）</td>
</tr>
<tr>
<td>-f</td>
<td>强制创建文件或目录的链接</td>
</tr>
<tr>
<td>-i</td>
<td>覆盖前先询问</td>
</tr>
<tr>
<td>-v</td>
<td>显示创建链接的过程</td>
</tr>
</tbody></table>
<pre><code>[root@linuxprobe ~]# echo &quot;Welcome to linuxprobe.com&quot; &gt; readme.txt
[root@linuxprobe ~]# ln -s readme.txt readit.txt
[root@linuxprobe ~]# cat readme.txt 
 Welcome to linuxprobe.com
[root@linuxprobe ~]# cat readit.txt 
 Welcome to linuxprobe.com
[root@linuxprobe ~]# ls -l readme.txt 
 -rw-r--r-- 1 root root 26 Jan 11 00:08 readme.txt
[root@linuxprobe ~]# rm -f readme.txt 
[root@linuxprobe ~]# cat readit.txt 
 cat: readit.txt: No such file or directory</code></pre>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第6章节：存储结构与磁盘划分</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：安装samba服务时packagekit报错解决方法</title>
    <url>/2021/02/12/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E5%AE%89%E8%A3%85samba%E6%9C%8D%E5%8A%A1%E6%97%B6packagekit%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在linux虚拟机Redhat7.0版本系统终端中输入命令：yum install samba，安装samba服务时，在安装过程中，出现以下报错信息：</p>
<a id="more"></a>

<pre><code>Error: initscripts conflicts with redhat-release-server-7.0-1.el7.x86_64
 You could try using --skip-broken to work around the problem
Found 2 pre-existing rpmdb problem(s), &#39;yum check&#39; output follows:
PackageKit-0.8.9-11.el7.x86_64 has missing requires of PackageKit-backend
rhn-check-2.0.2-5.el7.noarch has missing requires of yum-rhn-plugin &gt;= (&#39;0&#39;, &#39;1.6.4&#39;, &#39;1&#39;)</code></pre>
<p>有2个problem，1个error；先解决problem：</p>
<pre><code>（1）在http://rpm.pbone.net/网站中下载PackageKit-yum-0.8.9-11.el7.x86_64.rpm,然后将rpm文件拖入linux系统中，输入命令：rpm -Uvh PackageKit-yum-0.8.9-11.el7.x86_64.rpm，解决第1个problem。
（2）在终端中输入命令：yum install yum-rhn-plugin，解决第2个problem。</code></pre>
<p>再解决initscripts conflicts的error：</p>
<pre><code>首先，先查一下本机的initscripts的版本，有没有更适合自己系统的，输入以下命令：yum list initscripts，

显示以下信息：

Loading mirror speeds from cached hostfile
Installed Packages
initscripts.x86_64                9.49.17-1.el7                @anaconda/7.0
Available Packages
initscripts.x86_64                9.49.53-1.el7_9.1                updates  

说明当前版本是initscripts.x86_64  9.49.17-1.el7   @anaconda/7.0  

可以用更适合系统的initscripts.x86_64   9.49.53-1.el7_9.1版本来替换。

再输入命令：yum list centos-release，看看合适的centos-release版本：

Loading mirror speeds from cached hostfile
Available Packages
centos-release.x86_64               7-9.2009.1.el7.centos                updates

使用以上命令可以知道，最合适的版本是centos-release.x86_64  7-9.2009.1.el7.centos

从http://rpm.pbone.net/网站中分别下载initscripts-9.49.53-1.el7.x86_64.rpm和centos-release-7-9.2009.1.el7.centos.x86_64.rpm，然后输入命令：rpm -e redhat-release-server-7.0-1.el7.x86_64 --nodeps，将有冲突的版本删掉，删除redhat-release以后，不重启机器，马上安装centos-release.x86_64：

[root@linuxprobe Desktop]# rpm -Uvh centos-release-7-9.2009.1.el7.centos.x86_64.rpm
Preparing...                          ################################# [100%]
Updating / installing...
   1:centos-release-7-9.2009.1.el7.cenwarning: /etc/yum.repos.d/CentOS-Base.repo created as /etc/yum.repos.d/CentOS-Base.repo.rpmnew
################################# [100%]
error: unpacking of archive failed on file /usr/share/doc/redhat-release: cpio: rename failed - Is a directory
error: centos-release-7-9.2009.1.el7.centos.x86_64: install failed</code></pre>
<p>安装时出错！提示“/usr/share/doc/redhat-release 失败：cpio: rename 失败 - 是一个目录”</p>
<p>推测：安装centos-release时，这个redhat-release目录碍事了，所以我们手动把它删除掉（注意备份）。</p>
<pre><code>[root@linuxprobe doc]# rm -r /usr/share/doc/redhat-release 
rm：是否删除目录 &quot;/usr/share/doc/redhat-release&quot;？y

如果还是报错，则再在/usr/share目录中删除redhat-release：

[root@linuxprobe share]# rm -r /usr/share/redhat-release 
rm：是否删除目录 &quot;/usr/share/redhat-release&quot;？y

然后再终端中输入命令：rpm -Uvh centos-release-7-9.2009.1.el7.centos.x86_64.rpm：

[root@linuxprobe Desktop]# rpm -Uvh centos-release-7-9.2009.1.el7.centos.x86_64.rpm
Preparing...                          ################################# [100%]
Updating / installing...
  1:centos-release-7-9.2009.1.el7.cenwarning: /etc/yum.repos.d/CentOS-Base.repo created as /etc/yum.repos.d/CentOS-Base.repo.rpmnew
################################# [100%]</code></pre>
<p>到这一步，基本安装samba服务过程中的problem和error都已经解决，但此时如果输入yum install samba命令安装samba服务时，</p>
<p>可能会引起SELinux的报警，因此需要将SELinux关闭；在/etc/selinux/config配置文件中查看SELinux的默认状态。如果是</p>
<p>enforcing，建议赶紧修改为permissive或disabled；SELinux服务的主配置文件中，定义的是SELinux的默认运行状态，可以将其</p>
<p>理解为系统重启后的状态，因此它不会在更改后立即生效。可以使用getenforce命令获得当前SELinux服务的运行模式：</p>
<pre><code>[root@linuxprobe ~]# getenforce 
Enforcing</code></pre>
<p>再用setenforce [0|1]命令修改SELinux当前的运行模式（0为禁用，1为启用）。注意，这种修改只是临时的，在系统重启后就会失效：</p>
<pre><code>[root@linuxprobe ~]# setenforce 0
[root@linuxprobe ~]# getenforce
Permissive</code></pre>
<p>之后在终端中输入：yum install samba，安装samba服务，成功！</p>
<p>具体方法可参考以下链接：</p>
<p><a href="http://www.likecs.com/default/index/show?id=20904">http://www.likecs.com/default/index/show?id=20904</a><br><a href="https://blog.csdn.net/zz24_com/article/details/105127746">https://blog.csdn.net/zz24_com/article/details/105127746</a></p>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>安装samba服务时packagekit报错解决方法</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：用户身份与文件权限</title>
    <url>/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h1 id="1-用户身份与能力"><a href="#1-用户身份与能力" class="headerlink" title="1.用户身份与能力"></a>1.用户身份与能力</h1><p>管理员UID为0：系统的管理员用户。</p>
<p>系统用户UID为1～999： Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会有独立的系统用户负责运行，进而有效控制被破坏范围。</p>
<p>普通用户UID从1000开始：是由管理员创建的用于日常工作的用户。</p>
<a id="more"></a>
<p>一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p>
<p>（1）useradd：用于创建新的用户；默认的用户家目录会被存放在/home目录中，默认的Shell解释器为/bin/bash，而且默认会创建一个与该用户同名的基本用户组。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-d</td>
<td>指定用户的家目录</td>
</tr>
<tr>
<td>-u</td>
<td>指定该用户的默认UID</td>
</tr>
<tr>
<td>-g</td>
<td>指定一个初始的用户基本组（必须已存在）</td>
</tr>
<tr>
<td>-G</td>
<td>指定一个或多个扩展用户组</td>
</tr>
<tr>
<td>-s</td>
<td>指定该用户的默认Shell解释器</td>
</tr>
</tbody></table>
<p>/sbin/nologin，它是终端解释器中的一员，与Bash解释器有着天壤之别。一旦用户的解释器被设置为nologin，则代表该用户不能登录到系统中：</p>
<p>（2）groupadd:用于创建用户组；</p>
<p>（3）usermod：用于修改用户属性；用户的信息保存在/etc/passwd文件中，可以直接用文本编辑器来修改其中的用户参数项目，也可以用usermod命令修改已经创建的用户信息，诸如用户的UID、基本/扩展用户组、默认终端等。  </p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-d -m</td>
<td>参数-m与参数-d连用，可重新指定用户的家目录并自动把旧的数据转移过去</td>
</tr>
<tr>
<td>-g</td>
<td>变更所属用户组</td>
</tr>
<tr>
<td>-G</td>
<td>变更扩展用户组</td>
</tr>
<tr>
<td>-L</td>
<td>锁定用户禁止其登录系统</td>
</tr>
<tr>
<td>-U</td>
<td>解锁用户，允许其登陆系统</td>
</tr>
<tr>
<td>-s</td>
<td>变更默认终端</td>
</tr>
</tbody></table>
<p>（4）passwd：用于修改用户密码、过期时间、认证信息等；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td>锁定用户禁止其登录系统</td>
</tr>
<tr>
<td>-u</td>
<td>解锁用户，允许其登陆系统</td>
</tr>
<tr>
<td>–stdin</td>
<td>允许通过标准输入修改用户密码，如echo “NewPassWord”</td>
</tr>
<tr>
<td>-d</td>
<td>使该用户可用空密码登录系统</td>
</tr>
<tr>
<td>-e</td>
<td>强制用户在下次登录时修改密码</td>
</tr>
<tr>
<td>-S</td>
<td>显示用户的密码是否被锁定，以及密码所采用的加密算法名称</td>
</tr>
</tbody></table>
<p>（5）userdel：用于删除用户；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-f</td>
<td>强制删除用户</td>
</tr>
<tr>
<td>-r</td>
<td>同时删除用户及用户家目录</td>
</tr>
</tbody></table>
<h1 id="2-文件权限与归属"><a href="#2-文件权限与归属" class="headerlink" title="2.文件权限与归属"></a>2.文件权限与归属</h1><p> -：普通文件；d：目录文件；l：链接文件；b：块设备文件；c：字符设备文件；p：管道文件</p>
<p>对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。</p>
<p>对目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p>
<h2 id="2-1-文件的特殊权限"><a href="#2-1-文件的特殊权限" class="headerlink" title="2.1 文件的特殊权限"></a>2.1 文件的特殊权限</h2><p>详细内容可参考：<a href="https://www.cnblogs.com/sparkdev/p/9651622.html%EF%BC%9B">https://www.cnblogs.com/sparkdev/p/9651622.html；</a></p>
<p>（1）SUID：让执行者临时获得命令的所有者的权限；</p>
<p>（2）SGID：目录内新文件所有组，继承原有目录所有组的名称！</p>
<p>1.SUID<br>在 Linux 中，所有账号的密码记录在 /etc/shadow 这个文件中，并且只有 root 可以读写入这个文件：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/1.png" class>

<p>如果另一个普通账号 tester 需要修改自己的密码，就要访问 /etc/shadow 这个文件。但是明明只有 root 才能访问 /etc/shadow 这个文件，这究竟是如何做到的呢？事实上，tester 用户是可以修改 /etc/shadow 这个文件内的密码的，就是通过 SUID 的功能。让我们看看 passwd 程序文件的权限信息：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/2.png" class>

<p>上图红框中的权限信息有些奇怪，owner 的信息为 rws 而不是 rwx。当 s 出现在文件拥有者的 x 权限上时，就被称为 SETUID BITS 或 SETUID ，其特点如下：</p>
<p>-SUID 权限仅对二进制可执行文件有效<br>-如果执行者对于该二进制可执行文件具有 x 的权限，执行者将具有该文件的所有者的权限<br>-本权限仅在执行该二进制可执行文件的过程中有效</p>
<p>下面我们来看 tester 用户是如何利用 SUID 权限完成密码修改的：</p>
<pre><code>(1)tester 用户对于 /usr/bin/passwd 这个程序具有执行权限，因此可以执行 passwd 程序
(2)passwd 程序的所有者为 root
(3)tester 用户执行 passwd 程序的过程中会暂时获得 root 权限
(4)因此 tester 用户在执行 passwd 程序的过程中可以修改 /etc/shadow 文件</code></pre>
<p>但是如果由 tester 用户执行 cat 命令去读取 /etc/shadow 文件确是不行的：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/3.png" class>

<p>原因很清楚，tester 用户没有读 /etc/shadow 文件的权限，同时 cat 程序也没有被设置 SUID。我们可以通过下图来理解这两种情况：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/4.png" class>

<p>如果想让任意用户通过 cat 命令读取 /etc/shadow 文件的内容也是非常容易的，给它设置 SUID 权限就可以了：</p>
<p>$ sudo chmod 4755 /bin/cat</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/5.png" class>

<p>现在 cat 已经具有了 SUID 权限，试试看，是不是已经可以 cat 到 /etc/shadow 的内容了。因为这样做非常不安全，所以赶快通过下面的命令把 cat 的 SUID 权限移除掉：</p>
<p>$ sudo chmod 755 /bin/cat</p>
<p>2.SGID</p>
<p>当 s 标志出现在用户组的 x 权限时称为 SGID。SGID 的特点与 SUID 相同，我们通过 /usr/bin/mlocate 程序来演示其用法。mlocate 程序通过查询数据库文件 /var/lib/mlocate/mlocate.db 实现快速的文件查找。 mlocate 程序的权限如下图所示：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/6.png" class>

<p>很明显，它被设置了 SGID 权限。下面是数据库文件 /var/lib/mlocate/mlocate.db 的权限信息：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/7.png" class>

<p>普通用户 tester 执行 mlocate 命令时，tester 就会获得用户组 mlocate 的执行权限，又由于用户组 mlocate 对 mlocate.db 具有读权限，所以 tester 就可以读取 mlocate.db 了。程序的执行过程如下图所示：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/8.png" class>

<p>除二进制程序外，SGID 也可以用在目录上。当一个目录设置了 SGID 权限后，它具有如下功能：</p>
<pre><code>(1)用户若对此目录具有 r 和 x 权限，该用户能够进入该目录
(2)用户在此目录下的有效用户组将变成该目录的用户组
(3)若用户在此目录下拥有 w 权限，则用户所创建的新文件的用户组与该目录的用户组相同</code></pre>
<p>下面看个例子，创建 testdir 目录，目录的权限设置如下：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/9.png" class>

<p>此时目录 testdir 的 owner 是 nick，所属的 group 为 tester。<br>先创建一个名为 nickfile 的文件：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/10.png" class>

<p>这个文件的权限看起来没有什么特别的。然后给 testdir 目录设置 SGID 权限：</p>
<p>$ sudo chmod 2775 testdir</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/11.png" class>

<p>然后再创建一个文件 nickfile2：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/12.png" class>

<p>新建的文件所属的组为 tester！</p>
<p>总结一下，当 SGID 作用于普通文件时，和 SUID 类似，在执行该文件时，用户将获得该文件所属组的权限。当 SGID 作用于目录时，意义就非常重大了。当用户对某一目录有写和执行权限时，该用户就可以在该目录下建立文件，如果该目录用 SGID 修饰，则该用户在这个目录下建立的文件都是属于这个目录所属的组。</p>
<p>SBIT<br>其实 SBIT 与 SUID 和 SGID 的关系并不大。<br>SBIT 是 the  restricted  deletion  flag  or  sticky  bit 的简称。<br>SBIT 目前只对目录有效，用来阻止非文件的所有者删除文件。比较常见的例子就是 /tmp 目录：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/13.png" class>

<p>权限信息中最后一位 t 表明该目录被设置了 SBIT 权限。SBIT 对目录的作用是：当用户在该目录下创建新文件或目录时，仅有自己和 root 才有权力删除。</p>
<p>设置 SUID、SGID、SBIT 权限<br>以数字的方式设置权限<br>SUID、SGID、SBIT 权限对应的数字如下：</p>
<p>SUID-&gt;4<br>SGID-&gt;2<br>SBIT-&gt;1<br>所以如果要为一个文件权限为 “-rwxr-xr-x” 的文件设置 SUID 权限，需要在原先的 755 前面加上 4，也就是 4755：</p>
<p>$ chmod 4755 filename</p>
<p>同样，可以用 2 和 1 来设置 SGID 和 SBIT 权限。设置完成后分别会用 s, s, t 代替文件权限中的 x。</p>
<p>其实，还可能出现 S 和 T 的情况。S 和 t 是替代 x 这个权限的，但是，如果它本身没有 x 这个权限，添加 SUID、SGID、SBIT 权限后就会显示为大写 S 或大写 T。比如我们为一个权限为 666 的文件添加 SUID、SGID、SBIT 权限：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/14.png" class>

<p>执行 chmod 7666 nickfile，因为 666 表示 “-rw-rw-rw”，均没有 x 权限，所以最后变成了 “-rwSrwSrwT”。</p>
<p>通过符号类型改变权限</p>
<p>除了使用数字来修改权限，还可以使用符号：</p>
<p>$ chmod u+s testfile # 为 testfile 文件加上 SUID 权限。<br>$ chmod g+s testdir  # 为 testdir 目录加上 SGID 权限。<br>$ chmod o+t testdir  # 为 testdir 目录加上 SBIT 权限。</p>
<p>总结<br>SUID、SGID、SBIT 权限都是为了实现特殊功能而设计的，其目的是弥补 ugo 权限无法实现的一些使用场景。</p>
<h2 id="2-2文件的隐藏属性"><a href="#2-2文件的隐藏属性" class="headerlink" title="2.2文件的隐藏属性"></a>2.2文件的隐藏属性</h2><p>linux文件除了具备一般权限和特殊权限外，还具有隐藏权限；  </p>
<p>1.chattr：用于设置文件的隐藏权限，添加隐藏功能“+参数”，移除隐藏功能“-参数”。  </p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而不能新建或删除文件</td>
</tr>
<tr>
<td>a</td>
<td>仅允许补充（追加）内容，无法覆盖/删除内容（Append Only）</td>
</tr>
<tr>
<td>s</td>
<td>彻底从硬盘中删除，不可恢复（用0填充原文件所在硬盘区域）</td>
</tr>
<tr>
<td>A</td>
<td>不再修改这个文件或目录的最后访问时间（atime）</td>
</tr>
<tr>
<td>b</td>
<td>不再修改文件或目录的存取时间</td>
</tr>
<tr>
<td>u</td>
<td>当删除该文件后依然保留其在硬盘中的数据，方便日后恢复</td>
</tr>
</tbody></table>
<p>2.lsattr：用于显示文件的隐藏权限；</p>
<h2 id="2-3-文件访问控制列表"><a href="#2-3-文件访问控制列表" class="headerlink" title="2.3 文件访问控制列表"></a>2.3 文件访问控制列表</h2><p>一般权限、特殊权限、隐藏权限其实有一个共性—权限是针对某一类用户设置的；如果需要对某个指定的用户进行单独的权限控制，就需要用到文件访问控制列表（ACL);如果针对某个目录设置了ACL，则目录中的文件会继承其ACL；若针对文件设置了ACL，则文件不再继承其所在目录的ACL。</p>
<p>1.setfacl：可以针对单一用户或用户组、单一文件或目录来进行读/写/执行权限的控制。<br>-R：针对目录文件；    -m：针对普通文件；    -b：删除文件的ACL</p>
<pre><code>[root@linuxprobe ~]# setfacl -Rm u:linuxprobe:rwx /root
[root@linuxprobe ~]# su - linuxprobe
Last login: Sat Mar 21 15:45:03 CST 2017 on pts/1
[linuxprobe@linuxprobe ~]$ cd /root
[linuxprobe@linuxprobe root]$ ls
anaconda-ks.cfg Downloads Pictures Public
[linuxprobe@linuxprobe root]$ cat anaconda-ks.cfg
[linuxprobe@linuxprobe root]$ exit</code></pre>
<p>当文件权限的最后一个点（.）变成（+）时，意味着文件设置了ACL。</p>
<p>2.getfacl：用于显示文件的ACL信息；</p>
<h2 id="2-4-su命令与sudo服务"><a href="#2-4-su命令与sudo服务" class="headerlink" title="2.4 su命令与sudo服务"></a>2.4 su命令与sudo服务</h2><p>su命令可以解决切换用户身份的需求，使得当前用户在不退出登录的情况下，顺畅地切换到其他用户；上面的su命令与用户名之间有一个减号（-），这意味着完全切换到新的用户，即把环境变量信息也变更为新用户的相应信息，而不是保留原始的信息。</p>
<p>sudo命令用于给普通用户提供额外的权限来完成原本root管理员才能完成的任务，格式为“sudo [参数] 命令名称”。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td>列出当前用户可执行的命令</td>
</tr>
<tr>
<td>-u</td>
<td>以指定的用户身份执行命令</td>
</tr>
<tr>
<td>-k</td>
<td>清空密码的有效时间，下次执行sudo时需要再次进行密码验证</td>
</tr>
<tr>
<td>-b</td>
<td>在后台执行指定的命令</td>
</tr>
<tr>
<td>-p</td>
<td>更改询问密码的提示语</td>
</tr>
</tbody></table>
<p>配置文件（/etc/sudoers）提供集中的用户管理、权限与主机等参数；只有root管理员才可以使用visudo命令编辑sudo服务的配置文件。  </p>
<pre><code>谁可以使用  允许使用的主机=（以谁的身份）  可执行命令的列表
99 linuxprobe ALL=(ALL) ALL
99 linuxprobe ALL=(ALL) /usr/bin/cat（命令的绝对路径）
99 linuxprobe ALL=NOPASSWD: /usr/sbin/poweroff</code></pre>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第5章节：用户身份与文件权限</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：管道符、重定向与环境变量</title>
    <url>/2021/01/09/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%AE%A1%E9%81%93%E7%AC%A6%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="1-输入输出重定向"><a href="#1-输入输出重定向" class="headerlink" title="1.输入输出重定向"></a>1.输入输出重定向</h1><p>输入重定向：是指把文件导入到命令中； 输出重定向：是指把原本要输出到屏幕的数据写入到指定文件中。输出重定向又分为标准输出重定向和错误输出重定向。<br>输入重定向中用到的符号及其作用：</p>
<a id="more"></a>


<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>命令 &lt; 文件</td>
<td>将文件作为命令的标准输入</td>
</tr>
<tr>
<td>命令 &lt;&lt; 分界符（tag）</td>
<td>将开始标记 tag 和结束标记 tag 之间的内容作为输入</td>
</tr>
</tbody></table>
<p>输入重定向中用到的符号及其作用：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>命令 &gt; 文件</td>
<td>将输出重定向到文件（会清空原有数据）</td>
</tr>
<tr>
<td>命令 &gt;&gt; 文件</td>
<td>将输出以追加的方式重定向到文件</td>
</tr>
<tr>
<td>n &gt; 文件</td>
<td>将文件描述符为 n 的文件重定向到文件</td>
</tr>
<tr>
<td>n &gt;&gt; 文件</td>
<td>将文件描述符为 n 的文件以追加的方式重定向到文件</td>
</tr>
<tr>
<td>n &gt;&amp; m</td>
<td>将输出文件 m 和 n 合并</td>
</tr>
<tr>
<td>n &lt;&amp; m</td>
<td>将输入文件 m 和 n 合并</td>
</tr>
<tr>
<td>&lt;&lt; tag</td>
<td>将开始标记 tag 和结束标记 tag 之间的内容作为输入</td>
</tr>
</tbody></table>
<p>注意：文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p>
<h1 id="2-管道命令符"><a href="#2-管道命令符" class="headerlink" title="2. 管道命令符"></a>2. 管道命令符</h1><p>命令符：可以把前一个命令原本要输出到屏幕的数据当作是后一个命令的标准输入；</p>
<h1 id="3-命令行的通配符"><a href="#3-命令行的通配符" class="headerlink" title="3.命令行的通配符"></a>3.命令行的通配符</h1><p>星号（*）：代表匹配零个或多个字符； 问号（？）：代表匹配单个字符； [0-9]:代表匹配0-9之间的单个数字； [abc]:代表匹配a、b、c三个字符中的任意一个；<br>[^…]和[!…]表示匹配不在方括号里面的字符（不包括空字符）；这两种写法是等价的。</p>
<h1 id="4-转义字符"><a href="#4-转义字符" class="headerlink" title="4.转义字符"></a>4.转义字符</h1><p>反斜杠（\）：使反斜杠后面变量称为单纯的字符串；<br>单引号（’’）：转义其中所有的变量为单纯的字符串；<br>双引号（””）:保留其中的变量属性，不尽兴转义处理；<br>反引号（``）:把其中的命令执行后返回结果。</p>
<h1 id="5-环境变量"><a href="#5-环境变量" class="headerlink" title="5.环境变量"></a>5.环境变量</h1><p>变量是计算机系统用于保存可变值得数据类型，变量名称一般都是大写的；环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录、邮件存放位置等。</p>
<p>前面讲过，在 Linux 系统中“一切皆文件”，Linux 命令也不例外。那么，当编辑完成 Linux 命令并回车后，系统底层到底发生了什么事情呢？</p>
<p>简单来说，Linux 命令的执行过程分为如下 4 个步骤。</p>
<pre><code>1) 判断路径
    判断用户是否以绝对路径或相对路径的方式输入命令（如 /bin/ls），如果是的话直接执行。

2) 检查别名
    Linux 系统会检查用户输入的命令是否为“别名命令”。要知道，通过 alias 命令是可以给现有命令自定义别名的，即用一个自定义的命令名称来替换原本的命令名称。

    例如，我们经常使用的 rm 命令，其实就是 rm -i 这个整体的别名：
    [root@localhost ~]# alias rm
    alias rm=&#39;rm -i&#39;

    这使得当使用 rm 命令删除指定文件时，Linux 系统会要求我们再次确认是否执行删除操作。例如：
    [root@localhost ~]# rm a.txt &lt;-- 假定当前目录中已经存在 a.txt 文件
    rm: remove regular file &#39;a.txt&#39;? y  &lt;-- 手动输入 y，即确定删除
    [root@localhost ~]#

    这里可以使用 unalias 命令，将 Linux 系统设置的 rm 别名删除掉，执行命令如下：
    [root@localhost ~]# alias rm
    alias rm=&#39;rm -i&#39;
    [root@localhost ~]# unalias rm
    [root@localhost ~]# rm a.txt
    [root@localhost ~]#  &lt;--直接删除，不再询问


    注意，这里仅是为了演示 unalisa 的用法，建议读者删除 rm 别名之后，再手动添加到系统中，执行如下命令即可再次成功添加：
    [root@localhost ~]# alias rm=&#39;rm -i&#39;

3) 判断是内部命令还是外部命令
    Linux命令行解释器（又称为 Shell）会判断用户输入的命令是内部命令还是外部命令。其中，内部命令指的是解释器内部的命令，会被直接执行；而用户通常输入的命令都是外部命令，这些命令交给步骤四继续处理。
    内部命令由 Shell 自带，会随着系统启动，可以直接从内存中读取；而外部命令仅是在系统中有对应的可执行文件，执行时需要读取该文件。

    判断一个命令属于内部命令还是外部命令，可以使用 type 命令实现。例如：
    [root@localhost ~]# type pwd
    pwd is a shell builtin  &lt;-- pwd是内部命令
    [root@localhost ~]# type top
    top is /usr/bin/top  &lt;-- top是外部命令

4) 查找外部命令对应的可执行文件
    当用户执行的是外部命令时，系统会在指定的多个路径中查找该命令的可执行文件，而定义这些路径的变量，就称为 PATH 环境变量，其作用就是告诉 Shell 待执行命令的可执行文件可能存放的位置，也就是说，Shell 会在 PATH 变量包含的多个路径中逐个查找，直到找到为止（如果找不到，Shell 会提供用户“找不到此命令”）</code></pre>
<p>自己创建的变量不具有全局性，作用范围有限，默认情况下不能被其他用户使用，因此，可通过export命令（如：export WORKDIR）将其提升为全局变量，这样其他用户也可以使用了！</p>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第3章节：管道符、重定向与环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title>linux虚拟机外网网络访问设置指南</title>
    <url>/2021/02/07/linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%96%E7%BD%91%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>要达到的效果就是在Linux虚拟机中可以上网：ping <a href="http://www.baidu.com/">http://www.baidu.com</a></p>
<p>VMware中安装完 redhat7 后， 默认初始配置如下：</p>
<a id="more"></a>

<h1 id="1-VMware-网络配置"><a href="#1-VMware-网络配置" class="headerlink" title="1.VMware 网络配置"></a>1.VMware 网络配置</h1><p>（编辑 –&gt; 虚拟网络编辑器）查看</p>
<p>默认配置为： (这些配置都不需要发生变更， 看看就好)</p>
<pre><code>子网IP：192.168.154.0

子网掩码 : 255.255.255.0

可设置的IP网段为： 192.168.154.128 ~ 254

&#123;% asset_img 1.jpg %&#125;

点开 NAT设置可以看到 GATEWAY : 192.168.154.2:</code></pre>
<img src="/2021/02/07/linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%96%E7%BD%91%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/2.jpg" class>

<p>下面介绍 redhat 本身配置m修改配置参数如下：</p>
<p>注意各个参数与第一步 VMware 中的默认配置的联系 :</p>
<pre><code>BOOTPROTO ： dhcp --&gt; static （静态IP）

ONBOOT : no --&gt; YES (开机自动连接网络)

IPADDR : 192.168.154.128 ~ 254 之间即可

NETMASK : 子网， 与 VMware 默认一致

GATEWAY : 网关， 与VMware 默认一致

DNS1 : 首选 DNS, 不配置会出现外网不通， 只能与内网互通的问题.

这里DNS要说一下的是，其他资料上有说要跟本机上网的DNS一致，还有说跟网关一致，或者改成8.8.8.8，都试过，ping www.baidu.com 都可以，不同的机器可能有不同，希望可以共同探讨。

NM_CONTROLLED : “NM_CONTROLLED=no”表示该接口将通过该配置文件进行设置，而不是通过网络管理器进行管理。“ONBOOT=yes”告诉我们，系统将在启动时开启该接口。</code></pre>
<p>编辑/etc/sysconfig/network-scipts/网卡名称：</p>
<img src="/2021/02/07/linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%96%E7%BD%91%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/3.jpg" class>

<img src="/2021/02/07/linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%96%E7%BD%91%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/4.jpg" class>

<img src="/2021/02/07/linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%96%E7%BD%91%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/5.jpg" class>

<p>重启网络服务命令： systemctl restart network；</p>
<img src="/2021/02/07/linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%96%E7%BD%91%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/6.jpg" class>
















]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>linux虚拟机外网网络访问设置指南</tag>
      </tags>
  </entry>
  <entry>
    <title>liunx就该这么学-16：使用Squid部署代理缓存服务</title>
    <url>/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="1-代理缓存服务"><a href="#1-代理缓存服务" class="headerlink" title="1.代理缓存服务"></a>1.代理缓存服务</h1><a id="more"></a>

<p>Squid是Linux系统中最为流行的一款高性能代理服务软件，通常用作Web网站的前置缓存服务，能够代替用户向网站服务器请求页面数据并进行缓存。简单来说，Squid服务程序会按照收到的用户请求向网站源服务器请求页面、图片等所需的数据，并将服务器返回的数据存储在运行Squid服务程序的服务器上。当有用户再请求相同的数据时，则可以直接将存储服务器本地的数据交付给用户，这样不仅减少了用户的等待时间，还缓解了网站服务器的负载压力。</p>
<p>在使用Squid服务程序为用户提供缓存代理服务时，具有正向代理模式和反向代理模式之分。</p>
<p>所谓正向代理模式，是指让用户通过Squid服务程序获取网站页面等资源，以及基于访问控制列表（ACL）功能对用户访问网站行为进行限制，在具体的服务方式上又分为标准代理模式与透明代理模式。标准正向代理模式是把网站数据缓存到服务器本地，提高数据资源被再次访问时的效率，但是用户在上网时必须在浏览器等软件中填写代理服务器的IP地址与端口号信息，否则默认不使用代理服务。而透明正向代理模式的作用与标准正向代理模式基本相同，区别是用户不需要手动指定代理服务器的IP地址与端口号，所以这种代理服务对于用户来讲是相对透明的。</p>
<p>Squid服务程序提供正向代理服务：</p>
<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/1.png" class>

<p>反向代理模式是指让多台节点主机反向缓存网站数据，从而加快用户访问速度。因为一般来讲，网站中会普遍加载大量的文字、图片等静态资源，而且它们相对来说都是比较稳定的数据信息，当用户发起网站页面中这些静态资源的访问请求时，我们可以使用Squid服务程序提供的反向代理模式来进行响应。而且，如果反向代理服务器中恰巧已经有了用户要访问的静态资源，则直接将缓存的这些静态资源发送给用户，这不仅可以加快用户的网站访问速度，还在一定程度上降低了网站服务器的负载压力。</p>
<p>Squid服务程序提供的反向代理模式:</p>
<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/2.png" class>

<h1 id="2-配置Squid服务程序"><a href="#2-配置Squid服务程序" class="headerlink" title="2.配置Squid服务程序"></a>2.配置Squid服务程序</h1><p>Squid服务程序的配置步骤虽然十分简单，但依然需要为大家交代一下实验所需的设备以及相应的设置。首先需要准备两台虚拟机，一台用作Squid服务器，另外一台用作Squid客户端；为了能够相互通信，需要将这两台虚拟机<strong>都设置为仅主机模式（Hostonly）</strong>，然后关闭其中一台虚拟机的电源，在添加一块新的网卡为<strong>桥接模式</strong>后开启电源：</p>
<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/3.png" class>

<p>需要注意的是，这块新添加的网卡设备必须选择为桥接模式，否则这两台虚拟机都无法访问外网。</p>
<p>设置好桥接模式后，虚拟机还不能连接外网，还需要到虚拟机的编辑-虚拟网络编辑器，对VMnet0的桥接网卡进行指定：</p>
<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/4.png" class>

<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/5.png" class>

<p>之后回到linux系统，在终端中输入命令：nm-connection-editor，新建网卡：</p>
<pre><code>[root@linuxprobe ~]#nm-connection-editor</code></pre>
<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/6.png" class>

<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/7.png" class>

<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/8.png" class>

<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/9.png" class>

<p>设置完成后，保存退出，之后重新启动网卡；也可以ping下网站，看是否能够成功：</p>
<pre><code>[root@linuxprobe ~]#systemctl restart network
[root@linuxprobe ~]#ping -c 4 www.baidu.com</code></pre>
<p>当前Squid服务器和客户端的操作系统和IP地址信息：</p>
<table>
<thead>
<tr>
<th>主机名称</th>
<th>操作系统</th>
<th>IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>Squid服务器</td>
<td>RHEL 7</td>
<td>外网卡：桥接DHCP模式</td>
</tr>
<tr>
<td></td>
<td></td>
<td>内网卡：192.168.10.10</td>
</tr>
<tr>
<td>Squid客户端</td>
<td>Windows 7/RHEL 7</td>
<td>192.168.10.20</td>
</tr>
</tbody></table>
<p>这样一来，我们就有了一台既能访问内网，又能访问外网的Squid服务器了；但当前的Squid服务器只能和外网或虚拟机间进行通讯，无法和宿主机进行连接；如果Squid服务器需要和宿主机间通过主机模式（host only）进行通讯的话，还需要在宿主机的VMnet1网络适配器进行以下设置：</p>
<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/10.png" class>

<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/11.png" class>

<p>至此，Squid服务器既能访问外网和内网，又能和宿主机进行通讯。</p>
<p>但有一个问题，Squid服务器目前有两个网卡，一个网卡连接外网，一个网卡连接内网；但/etc/sysconfig/network-scripts目录内只有内网网卡的配置文件，并没有生成外网网卡的配置文件；自己手动新建配置文件的话，重启网卡后反而无法连接外网，会报错，不太清楚原因所在，难道使用DHCP的外网网卡不需要配置文件？</p>
<p>当配置好Yum软件仓库并挂载好设备镜像后，就可以安装Squid服务程序了:</p>
<pre><code>[root@linuxprobe ~]# yum install squid</code></pre>
<p>Squid服务程序的配置文件也是存放在/etc/squid/squid.conf;常用的Squid服务程序配置参数以及作用:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>http_port 3128</td>
<td>监听的端口号</td>
</tr>
<tr>
<td>cache_mem 64M</td>
<td>内存缓冲区的大小</td>
</tr>
<tr>
<td>cache_dir ufs /var/spool/squid 2000 16 256</td>
<td>硬盘缓冲区的大小</td>
</tr>
<tr>
<td>cache_effective_user squid</td>
<td>设置缓存的有效用户</td>
</tr>
<tr>
<td>cache_effective_group squid</td>
<td>设置缓存的有效用户组</td>
</tr>
<tr>
<td>dns_nameservers</td>
<td>IP地址    一般不设置，而是用服务器默认的DNS地址</td>
</tr>
<tr>
<td>cache_access_log /var/log/squid/access.log</td>
<td>访问日志文件的保存路径</td>
</tr>
<tr>
<td>cache_log /var/log/squid/cache.log</td>
<td>缓存日志文件的保存路径</td>
</tr>
<tr>
<td>visible_hostname linuxprobe.com</td>
<td>设置Squid服务器的名称</td>
</tr>
</tbody></table>
<h1 id="3-正向代理"><a href="#3-正向代理" class="headerlink" title="3.正向代理"></a>3.正向代理</h1><h2 id="3-1标准正向代理"><a href="#3-1标准正向代理" class="headerlink" title="3.1标准正向代理"></a>3.1标准正向代理</h2><pre><code>[root@linuxprobe ~]# systemctl restart squid
[root@linuxprobe ~]# systemctl enable squid
ln -s &#39;/usr/lib/systemd/system/squid.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/squid.service&#39;</code></pre>
<p>接下来在Squid客户端进行操作，首先是windows7系统：</p>
<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/12.png" class>

<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/13.png" class>

<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/14.png" class>

<p>其次是RHEL 7系统,打开火狐浏览器:</p>
<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/15.png" class>

<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/16.png" class>

<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/17.png" class>

<p>需要注意的是，虽然在浏览器中已经设置好代理服务器，但目前在客户端系统上还不能连接外网；此时需要回到Squid服务器中，输入以下命令，清空防火墙：</p>
<pre><code>[root@linuxprobe ~]# iptables -F
[root@linuxprobe ~]# service iptables save</code></pre>
<p>至此，Squid客户端系统可以连接外网！</p>
<p>Squid服务程序默认使用3128、3401与4827等端口号，因此可以把默认使用的端口号修改为其他值，以便起到一定的保护作用：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/squid/squid.conf
………………省略部分输出信息………………
http_port 10000
………………省略部分输出信息………………
[root@linuxprobe ~]# systemctl restart squid 
[root@linuxprobe ~]# systemctl enable squid 
 ln -s &#39;/usr/lib/systemd/system/squid.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/squid.service&#39;</code></pre>
<p>尽管现在重启Squid服务程序后系统没有报错，但是用户还不能使用代理服务。SElinux安全子系统认为Squid服务程序使用3128端口号是理所当然的，因此在默认策略规则中也是允许的，但是现在Squid服务程序却尝试使用新的10000端口号，而该端口原本并不属于Squid服务程序应该使用的系统资源，因此还需要手动把新的端口号添加到Squid服务程序在SElinux域的允许列表中。</p>
<pre><code>[root@linuxprobe ~]# semanage port -l | grep squid_port_t
squid_port_t                   tcp      3128, 3401, 4827
squid_port_t                   udp      3401, 4827
[root@linuxprobe ~]# semanage port -a -t squid_port_t -p tcp 10000
[root@linuxprobe ~]# semanage port -l | grep squid_port_t
squid_port_t                   tcp      10000, 3128, 3401, 4827
squid_port_t                   udp      3401, 4827</code></pre>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第16章节：使用Squid部署代理缓存服务</tag>
      </tags>
  </entry>
  <entry>
    <title>liunx就该这么学：vim编辑器与Shell命令脚本</title>
    <url>/2021/01/09/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Avim%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8EShell%E5%91%BD%E4%BB%A4%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="1-Vim文本编辑器"><a href="#1-Vim文本编辑器" class="headerlink" title="1.Vim文本编辑器"></a>1.Vim文本编辑器</h1><p>注意：在linux系统中一切都是文件，而配置一个服务就是在修改其配置文件的参数；</p>
<p>Vim编辑器有三种模式：</p>
<pre><code>（1）命令模式：控制光标移动，可对文本进行复制、粘贴、删除和查找等操作（开机后默认进入命令模式）；
（2）输入模式：正常的文本录入（按a、i、o从命令模式进入输入模式，按Esc键退出输入模式）；
             a键和i键分别是在光标后一位和光标当前位置切换到输入模式，而o键则是在光标的下面再新建一个空行。
（3）末行模式：保存或退出文档，以及设置编辑环境（按：键进入末行模式，按Esc键退出输入模式）；</code></pre>
<a id="more"></a>
<p>命令模式中常用的命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>dd</td>
<td>删除（剪切）光标所在整行</td>
</tr>
<tr>
<td>5dd</td>
<td>删除（剪切）从光标处开始的5行</td>
</tr>
<tr>
<td>yy</td>
<td>复制光标所在整行</td>
</tr>
<tr>
<td>5yy</td>
<td>复制从光标处开始的5行</td>
</tr>
<tr>
<td>n</td>
<td>显示搜索命令定位到的下一个字符串</td>
</tr>
<tr>
<td>N</td>
<td>显示搜索命令定位到的上一个字符串</td>
</tr>
<tr>
<td>u</td>
<td>撤销上一步的操作</td>
</tr>
<tr>
<td>p</td>
<td>将之前删除（dd）或复制（yy）过的数据粘贴到光标后面</td>
</tr>
</tbody></table>
<p>末行模式中常用的命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>:w</td>
<td>保存</td>
</tr>
<tr>
<td>:q</td>
<td>退出</td>
</tr>
<tr>
<td>:q!</td>
<td>强制退出（放弃对文档的修改内容）</td>
</tr>
<tr>
<td>:wq!</td>
<td>强制保存退出</td>
</tr>
<tr>
<td>:set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>不显示行号</td>
</tr>
<tr>
<td>:命令</td>
<td>执行该命令</td>
</tr>
<tr>
<td>:整数</td>
<td>跳转到该行</td>
</tr>
<tr>
<td>:s/one/two</td>
<td>将当前光标所在行的第一个one替换成two</td>
</tr>
<tr>
<td>:s/one/two/g</td>
<td>将当前光标所在行的所有one替换成two</td>
</tr>
<tr>
<td>:%s/one/two/g</td>
<td>将全文中的所有one替换成two</td>
</tr>
<tr>
<td>?字符串</td>
<td>在文本中从下至上搜索该字符串</td>
</tr>
<tr>
<td>/字符串</td>
<td>在文本中从上至下搜索该字符串</td>
</tr>
</tbody></table>
<h1 id="2-配置主机名称"><a href="#2-配置主机名称" class="headerlink" title="2.配置主机名称"></a>2.配置主机名称</h1><p>1.使用Vim编辑器修改“/etc/hostname”中的主机名称，将原始主机名称删除后追加“想加入的主机名称”，修改完毕后记得在末行模式下输入：wq！命令保存文档；<br>2.使用hostname命令检查是否修改成功；  </p>
<p>注意：修改完毕后，有时主机名称不会立即同步到系统中，可重启虚拟机；  </p>
<h1 id="3-配置网卡信息"><a href="#3-配置网卡信息" class="headerlink" title="3.配置网卡信息"></a>3.配置网卡信息</h1><p>网卡IP地址配置的是否正确是两台服务器是否可以相互通信的前提；  </p>
<p>网卡信息配置步骤：  </p>
<pre><code>1.cd /etc/sysconfig/network-scripts （存放着网卡的配置文件)；
2.用Vim编辑器修改网卡文件ifcfg-eno16777728（每台仪器的网卡名称不一样，需要用ifconfig命令进行查询）；  

    -设备类型：TYPE=Ethernet
    -地址分配模式：BOOTPROTO=static
    -网卡名称：NAME=eno16777728
    -设备名称：DEVICE=eno1677728（不输入设备名称，在重启网卡时有报错，不太清楚原因）
    -是否启动：ONBOOT=yes
    -IP地址：IPADDR=192.168.10.10
    -子网掩码：NETMASK=255.255.255.0
    -网关地址：GATEWAY=192.168.10.1
    -DNS地址：DNS1=192.168.10.1

3.重启网络服务并测试网络是否联通：systemctl restart network     ping 192.168.10.10</code></pre>
<h1 id="4-配置Yum软件仓库"><a href="#4-配置Yum软件仓库" class="headerlink" title="4.配置Yum软件仓库"></a>4.配置Yum软件仓库</h1><p>配置YUM软件仓库的步骤如下：</p>
<pre><code>1.cd /etc/yum.repos.d/ （存放Yum软件仓库的配置文件）；
2.vim rhel7.repo的配置文件（文件名称随意，但后缀必须为.repo），在配置文件中写入下方的配置参数：
    [rhel7] （Yum软件仓库唯一标识符，避免与其他仓库冲突）
    name=rhel7 （Yum软件仓库的名称描述，易于识别仓库用处）
    baseurl=file:///media/cdrom （提供的方式包括FTP（ftp://..）、HTTP（http://..）、本地（file:///..））
    enabled=1 （设置此源是否可用；1为可用，0为禁用）
    gpgcheck=0 （设置此源是否校验文件；1为校验，0为不校验）
3.挂载光盘，并把光盘挂载信息写入到/etc/fstab文件中；
4.使用“yum install httpd -y”检查Yum软件仓库是否可用</code></pre>
<h1 id="5-编写Shell脚本"><a href="#5-编写Shell脚本" class="headerlink" title="5.编写Shell脚本"></a>5.编写Shell脚本</h1><p>Shell脚本内容可分为三部分：</p>
<pre><code>1.第一行的#！/bin/bash：用于告诉系统用哪种Shell解释器来执行该脚本；
2.第二行的#：是注释信息，用于对脚本功能和某些命令的介绍信息；
3.第三行之后的内容是可执行语句。</code></pre>
<h2 id="5-1-接受用户参数"><a href="#5-1-接受用户参数" class="headerlink" title="5.1 接受用户参数"></a>5.1 接受用户参数</h2><p>Shell脚本语言内置了用于接收参数的变量，变量之间使用空格间隔；如：$0对应当前Shell脚本名称，$#对应总共几个参数，$*对应所有位置的参数值，$？对应显示上一次命令的执行返回值，而$1、$2、$3…分别对应第N个位置的参数值。</p>
<h2 id="5-2-判断用户的参数"><a href="#5-2-判断用户的参数" class="headerlink" title="5.2 判断用户的参数"></a>5.2 判断用户的参数</h2><p>条件测试语句格式： [ 条件表达式 ]  两边各有一个空格</p>
<p>条件测试语句分为4种：文件测试语句、逻辑测试语句、整数值比较语句、字符串比较语句。</p>
<p>文件测试所用参数：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-d</td>
<td>文件是否为目录</td>
</tr>
<tr>
<td>-e</td>
<td>文件是否存在</td>
</tr>
<tr>
<td>-f</td>
<td>文件是否为一般文件</td>
</tr>
<tr>
<td>-r</td>
<td>当前用户是否有权限读取</td>
</tr>
<tr>
<td>-w</td>
<td>当前用户是否有权限写入</td>
</tr>
<tr>
<td>-x</td>
<td>当前用户是否有权限执行</td>
</tr>
</tbody></table>
<pre><code>[root@linuxprobe ~]# [ -d /etc/fstab ]
[root@linuxprobe ~]# echo $?
1（返回值如果为0，表示目录存在；为非零值，则表示目录不存在）</code></pre>
<p>逻辑语句运算符号：与（&amp;&amp;）、或（||）、非（！）；</p>
<p>&amp;&amp;：表示当前面的命令执行成功后才能执行后面的命令；<br>||：表示当前面的命令执行失败后才能执行后面的命令；<br>！：表示把条件测试中的判断结果取相反值。</p>
<p>整数比较运算符仅是对数字的操作，不能将数字与字符串、文件等内容一起操作，而且不能想当然地使用日常生活中的等号、大于号、小于号等来判断。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>是否等于</td>
</tr>
<tr>
<td>-ne</td>
<td>是否不等于</td>
</tr>
<tr>
<td>-gt</td>
<td>是否大于</td>
</tr>
<tr>
<td>-lt</td>
<td>是否小于</td>
</tr>
<tr>
<td>-le</td>
<td>是否等于或小于</td>
</tr>
<tr>
<td>-ge</td>
<td>是否大于或等于</td>
</tr>
</tbody></table>
<pre><code>[root@linuxprobe ~]# [ 10 -gt 10 ]
[root@linuxprobe ~]# echo $?
1
[root@linuxprobe ~]# [ 10 -eq 10 ]
[root@linuxprobe ~]# echo $?
0</code></pre>
<p>字符串比较语句用于判断测试字符串是否为空值，或两个字符串是否相同。</p>
<p>| 操作符 | 作用 |<br>| = | 比较字符串内容是否相同 |<br>| ！= | 比较字符串内容是否不同 |<br>| -z |  判断字符串内容是否为空 |</p>
<h2 id="5-3-流程控制语句"><a href="#5-3-流程控制语句" class="headerlink" title="5.3 流程控制语句"></a>5.3 流程控制语句</h2><p>1.if条件测试语句：可以让脚本根据实际情况自动执行相应的命令。从技术角度来讲，if语句分为单分支结构、双分支结构、多分支结构；</p>
<pre><code>（1）
if 条件测试操作
then 命令序列
fi

（2）
if 条件测试操作
then 命令序列1
else 命令序列2
fi

（2）
if 条件测试操作
then 命令序列1
elif 条件测试操作2
    then 命令序列2
else 命令序列2
fi</code></pre>
<p>2.for条件循环语句：允许脚本一次性读取多个信息，然后逐一对信息进行操作处理，当要处理的数据有范围时，使用for循环语句再适合不过了。</p>
<pre><code>for 变量名 in 取值列表
do
命令序列
done</code></pre>
<p>3.while条件循环语句：通过判断条件测试的真假来决定是否继续执行命令，若条件为真就继续执行，为假就结束循环。</p>
<pre><code>while 条件测试操作
do
    命令序列
done</code></pre>
<p>4.case条件测试语句：case语句是在多个范围内匹配数据，若匹配成功则执行相关命令并结束整个条件测试；而如果数据不在所列出的范围内，则会去执行星号（*）中所定义的默认命令。</p>
<pre><code>case 变量值 in
模式1）
    命令序列1
    ;;
模式2）
    命令序列2
    ;;
    ……
*）
    默认命令序列
esac</code></pre>
<p>5.计划任务服务程序</p>
<p>分为一次性计划任务和长期性计划任务；</p>
<p>一次性计划任务：写成“ at 时间 ”的形式，如果想要查看已设置好但还未执行的一次性计划任务，可以使用“at -l”命令；要想将其删除，可以用“atrm 任务序号”。</p>
<p>长期性计划任务：默认启用crond服务；创建、编辑计划任务的命令为“crontab -e”，查看当前计划任务的命令为“crontab -l”，删除某条计划任务的命令为“crontab -r”。口诀：“分、时、日、月、星期 命令”</p>
<p>注意：<br>（1）在crond服务的计划任务参数中，所有命令一定要用绝对路径的方式来写，如果不知道绝对路径，请用whereis命令进行查询。<br>（2）计划任务中的“分”字段必须有数值，绝对不能为空或是*号，而“日”和“星期”字段不能同时使用，否则就会发生冲突。</p>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第4章节：vim编辑器与Shell命令脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>图片加载命令</title>
    <url>/2020/12/07/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<img src="/2020/12/07/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%91%BD%E4%BB%A4/114.jpg" class>
]]></content>
  </entry>
  <entry>
    <title>用hexo和github免费创建自己的博客</title>
    <url>/2020/12/06/%E7%94%A8hexo%E5%92%8Cgithub%E5%85%8D%E8%B4%B9%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="1-安装Nodejs"><a href="#1-安装Nodejs" class="headerlink" title="1.安装Nodejs"></a>1.安装Nodejs</h2><p>官方网站: <a href="https://nodejs.org/">https://nodejs.org</a>, 安装步骤非常简单，一直next，下一步就可以了，默认安装就行。</p>
<h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h2><p>官方网站：<a href="https://git-scm.com/downloads%EF%BC%8C">https://git-scm.com/downloads，</a> 然后我们选择windows版本的下载，安装也是一直点下一步，安装官方默认的来就行，<br>tips：这个Git Bash下载下来就相当于Linux中的终端窗口了，以后我们就用这个东东来打开终端。</p>
<a id="more"></a>
<h2 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h2><p>新建一个文件夹，比如我这里建了blog；打开你的文件夹，然后在空白处点鼠标的右键，选择 ==Git Bash Here==；<br>看看 node，npm是否安装成功，没有成功的就重新安装node：<br>node -v    #查看node版本<br>npm -v    #查看npm版本<br>我们需要先来安装个cnpm提高速度，以后下载什么东西都用cnpm，在上面终端继续输入：<br>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a><br>测试cnpm-成功:<br>cnpm -v    #查看cnpm版本<br>完成之后安装hexo：<br>cnpm install -g hexo-cli    #安装hexo框架<br>验证是否安装成功：<br>hexo -v    #查看hexo版本<br>用pwd命令查看当前路径，然后新建文件夹blog1：<br>mkdir blog1    #创建blog1目录<br>cd blog1     #进入blog1目录目录<br>hexo init     #生成博客 初始化博客（用Git Bash运行）<br>hexo s    #启动本地博客服务<br><a href="http://localhost:4000/">http://localhost:4000/</a>    #本地访问地址<br>hexo n “我的第一篇文章” #创建新的文章 </p>
<h2 id="4-返回blog目录"><a href="#4-返回blog目录" class="headerlink" title="4.返回blog目录"></a>4.返回blog目录</h2><p>hexo clean #清理<br>hexo g #生成</p>
<h2 id="5-将博客部署到GitHub上"><a href="#5-将博客部署到GitHub上" class="headerlink" title="5.将博客部署到GitHub上"></a>5.将博客部署到GitHub上</h2><p>在Github创建一个新的仓库 YourGithubName.github.io<br>然后输入cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件</p>
<h2 id="6-配置-config-yml"><a href="#6-配置-config-yml" class="headerlink" title="6.配置_config.yml"></a>6.配置_config.yml</h2><pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
      type: git
     repo: https://github.com/YourGithubName/YourGithubName.github.io.git
      branch: master</code></pre>
<p>win10 记得在 hexo d 之前输入以下命令：<br>git config –global user.email “xxx”<br>git config –global user.name “xxx”<br>然后用hexo d命令将博客部署到Github仓库里<br><a href="https://yourgithubname.github.io/">https://YourGithubName.github.io/</a>  #访问这个地址可以查看博客<br>注：<br>如果在输入hexo d命令时，提示有以下报错：ERROR Deployer not found: git<br>则在hexo的文件目录内输入以下命令：npm install –save hexo-deployer-git，之后再次输入hexo d命令即可</p>
<h2 id="7-安装主题"><a href="#7-安装主题" class="headerlink" title="7.安装主题"></a>7.安装主题</h2><p>下载yilia主题到本地：git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia<br>修改hexo根目录下的 _config.yml 文件 ： theme: yilia<br>hexo c    #清理一下<br>hexo g    #生成<br>hexo d    #部署到远程Github仓库<br><a href="https://yourgithubname.github.io/">https://YourGithubName.github.io/</a>  #查看博客</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学-13：使用Bind提供域名解析服务</title>
    <url>/2021/02/13/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-13%EF%BC%9A%E4%BD%BF%E7%94%A8Bind%E6%8F%90%E4%BE%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="1-DNS域名解析服务"><a href="#1-DNS域名解析服务" class="headerlink" title="1.DNS域名解析服务"></a>1.DNS域名解析服务</h1><p>DNS：Domain Name System，域名系统。</p>
<a id="more"></a>

<p>主服务器：在特定区域内具有唯一性，负责维护该区域内的域名与IP地址之间的对应关系。</p>
<p>从服务器：从主服务器中获得域名与IP地址的对应关系并进行维护，以防主服务器宕机等情况。</p>
<p>缓存服务器：通过向其他域名解析服务器查询获得域名与IP地址的对应关系，并将经常查询的域名信息保存到服务器本地，以此来提高重复查询时的效率。</p>
<p>在执行用户发起的域名查询请求时，具有递归查询和迭代查询两种方式。所谓递归查询，是指DNS服务器在收到用户发起的请求时，必须向用户返回一个准确的查询结果。如果DNS服务器本地没有存储与之对应的信息，则该服务器需要询问其他服务器，并将返回的查询结果提交给用户。而迭代查询则是指，DNS服务器在收到用户发起的请求时，并不直接回复查询结果，而是告诉另一台DNS服务器的地址，用户再向这台DNS服务器提交请求，这样依次反复，直到返回查询结果。</p>
<h1 id="2-安装Bind服务程序"><a href="#2-安装Bind服务程序" class="headerlink" title="2.安装Bind服务程序"></a>2.安装Bind服务程序</h1><p>BIND：Berkeley Internet Name Domain，伯克利因特网名称域。</p>
<p>chroot：俗称牢笼机制。</p>
<pre><code>[root@linuxprobe ~]# yum install bind-chroot</code></pre>
<p>在bind服务程序中有下面这三个比较关键的文件：</p>
<pre><code>主配置文件（/etc/named.conf）：只有58行，而且在去除注释信息和空行之后，实际有效的参数仅有30行左右，这些参数用来定义bind服务程序的运行。

区域配置文件（/etc/named.rfc1912.zones）：用来保存域名和IP地址对应关系的所在位置。类似于图书的目录，对应着每个域和相应IP地址所在的具体位置，当需要查看或修改时，可根据这个位置找到相关文件。

数据配置文件目录（/var/named）：该目录用来保存域名和IP地址真实对应关系的数据配置文件。</code></pre>
<p>在Linux系统中，bind服务程序的名称为named。首先需要在/etc目录中找到该服务程序的主配置文件，然后把第11行和第17行的地址均修改为any，分别表示服务器上的所有IP地址均可提供DNS域名解析服务，以及允许所有人对本服务器发送DNS查询请求。这两个地方一定要修改准确。</p>
<pre><code> [root@linuxprobe ~]# vim /etc/named.conf
 1 //
 2 // named.conf
 3 //
 4 // Provided by Red Hat bind package to configure the ISC BIND named(8) DNS
 5 // server as a caching only nameserver (as a localhost DNS resolver only).
 6 //
 7 // See /usr/share/doc/bind*/sample/ for example named configuration files.
 8 //
 9 
 10 options &#123;
 11 listen-on port 53 &#123; any; &#125;;
 12 listen-on-v6 port 53 &#123; ::1; &#125;;
 13 directory &quot;/var/named&quot;;
 14 dump-file &quot;/var/named/data/cache_dump.db&quot;;
 15 statistics-file &quot;/var/named/data/named_stats.txt&quot;;
 16 memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;
 17 allow-query &#123; any; &#125;;</code></pre>
<h2 id="2-1正向解析实验"><a href="#2-1正向解析实验" class="headerlink" title="2.1正向解析实验"></a>2.1正向解析实验</h2><p>正向解析是指根据域名（主机名）查找到对应的IP地址。</p>
<p>第1步：编辑区域配置文件。该文件中默认已经有了一些无关紧要的解析参数，旨在让用户有一个参考。我们可以将下面的参数添加到区域配置文件的最下面，当然，也可以将该文件中的原有信息全部清空，而只保留自己的域名解析信息：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/named.rfc1912.zones
zone &quot;linuxprobe.com&quot; IN &#123;
type master;
file &quot;linuxprobe.com.zone&quot;;
allow-update &#123;none;&#125;;
&#125;;</code></pre>
<p>第2步：编辑数据配置文件。我们可以从/var/named目录中复制一份正向解析的模板文件（named.localhost），然后把域名和IP地址的对应数据填写数据配置文件中并保存。在复制时记得加上-a参数，这可以保留原始文件的所有者、所属组、权限属性等信息，以便让bind服务程序顺利读取文件内容：</p>
<pre><code>[root@linuxprobe ~]# cd /var/named/
[root@linuxprobe named]# ls -al named.localhost
-rw-r-----. 1 root named 152 Jun 21 2007 named.localhost
[root@linuxprobe named]# cp -a named.localhost linuxprobe.com.zone</code></pre>
<img src="/2021/02/13/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-13%EF%BC%9A%E4%BD%BF%E7%94%A8Bind%E6%8F%90%E4%BE%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1/1.png" class>

<p>在保存并退出后文件后记得重启named服务程序，让新的解析数据生效:</p>
<pre><code>[root@linuxprobe named]# vim linuxprobe.com.zone
[root@linuxprobe named]# systemctl restart named</code></pre>
<p>第3步：检验解析结果;为了检验解析结果，一定要先把Linux系统网卡中的DNS地址参数修改成本机IP地址，这样就可以使用由本机提供的DNS查询服务了。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/sysconfig/network-scripts/ifcfg-eno16777728（网卡名称）
TYPE=Ethernet
BOOTPROTO=none
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
NAME=eno16777728
UUID=f6b8c6f1-3067-47f6-984e-3d0a1f4d7c23
ONBOOT=yes
IPADDR0=192.168.10.10
GATEWAY0=192.168.10.2
PREFIX0=24
HWADDR=00:0C:29:2B:CC:85
DNS=192.168.10.10
……</code></pre>
<p>nslookup命令用于检测能否从DNS服务器中查询到域名与IP地址的解析记录，进而更准确地检验DNS服务器是否已经能够为用户提供服务。</p>
<pre><code>[root@linuxprobe ~]# systemctl restart network
[root@linuxprobe ~]# nslookup
&gt; www.linuxprobe.com
Server: 127.0.0.1
Address: 127.0.0.1#53
Name: www.linuxprobe.com
Address: 192.168.10.10
&gt; bbs.linuxprobe.com
Server: 127.0.0.1
Address: 127.0.0.1#53
Name: bbs.linuxprobe.com
Address: 192.168.10.20</code></pre>
<h2 id="2-2反向解析实验"><a href="#2-2反向解析实验" class="headerlink" title="2.2反向解析实验"></a>2.2反向解析实验</h2><p>反向解析：将用户提交的IP地址解析为对应的域名信息。</p>
<p>第1步：编辑区域配置文件。除了不要写错格式之外，还需要记住此处定义的数据配置文件名称，因为一会儿还需要在/var/named目录中建立与其对应的同名文件。反向解析是把IP地址解析成域名格式，因此在定义zone（区域）时应该要把IP地址反写，比如原来是192.168.10.0，反写后应该就是10.168.192，而且只需写出IP地址的网络位即可。把下列参数添加至正向解析参数的后面。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/named.rfc1912.zones
zone &quot;linuxprobe.com&quot; IN &#123;
type master;
file &quot;linuxprobe.com.zone&quot;;
allow-update &#123;none;&#125;;
&#125;;
zone &quot;10.168.192.in-addr.arpa&quot; IN &#123;
type master;
file &quot;192.168.10.arpa&quot;;
&#125;;</code></pre>
<p>第2步：编辑数据配置文件。首先从/var/named目录中复制一份反向解析的模板文件（named.loopback），然后把下面的参数填写到文件中。其中，IP地址仅需要写主机位！</p>
<img src="/2021/02/13/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-13%EF%BC%9A%E4%BD%BF%E7%94%A8Bind%E6%8F%90%E4%BE%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1/2.png" class>

<pre><code>[root@linuxprobe named]# cp -a named.loopback 192.168.10.arpa
[root@linuxprobe named]# vim 192.168.10.arpa</code></pre>
<img src="/2021/02/13/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-13%EF%BC%9A%E4%BD%BF%E7%94%A8Bind%E6%8F%90%E4%BE%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1/3.png" class>

<pre><code>[root@linuxprobe named]# systemctl restart named</code></pre>
<p>第3步：检验解析结果。在前面的正向解析实验中，已经把系统网卡中的DNS地址参数修改成了本机IP地址，因此可以直接使用nslookup命令来检验解析结果，仅需输入IP地址即可查询到对应的域名信息。</p>
<pre><code>[root@linuxprobe ~]# nslookup
&gt; 192.168.10.10
Server: 127.0.0.1
Address: 127.0.0.1#53
10.10.168.192.in-addr.arpa name = ns.linuxprobe.com.
10.10.168.192.in-addr.arpa name = www.linuxprobe.com.
10.10.168.192.in-addr.arpa name = mail.linuxprobe.com.
&gt; 192.168.10.20
Server: 127.0.0.1
Address: 127.0.0.1#53
20.10.168.192.in-addr.arpa name = bbs.linuxprobe.com.</code></pre>
<h1 id="3-部署从服务器"><a href="#3-部署从服务器" class="headerlink" title="3.部署从服务器"></a>3.部署从服务器</h1><p>在本实验中，主服务器与从服务器分别使用的操作系统和IP地址如下：</p>
<table>
<thead>
<tr>
<th>主机名称</th>
<th>操作系统</th>
<th>IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>主服务器</td>
<td>RHEL 7</td>
<td>192.168.10.10</td>
</tr>
<tr>
<td>从服务器</td>
<td>RHEL 7</td>
<td>192.168.10.20</td>
</tr>
</tbody></table>
<p>第1步：在<strong>主服务器</strong>的区域配置文件中允许该从服务器的更新请求，即修改allow-update {允许更新区域信息的主机地址;};参数，然后重启主服务器的DNS服务程序。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/named.rfc1912.zones
zone &quot;linuxprobe.com&quot; IN &#123;
type master;
file &quot;linuxprobe.com.zone&quot;;
allow-update &#123; 192.168.10.20; &#125;;
&#125;;
zone &quot;10.168.192.in-addr.arpa&quot; IN &#123;
type master;
file &quot;192.168.10.arpa&quot;;
allow-update &#123; 192.168.10.20; &#125;;
&#125;;
[root@linuxprobe ~]# systemctl restart named</code></pre>
<p>第2步：在从服务器终端中输入命令：yum install bind-chroot，安装bind服务程序；再根据上面步骤编辑配置文件vim /etc/named.conf；</p>
<p>第3步：安装完之后，在<strong>从服务器</strong>中填写主服务器的IP地址与要抓取的区域信息，然后重启服务。注意此时的服务类型应该是slave（从），而不再是master（主）。masters参数后面应该为主服务器的IP地址，而且file参数后面定义的是同步数据配置文件后要保存到的位置，稍后可以在该目录内看到同步的文件。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/named.rfc1912.zones
zone &quot;linuxprobe.com&quot; IN &#123;
type slave;
masters &#123; 192.168.10.10; &#125;;
file &quot;slaves/linuxprobe.com.zone&quot;;
&#125;;
zone &quot;10.168.192.in-addr.arpa&quot; IN &#123;
type slave;
masters &#123; 192.168.10.10; &#125;;
file &quot;slaves/192.168.10.arpa&quot;;
&#125;;
[root@linuxprobe ~]# systemctl restart named</code></pre>
<p>第4步：检验解析结果。当<strong>从服务器</strong>的DNS服务程序在重启后，一般就已经自动从主服务器上同步了数据配置文件，而且该文件默认会放置在区域配置文件中所定义的目录位置（/var/named/slaves）中。</p>
<p>第5步：随后在终端中输入命令：nmtui，修改从服务器的网络参数，把DNS地址参数修改成192.168.10.20，这样即可使用<strong>从服务器</strong>自身提供的DNS域名解析服务。最后就可以使用nslookup命令顺利看到解析结果了。</p>
<pre><code>[root@linuxprobe ~]# cd /var/named/slaves
[root@linuxprobe slaves]# ls 
192.168.10.arpa linuxprobe.com.zone
[root@linuxprobe slaves]# nslookup
&gt; www.linuxprobe.com
Server: 192.168.10.20
Address: 192.168.10.20#53
Name: www.linuxprobe.com
Address: 192.168.10.10
&gt; 192.168.10.10
Server: 192.168.10.20
Address: 192.168.10.20#53
10.10.168.192.in-addr.arpa name = www.linuxprobe.com.</code></pre>
<h1 id="4-安全的加密传输"><a href="#4-安全的加密传输" class="headerlink" title="4.安全的加密传输"></a>4.安全的加密传输</h1><table>
<thead>
<tr>
<th>主机名称</th>
<th>操作系统</th>
<th>IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>主服务器</td>
<td>RHEL 7</td>
<td>192.168.10.10</td>
</tr>
<tr>
<td>从服务器</td>
<td>RHEL 7</td>
<td>192.168.10.20</td>
</tr>
</tbody></table>
<p>在从服务器上配妥bind服务程序并重启后，即可看到从主服务器中获取到的数据配置文件。</p>
<pre><code>[root@linuxprobe ~]# ls -al /var/named/slaves/
total 12
drwxrwx---. 2 named named 54 Jun 7 16:02 .
drwxr-x---. 6 root named 4096 Jun 7 15:58 ..
-rw-r--r--. 1 named named 432 Jun 7 16:02 192.168.10.arpa
-rw-r--r--. 1 named named 439 Jun 7 16:02 linuxprobe.com.zone
[root@linuxprobe ~]# rm -rf /var/named/slaves/*</code></pre>
<p>第1步：在<strong>主服务器</strong>中生成密钥。dnssec-keygen命令用于生成安全的DNS服务密钥，其格式为“dnssec-keygen [参数]”，常用的参数以及作用如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>指定加密算法，包括RSAMD5（RSA）、RSASHA1、DSA、NSEC3RSASHA1、NSEC3DSA等</td>
</tr>
<tr>
<td>-b</td>
<td>密钥长度（HMAC-MD5的密钥长度在1~512位之间）</td>
</tr>
<tr>
<td>-n</td>
<td>密钥的类型（HOST表示与主机相关）</td>
</tr>
</tbody></table>
<p>使用下述命令生成一个主机名称为master-slave的128位HMAC-MD5算法的密钥文件。在执行该命令后默认会在当前目录中生成公钥和私钥文件，我们需要把私钥文件中Key参数后面的值记录下来；</p>
<pre><code>[root@linuxprobe ~]# dnssec-keygen -a HMAC-MD5 -b 128 -n HOST master-slave
Kmaster-slave.+157+46845
[root@linuxprobe ~]# ls -al Kmaster-slave.+157+46845.*
-rw-------. 1 root root 56 Jun 7 16:06 Kmaster-slave.+157+46845.key
-rw-------. 1 root root 165 Jun 7 16:06 Kmaster-slave.+157+46845.private
[root@linuxprobe ~]# cat Kmaster-slave.+157+46845.private
Private-key-format: v1.3
Algorithm: 157 (HMAC_MD5)
Key: 1XEEL3tG5DNLOw+1WHfE3Q==
Bits: AAA=
Created: 20170607080621
Publish: 20170607080621
Activate: 20170607080621</code></pre>
<p>第2步：在<strong>主服务器</strong>中创建密钥验证文件。进入bind服务程序用于保存配置文件的目录，把刚刚生成的密钥名称、加密算法和私钥加密字符串按照下面格式写入到tansfer.key传输配置文件中。为了安全起见，我们需要将文件的所属组修改成named，并将文件权限设置得要小一点，然后把该文件做一个硬链接到/etc目录中。</p>
<pre><code>[root@linuxprobe ~]# cd /var/named/chroot/etc/
[root@linuxprobe etc]# vim transfer.key
key &quot;master-slave&quot; &#123;
algorithm hmac-md5;
secret &quot;1XEEL3tG5DNLOw+1WHfE3Q==&quot;;
&#125;;
[root@linuxprobe etc]# chown root:named transfer.key
[root@linuxprobe etc]# chmod 640 transfer.key
[root@linuxprobe etc]# ln transfer.key /etc/transfer.key</code></pre>
<p>第3步：开启并加载Bind服务的密钥验证功能。首先需要在主服务器的主配置文件中加载密钥验证文件，然后进行设置，使得只允许带有master-slave密钥认证的DNS服务器同步数据配置文件：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/named.conf
  9 include &quot;/etc/transfer.key&quot;;
 10 options &#123;
 11 listen-on port 53 &#123; any; &#125;;
 12 listen-on-v6 port 53 &#123; ::1; &#125;;
 13 directory &quot;/var/named&quot;;
 14 dump-file &quot;/var/named/data/cache_dump.db&quot;;
 15 statistics-file &quot;/var/named/data/named_stats.txt&quot;;
 16 memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;
 17 allow-query &#123; any; &#125;;
 18 allow-transfer &#123; key master-slave; &#125;;
………………省略部分输出信息………………
[root@linuxprobe ~]# systemctl restart named</code></pre>
<p>至此，DNS主服务器的TSIG密钥加密传输功能就已经配置完成。此时清空DNS从服务器同步目录中所有的数据配置文件，然后再次重启bind服务程序；</p>
<pre><code>[root@linuxprobe ~]# rm -rf /var/named/slaves/*
[root@linuxprobe ~]# ls  /var/named/slaves/
[root@linuxprobe ~]# systemctl restart named</code></pre>
<p>第4步：配置<strong>从服务器</strong>，使其支持密钥验证。配置DNS从服务器和主服务器的方法大致相同，都需要在bind服务程序的配置文件目录中创建密钥认证文件，并设置相应的权限，然后把该文件做一个硬链接到/etc目录中。</p>
<pre><code>[root@linuxprobe ~]# cd /var/named/chroot/etc
[root@linuxprobe etc]# vim transfer.key
key &quot;master-slave&quot; &#123;
algorithm hmac-md5;
secret &quot;1XEEL3tG5DNLOw+1WHfE3Q==&quot;;
&#125;;
[root@linuxprobe etc]# chown root:named transfer.key
[root@linuxprobe etc]# chmod 640 transfer.key
[root@linuxprobe etc]# ln transfer.key /etc/transfer.key</code></pre>
<p>第5步：开启并加载从服务器的密钥验证功能。这一步的操作步骤也同样是在主配置文件中加载密钥认证文件，然后按照指定格式写上主服务器的IP地址和密钥名称。注意，密钥名称等参数位置不要太靠前，大约在第43行比较合适，否则bind服务程序会因为没有加载完预设参数而报错：</p>
<pre><code>[root@linuxprobe etc]# vim /etc/named.conf
  9 include &quot;/etc/transfer.key&quot;;
 10 options &#123;
 11 listen-on port 53 &#123; 127.0.0.1; &#125;;
 12 listen-on-v6 port 53 &#123; ::1; &#125;;
 13 directory &quot;/var/named&quot;;
 14 dump-file &quot;/var/named/data/cache_dump.db&quot;;
 15 statistics-file &quot;/var/named/data/named_stats.txt&quot;;
 16 memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;
 17 allow-query &#123; localhost; &#125;;
    …………
 41 session-keyfile &quot;/run/named/session.key&quot;;
 42 &#125;;
 43 server 192.168.10.10
 44 &#123;
 45 keys &#123; master-slave; &#125;;
 46 &#125;; 
 47 logging &#123;</code></pre>
<p>第6步：DNS从服务器同步域名区域数据。现在，两台服务器的bind服务程序都已经配置妥当，并匹配到了相同的密钥认证文件。接下来在从服务器上重启bind服务程序，可以发现又能顺利地同步到数据配置文件了。</p>
<pre><code>[root@linuxprobe ~]# systemctl restart named
[root@linuxprobe ~]# ls /var/named/slaves/
 192.168.10.arpa  linuxprobe.com.zone</code></pre>
<h1 id="5-分离解析技术"><a href="#5-分离解析技术" class="headerlink" title="5.分离解析技术"></a>5.分离解析技术</h1><table>
<thead>
<tr>
<th>主机名称</th>
<th>操作系统</th>
<th>IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>DNS服务器</td>
<td>RHEL 7</td>
<td>北京网络：122.71.115.10</td>
</tr>
<tr>
<td></td>
<td></td>
<td>美国网络：106.185.25.10</td>
</tr>
<tr>
<td>北京用户</td>
<td>windows 7</td>
<td>122.71.115.1</td>
</tr>
<tr>
<td>海外用户</td>
<td>windows 7</td>
<td>106.185.25.1</td>
</tr>
</tbody></table>
<p>第1步：安装bind域名解析服务，并修改bind服务程序的主配置文件，把第11行的监听端口与第17行的允许查询主机修改为any。由于配置的DNS分离解析功能与DNS根服务器配置参数有冲突，所以需要把第51~54行的根域信息删除。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/named.conf
………………省略部分输出信息………………
 44 logging &#123;
 45 channel default_debug &#123;
 46 file &quot;data/named.run&quot;;
 47 severity dynamic;
 48 &#125;;
 49 &#125;;
 50 
 51 zone &quot;.&quot; IN &#123;
 52 type hint;
 53 file &quot;named.ca&quot;;
 54 &#125;;
 55 
 56 include &quot;/etc/named.rfc1912.zones&quot;;
 57 include &quot;/etc/named.root.key&quot;;
 58
………………省略部分输出信息………………</code></pre>
<p>第2步：编辑区域配置文件。把区域配置文件中原有的数据清空，然后按照以下格式写入参数。首先使用acl参数分别定义两个变量名称（china与american），当下面需要匹配IP地址时只需写入变量名称即可，这样不仅容易阅读识别，而且也利于修改维护。这里的难点是理解view参数的作用。它的作用是通过判断用户的IP地址是中国的还是美国的，然后去分别加载不同的数据配置文件（linuxprobe.com.china或linuxprobe.com.american）。这样，当把相应的IP地址分别写入到数据配置文件后，即可实现DNS的分离解析功能。这样一来，当中国的用户访问linuxprobe.com域名时，便会按照linuxprobe.com.china数据配置文件内的IP地址找到对应的服务器。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/named.rfc1912.zones
1 acl &quot;china&quot; &#123; 122.71.115.0/24; &#125;;
2 acl &quot;american&quot; &#123; 106.185.25.0/24;&#125;;
3 view &quot;china&quot;&#123;
4 match-clients &#123; &quot;china&quot;; &#125;;
5 zone &quot;linuxprobe.com&quot; &#123;
6 type master;
7 file &quot;linuxprobe.com.china&quot;;
8 &#125;;
9 &#125;;
10 view &quot;american&quot; &#123;
11 match-clients &#123; &quot;american&quot;; &#125;;
12 zone &quot;linuxprobe.com&quot; &#123;
13 type master;
14 file &quot;linuxprobe.com.american&quot;;
15 &#125;;
16 &#125;;</code></pre>
<p>第3步：建立数据配置文件。分别通过模板文件创建出两份不同名称的区域数据文件，其名称应与上面区域配置文件中的参数相对应。</p>
<pre><code>[root@linuxprobe ~]# cd /var/named
[root@linuxprobe named]# cp -a named.localhost linuxprobe.com.china
[root@linuxprobe named]# cp -a named.localhost linuxprobe.com.american
[root@linuxprobe named]# vim linuxprobe.com.china</code></pre>
<img src="/2021/02/13/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-13%EF%BC%9A%E4%BD%BF%E7%94%A8Bind%E6%8F%90%E4%BE%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1/4.png" class>

<pre><code>[root@linuxprobe named]# vim linuxprobe.com.american</code></pre>
<img src="/2021/02/13/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-13%EF%BC%9A%E4%BD%BF%E7%94%A8Bind%E6%8F%90%E4%BE%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1/5.png" class>

<p>第4步：重新启动named服务程序，验证结果。</p>
<pre><code>[root@linuxprobe named]# systemctl restart named</code></pre>
<p>第5步：将客户端主机（Windows系统或Linux系统均可）的IP地址分别设置为122.71.115.1与106.185.25.1，将DNS地址分别设置为服务器主机的两个IP地址。这样，当尝试使用nslookup命令解析域名时就能清晰地看到解析结果，分别如下图所示。</p>
<img src="/2021/02/13/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-13%EF%BC%9A%E4%BD%BF%E7%94%A8Bind%E6%8F%90%E4%BE%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1/6.png" class>

<img src="/2021/02/13/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-13%EF%BC%9A%E4%BD%BF%E7%94%A8Bind%E6%8F%90%E4%BE%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1/7.png" class>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第13章节：使用Bind提供域名解析服务</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：使用Apache服务部署静态网站</title>
    <url>/2021/02/07/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8Apache%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="1-网站服务程序"><a href="#1-网站服务程序" class="headerlink" title="1.网站服务程序"></a>1.网站服务程序</h1><a id="more"></a>

<p>第1步：把光盘设备中的系统镜像挂载到/media/cdrom目录。</p>
<pre><code>[root@linuxprobe ~]# mkdir -p /media/cdrom
[root@linuxprobe ~]# mount /dev/cdrom /media/cdrom
mount: /dev/sr0 is write-protected, mounting read-only</code></pre>
<p>第2步：使用Vim文本编辑器创建Yum仓库的配置文件。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/yum.repos.d/rhel7.repo
[rhel7]
name=rhel7
baseurl=file:///media/cdrom
enabled=1
gpgcheck=0</code></pre>
<p>第3步：动手安装Apache服务程序。注意，使用yum命令进行安装时，跟在命令后面的Apache服务的软件包名称为httpd。如果直接执行yum install apache命令，则系统会报错。</p>
<pre><code>[root@linuxprobe ~]# yum install httpd
Loaded plugins: langpacks, product-id, subscription-manager
………………省略部分输出信息………………
Complete!</code></pre>
<p>第4步：启用httpd服务程序并将其加入到开机启动项中，使其能够随系统开机而运行，从而持续为用户提供Web服务：</p>
<pre><code>[root@linuxprobe ~]# systemctl start httpd
[root@linuxprobe ~]# systemctl enable httpd
ln -s &#39;/usr/lib/systemd/system/httpd.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/httpd.service&#39;

[root@linuxprobe ~]# firefox</code></pre>
<h1 id="2-配置服务文件参数"><a href="#2-配置服务文件参数" class="headerlink" title="2.配置服务文件参数"></a>2.配置服务文件参数</h1><table>
<thead>
<tr>
<th>作用</th>
<th>文件名称</th>
</tr>
</thead>
<tbody><tr>
<td>服务目录</td>
<td>/etc/httpd</td>
</tr>
<tr>
<td>主配置文件</td>
<td>/etc/httpd/conf/httpd.conf</td>
</tr>
<tr>
<td>网站数据目录</td>
<td>/var/www/html</td>
</tr>
<tr>
<td>访问日志</td>
<td>/var/log/httpd/access_log</td>
</tr>
<tr>
<td>错误日志</td>
<td>/var/log/httpd/error_log</td>
</tr>
</tbody></table>
<p>在httpd服务程序的主配置文件中，存在三种类型的信息：注释行信息、全局配置、区域配置；</p>
<p> 配置httpd服务程序时最常用的参数以及用途描述：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ServerRoot</td>
<td>服务目录</td>
</tr>
<tr>
<td>ServerAdmin</td>
<td>管理员邮箱</td>
</tr>
<tr>
<td>User</td>
<td>运行服务的用户</td>
</tr>
<tr>
<td>Group</td>
<td>运行服务的用户组</td>
</tr>
<tr>
<td>ServerName</td>
<td>网站服务器的域名</td>
</tr>
<tr>
<td>DocumentRoot</td>
<td>网站数据目录</td>
</tr>
<tr>
<td>Listen</td>
<td>监听的IP地址与端口号</td>
</tr>
<tr>
<td>DirectoryIndex</td>
<td>默认的索引页页面</td>
</tr>
<tr>
<td>ErrorLog</td>
<td>错误日志文件</td>
</tr>
<tr>
<td>CustomLog</td>
<td>访问日志文件</td>
</tr>
<tr>
<td>Timeout</td>
<td>网页超时时间，默认为300秒</td>
</tr>
</tbody></table>
<p>在默认情况下，网站数据是保存在/var/www/html目录中，打开httpd服务程序的主配置文件，将约第119行用于定义网站数据保存路径的参数DocumentRoot修改为/home/wwwroot，同时还需要将约第124行用于定义目录权限的参数Directory后面的路径也修改为/home/wwwroot。配置文件修改完毕后即可保存并退出。</p>
<h1 id="3-SELinux安全子系统"><a href="#3-SELinux安全子系统" class="headerlink" title="3.SELinux安全子系统"></a>3.SELinux安全子系统</h1><p>“SELinux域”和“SELinux安全上下文”称为是Linux系统中的双保险</p>
<p>SELinux服务有三种配置模式，具体如下：</p>
<pre><code>enforcing：强制启用安全策略模式，将拦截服务的不合法请求。

permissive：遇到服务越权访问时，只发出警告而不强制拦截。

disabled：对于越权的行为不警告也不拦截。</code></pre>
<p>SELinux服务主配置文件目录：/etc/selinux/config；</p>
<p>getenforce：获取当前SELinux服务的运行模式； setenforce[0|1]：修改SELinux当前的运行模式（0为禁用，1为启用）；修改是暂时的，系统重启后失效。</p>
<p>查看网站数据保存目录的SELinux安全上下文值：</p>
<pre><code>[root@linuxprobe ~]# setenforce 1
[root@linuxprobe ~]# ls -Zd /var/www/html
drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 /var/www/html
[root@linuxprobe ~]# ls -Zd /home/wwwroot
drwxrwxrwx. root root unconfined_u:object_r:home_root_t:s0 /home/wwwroot</code></pre>
<p>在文件上设置的SELinux安全上下文是由用户段、角色段以及类型段等多个信息项共同组成的。其中，用户段system_u代表系统进程的身份，角色段object_r代表文件目录的角色，类型段httpd_sys_content_t代表网站服务的系统文件。</p>
<h2 id="3-1-semanage命令"><a href="#3-1-semanage命令" class="headerlink" title="3.1 semanage命令"></a>3.1 semanage命令</h2><p>emanage命令用于管理SELinux的策略，格式为“semanage [选项] [文件]”，经常用到的几个参数及其功能如下所示：</p>
<pre><code>    -l参数用于查询；    -a参数用于添加；    -m参数用于修改；    -d参数用于删除。</code></pre>
<p>可以向新的网站数据目录中新添加一条SELinux安全上下文，让这个目录以及里面的所有文件能够被httpd服务程序所访问到：</p>
<pre><code>[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/*</code></pre>
<p>注意，执行上述设置之后，还无法立即访问网站，还需要使用restorecon命令将设置好的SELinux安全上下文立即生效。在使用restorecon命令时，可以加上-Rv参数对指定的目录进行递归操作，以及显示SELinux安全上下文的修改过程。最后，再次刷新页面，就可以正常看到网页内容了：</p>
<pre><code>[root@linuxprobe ~]# restorecon -Rv /home/wwwroot/
restorecon reset /home/wwwroot context unconfined_u:object_r:home_root_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0</code></pre>
<p>再添加systemctl enable httpd命令，将所需服务添加到开机启动项中。</p>
<h1 id="4-个人用户主页功能"><a href="#4-个人用户主页功能" class="headerlink" title="4.个人用户主页功能"></a>4.个人用户主页功能</h1><p>第1步：在httpd服务程序中，默认没有开启个人用户主页功能。为此，我们需要编辑下面的配置文件，然后在第17行的UserDir disabled参数前面加上井号（#），表示让httpd服务程序开启个人用户主页功能；同时再把第24行的UserDir public_html参数前面的井号（#）去掉（UserDir参数表示网站数据在用户家目录中的保存目录名称，即public_html目录）。最后，在修改完毕后记得保存。</p>
<pre><code> 15 # permissions).
 16 #
 17 # UserDir disabled
 18 
 19 #
 20 # To enable requests to /~user/ to serve the user&#39;s public_html
 21 # directory, remove the &quot;UserDir disabled&quot; line above, and uncomment
 22 # the following line instead:
 23 # 
 24   UserDir public_html
 25 &lt;/IfModule&gt;
 …… …… …… ……</code></pre>
<p>第2步：在用户家目录中建立用于保存网站数据的目录及首页面文件。另外，还需要把家目录的权限修改为755，保证其他人也有权限读取里面的内容。</p>
<pre><code>[root@linuxprobe home]# su - linuxprobe
Last login: Fri May 22 13:17:37 CST 2017 on :0
[linuxprobe@linuxprobe ~]$ mkdir public_html
[linuxprobe@linuxprobe ~]$ echo &quot;This is linuxprobe&#39;s website&quot; &gt; public_html/index.html
[linuxprobe@linuxprobe ~]$ chmod -Rf 755 /home/linuxprobe</code></pre>
<p>第3步：使用getsebool命令查询并过滤出所有与HTTP协议相关的安全策略。其中，off为禁止状态，on为允许状态。</p>
<pre><code>[root@linuxprobe ~]# getsebool -a | grep http
httpd_anon_write --&gt; off
httpd_builtin_scripting --&gt; on
……
**httpd_enable_homedirs --&gt; off**
……</code></pre>
<p>第4步：用setsebool命令来修改SELinux策略中规则的布尔值，在setsebool命令后面加上-P参数，让修改后的SELinux策略规则永久生效且立即生效，并重新启动httpd服务程序：</p>
<pre><code>[root@linuxprobe ~]# setsebool -P httpd_enable_homedirs=on
[root@linuxprobe ~]# systemctl restart httpd</code></pre>
<p>第5步：在浏览器的地址栏中输入网址，其格式为“网址/<del>用户名”（其中的波浪号是必需的，而且网址、波浪号、用户名之间没有空格）如：127.0.0.1/</del>linuxprobe，就可以看到用户的个人网站了。</p>
<h2 id="4-1在网页中添加口令功能"><a href="#4-1在网页中添加口令功能" class="headerlink" title="4.1在网页中添加口令功能"></a>4.1在网页中添加口令功能</h2><p>第1步：先使用htpasswd命令生成密码数据库。-c参数表示第一次生成；后面再分别添加密码数据库的存放文件，以及验证要用到的用户名称（该用户不必是系统中已有的本地账户）。</p>
<pre><code>[root@linuxprobe ~]# htpasswd -c /etc/httpd/passwd linuxprobe
New password:此处输入用于网页验证的密码
Re-type new password:再输入一遍进行确认
Adding password for user linuxprobe</code></pre>
<p>第2步：编辑个人用户主页功能的配置文件。把第31～35行的参数信息修改成下列内容，其中井号（#）开头的内容为刘遄老师添加的注释信息，可将其忽略。随后保存并退出配置文件，重启httpd服务程序即可生效。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/httpd/conf.d/userdir.conf
31 &lt;Directory &quot;/home/*/public_html&quot;&gt;
32 AllowOverride all
#刚刚生成出来的密码验证文件保存路径
33 authuserfile &quot;/etc/httpd/passwd&quot;
#当用户尝试访问个人用户网站时的提示信息
34 authname &quot;My privately website&quot;
35 authtype basic
#用户进行账户密码登录时需要验证的用户名称
36 require user linuxprobe
37 &lt;/Directory&gt;
[root@linuxprobe ~]# systemctl restart httpd</code></pre>
<p>此后，当用户再想访问某个用户的个人网站时，就必须要输入账户和密码才能正常访问了。另外，验证时使用的账户和密码是用htpasswd命令生成的专门用于网站登录的口令密码，而不是系统中的用户密码，请不要搞错了。</p>
<h2 id="4-3虚拟网站主机功能"><a href="#4-3虚拟网站主机功能" class="headerlink" title="4.3虚拟网站主机功能"></a>4.3虚拟网站主机功能</h2><p>利用虚拟主机功能，可以把一台处于运行状态的物理服务器分割成多个“虚拟的服务器”。但是，该技术无法实现目前云主机技术的硬件资源隔离，让这些虚拟的服务器共同使用物理服务器的硬件资源，供应商只能限制硬盘的使用空间大小。</p>
<p>Apache的虚拟主机功能是服务器基于用户请求的不同IP地址、主机域名或端口号，实现提供多个网站同时为外部提供访问服务的技术，用户请求的资源不同，最终获取到的网页内容也各不相同。</p>
<h3 id="4-3-1基于IP地址"><a href="#4-3-1基于IP地址" class="headerlink" title="4.3.1基于IP地址"></a>4.3.1基于IP地址</h3><p>第1步：使用nmtui命令，创建三个IP地址，如：192.168.10.10、192.168.10.20、192.168.10.30；</p>
<img src="/2021/02/07/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8Apache%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/1.png" class>

<p>第2步：分别在/home/wwwroot中创建用于保存不同网站数据的3个目录，并向其中分别写入网站的首页文件。每个首页文件中应有明确区分不同网站内容的信息，方便我们稍后能更直观地检查效果。</p>
<img src="/2021/02/07/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8Apache%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/2.png" class>

<pre><code>[root@linuxprobe ~]# mkdir -p /home/wwwroot/10
[root@linuxprobe ~]# mkdir -p /home/wwwroot/20
[root@linuxprobe ~]# mkdir -p /home/wwwroot/30
[root@linuxprobe ~]# echo &quot;IP:192.168.10.10&quot; &gt; /home/wwwroot/10/index.html
[root@linuxprobe ~]# echo &quot;IP:192.168.10.20&quot; &gt; /home/wwwroot/20/index.html
[root@linuxprobe ~]# echo &quot;IP:192.168.10.30&quot; &gt; /home/wwwroot/30/index.html</code></pre>
<p>第3步：在httpd服务的配置文件中大约113行处开始，分别追加写入三个基于IP地址的虚拟主机网站参数，然后保存并退出。记得需要重启httpd服务，这些配置才生效。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/httpd/conf/httpd.conf
………………省略部分输出信息………………
113 &lt;VirtualHost 192.168.10.10&gt;
114 DocumentRoot /home/wwwroot/10
115 ServerName www.linuxprobe.com
116 &lt;Directory /home/wwwroot/10 &gt;
117 AllowOverride None
118 Require all granted
119 &lt;/Directory&gt;
120 &lt;/VirtualHost&gt;
121 &lt;VirtualHost 192.168.10.20&gt;
122 DocumentRoot /home/wwwroot/20
123 ServerName bbs.linuxprobe.com
124 &lt;Directory /home/wwwroot/20 &gt;
125 AllowOverride None
126 Require all granted
127 &lt;/Directory&gt;
128 &lt;/VirtualHost&gt;
129 &lt;VirtualHost 192.168.10.30&gt;
130 DocumentRoot /home/wwwroot/30
131 ServerName tech.linuxprobe.com
132 &lt;Directory /home/wwwroot/30 &gt;
133 AllowOverride None
134 Require all granted
135 &lt;/Directory&gt;
136 &lt;/VirtualHost&gt;
………………省略部分输出信息………………
[root@linuxprobe ~]# systemctl restart httpd</code></pre>
<p>第3步：手动把新的网站数据目录的SELinux安全上下文设置正确，并使用restorecon命令让新设置的SELinux安全上下文立即生效;</p>
<pre><code>[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/10
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/10/*
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/20
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/20/*
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/30
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/30/*
[root@linuxprobe ~]# restorecon -Rv /home/wwwroot</code></pre>
<img src="/2021/02/07/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8Apache%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/3.png" class>

<h3 id="4-3-2基于主机域名"><a href="#4-3-2基于主机域名" class="headerlink" title="4.3.2基于主机域名"></a>4.3.2基于主机域名</h3><p>当服务器无法为每个网站都分配一个独立IP地址的时候，可以尝试让Apache自动识别用户请求的域名，从而根据不同的域名请求来传输不同的内容。在这种情况下的配置更加简单，只需要保证位于生产环境中的服务器上有一个可用的IP地址（这里以192.168.10.10为例）就可以了。</p>
<p>/etc/hosts是Linux系统中用于强制把某个主机域名解析到指定IP地址的配置文件。</p>
<p>第1步：手工定义IP地址与域名之间对应关系的配置文件，保存并退出后会立即生效。可以通过分别ping这些域名来验证域名是否已经成功解析为IP地址。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/hosts
127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4
::1 localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.10.10 www.linuxprobe.com bbs.linuxprobe.com tech.linuxprobe.com
[root@linuxprobe ~]# ping -c 4 www.linuxprobe.com
PING www.linuxprobe.com (192.168.10.10) 56(84) bytes of data.
64 bytes from www.linuxprobe.com (192.168.10.10): icmp_seq=1 ttl=64 time=0.070 ms</code></pre>
<p>第2步：分别在/home/wwwroot中创建用于保存不同网站数据的三个目录，并向其中分别写入网站的首页文件。每个首页文件中应有明确区分不同网站内容的信息，方便我们稍后能更直观地检查效果。</p>
<pre><code>[root@linuxprobe ~]# mkdir -p /home/wwwroot/www
[root@linuxprobe ~]# mkdir -p /home/wwwroot/bbs
[root@linuxprobe ~]# mkdir -p /home/wwwroot/tech
[root@linuxprobe ~]# echo &quot;WWW.linuxprobe.com&quot; &gt; /home/wwwroot/www/index.html
[root@linuxprobe ~]# echo &quot;BBS.linuxprobe.com&quot; &gt; /home/wwwroot/bbs/index.html
[root@linuxprobe ~]# echo &quot;TECH.linuxprobe.com&quot; &gt; /home/wwwroot/tech/index.html</code></pre>
<p>第3步：在httpd服务的配置文件中大约113行处开始，分别追加写入三个基于主机名的虚拟主机网站参数，然后保存并退出。记得需要重启httpd服务，这些配置才生效。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/httpd/conf/httpd.conf
………………省略部分输出信息………………
113 &lt;VirtualHost 192.168.10.10&gt;
114 DocumentRoot &quot;/home/wwwroot/www&quot;
115 ServerName &quot;www.linuxprobe.com&quot;
116 &lt;Directory &quot;/home/wwwroot/www&quot;&gt;
117 AllowOverride None
118 Require all granted
119 &lt;/directory&gt; 
120 &lt;/VirtualHost&gt;
121 &lt;VirtualHost 192.168.10.10&gt;
122 DocumentRoot &quot;/home/wwwroot/bbs&quot;
123 ServerName &quot;bbs.linuxprobe.com&quot;
124 &lt;Directory &quot;/home/wwwroot/bbs&quot;&gt;
125 AllowOverride None
126 Require all granted
127 &lt;/Directory&gt;
128 &lt;/VirtualHost&gt;
129 &lt;VirtualHost 192.168.10.10&gt;
130 DocumentRoot &quot;/home/wwwroot/tech&quot;
131 ServerName &quot;tech.linuxprobe.com&quot;
132 &lt;Directory &quot;/home/wwwroot/tech&quot;&gt;
133 AllowOverride None
134 Require all granted
135 &lt;/directory&gt;
136 &lt;/VirtualHost&gt;</code></pre>
<p>第4步：因为当前的网站数据目录还是在/home/wwwroot目录中，因此还是必须要正确设置网站数据目录文件的SELinux安全上下文，使其与网站服务功能相吻合。最后记得用restorecon命令让新配置的SELinux安全上下文立即生效，这样就可以立即访问到虚拟主机网站了。</p>
<pre><code>[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/www
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/www/*
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/bbs
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/bbs/*
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/tech
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/tech/*
[root@linuxprobe ~]# restorecon -Rv /home/wwwroot</code></pre>
<img src="/2021/02/07/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8Apache%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/4.png" class>

<h3 id="4-3-3基于端口号"><a href="#4-3-3基于端口号" class="headerlink" title="4.3.3基于端口号"></a>4.3.3基于端口号</h3><p>基于端口号的虚拟主机功能可以让用户通过指定的端口号来访问服务器上的网站资源。一般来说，使用80、443、8080等端口号来提供网站访问服务是比较合理的，如果使用其他端口号则会受到SELinux服务的限制。</p>
<p>在接下来的实验中，我们不但要考虑到目录上应用的SELinux安全上下文的限制，还需要考虑SELinux域对httpd服务程序的管控。</p>
<p>第1步：分别在/home/wwwroot中创建用于保存不同网站数据的两个目录，并向其中分别写入网站的首页文件。每个首页文件中应有明确区分不同网站内容的信息，方便我们稍后能更直观地检查效果。</p>
<pre><code>[root@linuxprobe ~]# mkdir -p /home/wwwroot/6111
[root@linuxprobe ~]# mkdir -p /home/wwwroot/6222
[root@linuxprobe ~]# echo &quot;port:6111&quot; &gt; /home/wwwroot/6111/index.html
[root@linuxprobe ~]# echo &quot;port:6222&quot; &gt; /home/wwwroot/6222/index.html</code></pre>
<p>第2步：在httpd服务配置文件的第43行和第44行分别添加用于监听6111和6222端口的参数。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/httpd/conf/httpd.conf 
………………省略部分输出信息……………… 
 33 #
 34 # Listen: Allows you to bind Apache to specific IP addresses and/or
 35 # ports, instead of the default. See also the &lt;VirtualHost&gt;
 36 # directive.
 37 #
 38 # Change this to Listen on specific IP addresses as shown below to 
 39 # prevent Apache from glomming onto all bound IP addresses.
 40 #
 41 #Listen 12.34.56.78:80
 42 Listen 80
 43 Listen 6111
 44 Listen 6222
………………省略部分输出信息……………… </code></pre>
<p>第3步：在httpd服务的配置文件中大约113行处开始，分别追加写入两个基于端口号的虚拟主机网站参数，然后保存并退出。记得需要重启httpd服务，这些配置才生效。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/httpd/conf/httpd.conf
………………省略部分输出信息……………… 
113 &lt;VirtualHost 192.168.10.10:6111&gt;
114 DocumentRoot &quot;/home/wwwroot/6111&quot;
115 ServerName www.linuxprobe.com
116 &lt;Directory &quot;/home/wwwroot/6111&quot;&gt;
117 AllowOverride None
118 Require all granted
119 &lt;/Directory&gt; 
120 &lt;/VirtualHost&gt;
121 &lt;VirtualHost 192.168.10.10:6222&gt;
122 DocumentRoot &quot;/home/wwwroot/6222&quot;
123 ServerName bbs.linuxprobe.com
124 &lt;Directory &quot;/home/wwwroot/6222&quot;&gt;
125 AllowOverride None
126 Require all granted
127 &lt;/Directory&gt;
128 &lt;/VirtualHost&gt;
………………省略部分输出信息………………</code></pre>
<p>第4步：因为我们把网站数据目录存放在/home/wwwroot目录中，因此还是必须要正确设置网站数据目录文件的SELinux安全上下文，使其与网站服务功能相吻合。最后记得用restorecon命令让新配置的SELinux安全上下文立即生效。</p>
<pre><code>[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/6111
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/6111/*
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/6222
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/6222/*
[root@linuxprobe ~]# restorecon -Rv /home/wwwroot/</code></pre>
<p>第5步：用semanage命令查询并过滤出所有与HTTP协议相关且SELinux服务允许的端口列表。</p>
<pre><code>[root@linuxprobe ~]# semanage port -l | grep http
http_cache_port_t tcp 8080, 8118, 8123, 10001-10010
http_cache_port_t udp 3130
http_port_t tcp 80, 81, 443, 488, 8008, 8009, 8443, 9000
pegasus_http_port_t tcp 5988
pegasus_https_port_t tcp 5989</code></pre>
<p>第6步：SELinux允许的与HTTP协议相关的端口号中默认没有包含6111和6222，因此需要将这两个端口号手动添加进去。该操作会立即生效，而且在系统重启过后依然有效。设置好后再重启httpd服务程序</p>
<pre><code>[root@linuxprobe ~]# semanage port -a -t http_port_t -p tcp 6111
[root@linuxprobe ~]# semanage port -a -t http_port_t -p tcp 6222
[root@linuxprobe ~]# semanage port -l| grep http
http_cache_port_t tcp 8080, 8118, 8123, 10001-10010
http_cache_port_t udp 3130
http_port_t tcp  6222, 6111, 80, 81, 443, 488, 8008, 8009, 8443, 9000
pegasus_http_port_t tcp 5988
pegasus_https_port_t tcp 5989
[root@linuxprobe ~]# systemctl restart httpd</code></pre>
<img src="/2021/02/07/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8Apache%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/5.png" class>

<h1 id="5-Apache的访问控制"><a href="#5-Apache的访问控制" class="headerlink" title="5.Apache的访问控制"></a>5.Apache的访问控制</h1><p>Apache通过Allow指令允许某个主机访问服务器上的网站资源，通过Deny指令实现禁止访问。在允许或禁止访问网站资源时，还会用到Order指令，这个指令用来定义Allow或Deny指令起作用的顺序，其匹配原则是按照顺序进行匹配，若匹配成功则执行后面的默认指令。比如“Order Allow, Deny”表示先将源主机与允许规则进行匹配，若匹配成功则允许访问请求，反之则拒绝访问请求。</p>
<p>第1步：先在服务器上的网站数据目录中新建一个子目录，并在这个子目录中创建一个包含Successful单词的首页文件；</p>
<pre><code>[root@linuxprobe ~]# mkdir /var/www/html/server
[root@linuxprobe ~]# echo &quot;Successful&quot; &gt; /var/www/html/server/index.html</code></pre>
<p>第2步：打开httpd服务的配置文件，在第129行后面添加下述规则来限制源主机的访问。这段规则的含义是允许使用Firefox浏览器的主机访问服务器上的首页文件，除此之外的所有请求都将被拒绝。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/httpd/conf/httpd.conf
………………省略部分输出信息………………
129 &lt;Directory &quot;/var/www/html/server&quot;&gt;
130 SetEnvIf User-Agent &quot;Firefox&quot; ff=1
131 Order allow,deny
132 Allow from env=ff
133 &lt;/Directory&gt;
………………省略部分输出信息………………
[root@linuxprobe ~]# systemctl restart httpd
[root@linuxprobe ~]# firefox</code></pre>
<img src="/2021/02/07/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8Apache%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/6.png" class>

<p>除了匹配源主机的浏览器特征之外，还可以通过匹配源主机的IP地址进行访问控制。例如，我们只允许IP地址为192.168.10.20的主机访问网站资源，那么就可以在httpd服务配置文件的第129行后面添加下述规则。这样在重启httpd服务程序后再用本机（即服务器，其IP地址为192.168.10.10）来访问网站的首页面时就会提示访问被拒绝了。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/httpd/conf/httpd.conf
………………省略部分输出信息………………
129 &lt;Directory &quot;/var/www/html/server&quot;&gt;
130 Order allow,deny 
131 Allow from 192.168.10.20
132 &lt;/Directory&gt;
………………省略部分输出信息………………
[root@linuxprobe ~]# systemctl restart httpd
[root@linuxprobe ~]# firefox</code></pre>
<img src="/2021/02/07/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8Apache%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/7.jpg" class>




























]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第10章节：使用Apache服务部署静态网站</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：使用Vsftpd服务传输文件</title>
    <url>/2021/02/09/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8Vsftpd%E6%9C%8D%E5%8A%A1%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="1-文件传输协议"><a href="#1-文件传输协议" class="headerlink" title="1.文件传输协议"></a>1.文件传输协议</h1><p>FTP是一种在互联网中进行文件传输的协议，基于客户端/服务器模式，默认使用20、21号端口，其中端口20（数据端口）用于进行数据传输，端口21（命令端口）用于接受客户端发出的相关FTP命令与参数。</p>
<a id="more"></a>

<p>FTP服务器是按照FTP协议在互联网上提供文件存储和访问服务的主机，FTP客户端则是向服务器发送连接请求，以建立数据传输链路的主机。FTP协议有下面两种工作模式。</p>
<pre><code>主动模式：FTP服务器主动向客户端发起连接请求。

被动模式：FTP服务器等待客户端发起连接请求（FTP的默认工作模式）。</code></pre>
<p>在配置妥当Yum软件仓库之后，就可以安装vsftpd服务程序了。</p>
<pre><code>[root@linuxprobe ~]# yum install vsftpd</code></pre>
<p>iptables防火墙管理工具默认禁止了FTP传输协议的端口号，因此在正式配置vsftpd服务程序之前，为了避免这些默认的防火墙策略“捣乱”，还需要清空iptables防火墙的默认策略，并把当前已经被清理的防火墙策略状态保存下来：</p>
<pre><code>[root@linuxprobe ~]# iptables -F
[root@linuxprobe ~]# service iptables save</code></pre>
<p>vsftpd服务程序主配置文件中常用的参数以及作用：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>listen=[YES</td>
<td>NO]</td>
</tr>
<tr>
<td>listen_address=IP地址</td>
<td>设置要监听的IP地址</td>
</tr>
<tr>
<td>listen_port=21</td>
<td>设置FTP服务的监听端口</td>
</tr>
<tr>
<td>download_enable＝[YES</td>
<td>NO]</td>
</tr>
<tr>
<td>userlist_enable=[YES</td>
<td>NO]</td>
</tr>
<tr>
<td>userlist_deny=[YES</td>
<td>NO]</td>
</tr>
<tr>
<td>max_clients=0</td>
<td>最大客户端连接数，0为不限制</td>
</tr>
<tr>
<td>max_per_ip=0</td>
<td>同一IP地址的最大连接数，0为不限制</td>
</tr>
<tr>
<td>anonymous_enable=[YES</td>
<td>NO]</td>
</tr>
<tr>
<td>anon_upload_enable=[YES</td>
<td>NO]</td>
</tr>
<tr>
<td>anon_umask=022</td>
<td>匿名用户上传文件的umask值</td>
</tr>
<tr>
<td>anon_root=/var/ftp</td>
<td>匿名用户的FTP根目录</td>
</tr>
<tr>
<td>anon_mkdir_write_enable=[YES</td>
<td>NO]</td>
</tr>
<tr>
<td>anon_other_write_enable=[YES</td>
<td>NO]</td>
</tr>
<tr>
<td>anon_max_rate=0</td>
<td>匿名用户的最大传输速率（字节/秒），0为不限制</td>
</tr>
<tr>
<td>local_enable=[YES</td>
<td>NO]</td>
</tr>
<tr>
<td>local_umask=022</td>
<td>本地用户上传文件的umask值</td>
</tr>
<tr>
<td>local_root=/var/ftp</td>
<td>本地用户的FTP根目录</td>
</tr>
<tr>
<td>chroot_local_user=[YES</td>
<td>NO]</td>
</tr>
<tr>
<td>local_max_rate=0</td>
<td>本地用户最大传输速率（字节/秒），0为不限制</td>
</tr>
</tbody></table>
<h1 id="2-Vsftpd服务程序"><a href="#2-Vsftpd服务程序" class="headerlink" title="2.Vsftpd服务程序"></a>2.Vsftpd服务程序</h1><p>vsftpd作为更加安全的文件传输的服务程序，允许用户以三种认证模式登录到FTP服务器上。</p>
<pre><code>匿名开放模式：是一种最不安全的认证模式，任何人都可以无需密码验证而直接登录到FTP服务器。

本地用户模式：是通过Linux系统本地的账户密码信息进行认证的模式，相较于匿名开放模式更安全，而且配置起来也很简单。但是如果被黑客破解了账户的信息，就可以畅通无阻地登录FTP服务器，从而完全控制整台服务器。

虚拟用户模式：是这三种模式中最安全的一种认证模式，它需要为FTP服务单独建立用户数据库文件，虚拟出用来进行口令验证的账户信息，而这些账户信息在服务器系统中实际上是不存在的，仅供FTP服务程序进行认证使用。

[root@linuxprobe ~]# yum install ftp</code></pre>
<h2 id="2-1匿名访问模式"><a href="#2-1匿名访问模式" class="headerlink" title="2.1匿名访问模式"></a>2.1匿名访问模式</h2><p>vsftpd服务程序默认开启了匿名开放模式，我们需要做的就是开放匿名用户的上传、下载文件的权限，以及让匿名用户创建、删除、更名文件的权限。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>anonymous_enable=YES</td>
<td>允许匿名访问模式</td>
</tr>
<tr>
<td>anon_umask=022</td>
<td>匿名用户上传文件的umask值</td>
</tr>
<tr>
<td>anon_upload_enable=YES</td>
<td>允许匿名用户上传文件</td>
</tr>
<tr>
<td>anon_mkdir_write_enable=YES</td>
<td>允许匿名用户创建目录</td>
</tr>
<tr>
<td>anon_other_write_enable=YES</td>
<td>允许匿名用户修改目录名称或删除目录</td>
</tr>
</tbody></table>
<p>在<strong>服务器</strong>中修改vsftpd.conf的配置文件：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/vsftpd/vsftpd.conf
1 anonymous_enable=YES
2 anon_umask=022
3 anon_upload_enable=YES
4 anon_mkdir_write_enable=YES
5 anon_other_write_enable=YES
6 local_enable=YES
7 write_enable=YES
……</code></pre>
<p>在vsftpd服务程序的主配置文件中正确填写参数，然后保存并退出。</p>
<p>在vsftpd服务程序的匿名开放认证模式下，默认访问的是/var/ftp目录。查看该目录的权限得知，只有root管理员才有写入权限，修改目录的所有者身份改为系统账户ftp：</p>
<pre><code>[root@linuxprobe ~]# ls -ld /var/ftp/pub
drwxr-xr-x. 3 root root 16 Jul 13 14:38 /var/ftp/pub
[root@linuxprobe ~]# chown -Rf ftp /var/ftp/pub
[root@linuxprobe ~]# ls -ld /var/ftp/pub
drwxr-xr-x. 3 ftp root 16 Jul 13 14:38 /var/ftp/pub</code></pre>
<p>再使用getsebool命令查看与FTP相关的SELinux域策略：</p>
<pre><code>[root@linuxprobe ~]# getsebool -a | grep ftp
ftp_home_dir --&gt; off
ftpd_anon_write --&gt; off
ftpd_connect_all_unreserved --&gt; off
ftpd_connect_db --&gt; off
ftpd_full_access --&gt; off
ftpd_use_cifs --&gt; off
ftpd_use_fusefs --&gt; off
ftpd_use_nfs --&gt; off
……</code></pre>
<p>修改该策略规则，并且在设置时使用-P参数让修改过的策略永久生效，确保在服务器重启后依然能够顺利写入文件：</p>
<pre><code>[root@linuxprobe ~]# setsebool -P ftpd_full_access=on</code></pre>
<p>再重启vsftpd服务程序并加入启动项，让新的配置参数生效。</p>
<pre><code>[root@linuxprobe ~]# systemctl restart vsftpd
[root@linuxprobe ~]# systemctl enable vsftpd</code></pre>
<p>现在就可以在<strong>客户端</strong>执行ftp命令连接到远程的FTP服务器了。在vsftpd服务程序的匿名开放认证模式下，其账户统一为anonymous，密码为空。可以切换到该目录下的pub目录中，然后尝试创建一个新的目录文件，以检验是否拥有写入权限：</p>
<pre><code>[root@linuxprobe ~]# ftp 192.168.10.10
Connected to 192.168.10.10 (192.168.10.10).
220 (vsFTPd 3.0.2)
Name (192.168.10.10:root): anonymous
331 Please specify the password.
Password:此处敲击回车即可
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&gt; cd pub
250 Directory successfully changed.
ftp&gt; mkdir files
257 &quot;/pub/files&quot; created
ftp&gt; rename files database
350 Ready for RNTO.
250 Rename successful.
ftp&gt; rmdir database
250 Remove directory operation successful.
ftp&gt; exit
221 Goodbye.</code></pre>
<h2 id="2-2本地用户模式"><a href="#2-2本地用户模式" class="headerlink" title="2.2本地用户模式"></a>2.2本地用户模式</h2><p>本地用户模式的权限参数以及作用如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>anonymous_enable=NO</td>
<td>禁止匿名访问模式</td>
</tr>
<tr>
<td>local_enable=YES</td>
<td>允许本地用户模式</td>
</tr>
<tr>
<td>write_enable=YES</td>
<td>设置可写权限</td>
</tr>
<tr>
<td>local_umask=022</td>
<td>本地用户模式创建文件的umask值</td>
</tr>
<tr>
<td>userlist_deny=YES</td>
<td>启用“禁止用户名单”，名单文件为ftpusers和user_list</td>
</tr>
<tr>
<td>userlist_enable=YES</td>
<td>开启用户作用名单文件功能</td>
</tr>
</tbody></table>
<p>在vsftpd服务程序的主配置文件中正确填写参数，然后保存并退出：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/vsftpd/vsftpd.conf
anonymous_enable=NO
local_enable=YES
write_enable=YES
local_umask=022
dirmessage_enable=YES
xferlog_enable=YES
connect_from_port_20=YES
xferlog_std_format=YES
listen=NO
listen_ipv6=YES
pam_service_name=vsftpd
userlist_enable=YES
tcp_wrappers=YES</code></pre>
<p>重启vsftpd服务程序并加入启动项，让新的配置参数生效：</p>
<pre><code>[root@linuxprobe ~]# systemctl restart vsftpd
[root@linuxprobe ~]# systemctl enable vsftpd
 ln -s &#39;/usr/lib/systemd/system/vsftpd.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/vsftpd.service</code></pre>
<p>vsftpd服务程序为了保证服务器的安全性而默认禁止了root管理员和大多数系统用户的登录行为，这样可以有效地避免黑客通过FTP服务对root管理员密码进行暴力破解。如果您确认在生产环境中使用root管理员不会对系统安全产生影响，只需按照上面的提示删除掉root用户名即可。</p>
<pre><code>[root@linuxprobe ~]# cat /etc/vsftpd/user_list 
1 # vsftpd userlist
2 # If userlist_deny=NO, only allow users in this file
3 # If userlist_deny=YES (default), never allow users in this file, and
4 # do not even prompt for a password.
5 # Note that the default vsftpd pam config also checks /etc/vsftpd/ftpusers
6 # for users that are denied.
7 root
8 bin
9 daemon
10 adm
11 lp
12 sync
13 shutdown
14 halt
15 mail
16 news
17 uucp
18 operator
19 games
20 nobody
[root@linuxprobe ~]# cat /etc/vsftpd/ftpusers 
# Users that are not allowed to login via ftp
1 root
2 bin
3 daemon
4 adm
5 lp
6 sync
7 shutdown
8 halt
9 mail
10 news
11 uucp
12 operator
13 games
14 nobody</code></pre>
<p>也可以选择ftpusers和user_list文件中没有的一个普通用户尝试登录FTP服务器：</p>
<pre><code>[root@linuxprobe ~]# ftp 192.168.10.10 
Connected to 192.168.10.10 (192.168.10.10).
220 (vsFTPd 3.0.2)
Name (192.168.10.10:root): linuxprobe
331 Please specify the password.
Password:此处输入该用户的密码
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&gt; mkdir files
550 Create directory operation failed.</code></pre>
<p>在采用本地用户模式登录FTP服务器后，默认访问的是该用户的家目录，也就是说，访问的是/home/linuxprobe目录。而且该目录的默认所有者、所属组都是该用户自己，因此不存在写入权限不足的情况。但是当前的操作仍然被拒绝，是因为我们刚才将虚拟机系统还原到最初的状态了。为此，需要再次开启SELinux域中对FTP服务的允许策略：</p>
<pre><code>[root@linuxprobe ~]# getsebool -a | grep ftp
ftp_home_dir --&gt; off
ftpd_anon_write --&gt; off
ftpd_connect_all_unreserved --&gt; off
ftpd_connect_db --&gt; off
ftpd_full_access --&gt; off
……
[root@linuxprobe ~]# setsebool -P ftpd_full_access=on</code></pre>
<p>配置妥当后再使用本地用户尝试登录下FTP服务器，分别执行文件的创建、重命名及删除等命令。操作均成功！</p>
<pre><code>[root@linuxprobe ~]# ftp 192.168.10.10
Connected to 192.168.10.10 (192.168.10.10).
220 (vsFTPd 3.0.2)
Name (192.168.10.10:root): linuxprobe
331 Please specify the password.
Password:此处输入该用户的密码
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&gt; mkdir files
257 &quot;/home/linuxprobe/files&quot; created
ftp&gt; rename files database
350 Ready for RNTO.
250 Rename successful.
ftp&gt; rmdir database
250 Remove directory operation successful.
ftp&gt; exit
221 Goodbye.</code></pre>
<h2 id="2-3虚拟用户模式"><a href="#2-3虚拟用户模式" class="headerlink" title="2.3虚拟用户模式"></a>2.3虚拟用户模式</h2><p>第1步：在<strong>服务器</strong>中创建用于进行FTP认证的用户数据库文件，其中奇数行为账户名，偶数行为密码。例如，我们分别创建出zhangsan和lisi两个用户，密码均为redhat：</p>
<pre><code>[root@linuxprobe ~]# cd /etc/vsftpd/
[root@linuxprobe vsftpd]# vim vuser.list
zhangsan
redhat
lisi
redhat</code></pre>
<p>第2步：明文信息既不安全，也不符合让vsftpd服务程序直接加载的格式，因此需要使用db_load命令用哈希（hash）算法将原始的明文信息文件转换成数据库文件，并且降低数据库文件的权限（避免其他人看到数据库文件的内容），然后再把原始的明文信息文件删除。</p>
<pre><code>[root@linuxprobe vsftpd]# db_load -T -t hash -f vuser.list vuser.db
[root@linuxprobe vsftpd]# file vuser.db
vuser.db: Berkeley DB (Hash, version 9, native byte-order)
[root@linuxprobe vsftpd]# chmod 600 vuser.db
[root@linuxprobe vsftpd]# rm -f vuser.list</code></pre>
<p>第3步：创建vsftpd服务程序用于存储文件的根目录以及虚拟用户映射的系统本地用户。FTP服务用于存储文件的根目录指的是，当虚拟用户登录后所访问的默认位置。</p>
<p>为了方便管理FTP服务器上的数据，可以把这个系统本地用户的家目录设置为/var目录（该目录用来存放经常发生改变的数据）。并且为了安全起见，我们将这个系统本地用户设置为不允许登录FTP服务器，这不会影响虚拟用户登录，而且还可以避免黑客通过这个系统本地用户进行登录。</p>
<pre><code>[root@linuxprobe ~]# useradd -d /var/ftproot -s /sbin/nologin virtual
[root@linuxprobe ~]# ls -ld /var/ftproot/
drwx------. 3 virtual virtual 74 Jul 14 17:50 /var/ftproot/
[root@linuxprobe ~]# chmod -Rf 755 /var/ftproot/</code></pre>
<p>第4步：建立用于支持虚拟用户的PAM文件；新建一个用于虚拟用户认证的PAM文件vsftpd.vu，其中PAM文件内的“db=”参数为使用db_load命令生成的账户密码数据库文件的路径，但不用写数据库文件的后缀：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/pam.d/vsftpd.vu
auth       required     pam_userdb.so db=/etc/vsftpd/vuser
account    required     pam_userdb.so db=/etc/vsftpd/vuser</code></pre>
<p>第5步：在vsftpd服务程序的主配置文件中通过pam_service_name参数将PAM认证文件的名称修改为vsftpd.vu：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>anonymous_enable=NO</td>
<td>禁止匿名开放模式</td>
</tr>
<tr>
<td>local_enable=YES</td>
<td>允许本地用户模式</td>
</tr>
<tr>
<td>guest_enable=YES</td>
<td>开启虚拟用户模式</td>
</tr>
<tr>
<td>guest_username=virtual</td>
<td>指定虚拟用户账户</td>
</tr>
<tr>
<td>pam_service_name=vsftpd.vu</td>
<td>指定PAM文件</td>
</tr>
<tr>
<td>allow_writeable_chroot=YES</td>
<td>允许对禁锢的FTP根目录执行写入操作，而且不拒绝用户的登录请求</td>
</tr>
</tbody></table>
<pre><code>[root@linuxprobe ~]# vim /etc/vsftpd/vsftpd.conf
1 anonymous_enable=NO
2 local_enable=YES
3 guest_enable=YES
4 guest_username=virtual
5 allow_writeable_chroot=YES
6 write_enable=YES
7 local_umask=022
8 dirmessage_enable=YES
9 xferlog_enable=YES
10 connect_from_port_20=YES
11 xferlog_std_format=YES
12 listen=NO
13 listen_ipv6=YES
14 pam_service_name=vsftpd.vu
15 userlist_enable=YES
16 tcp_wrappers=YES</code></pre>
<p>第6步：为虚拟用户设置不同的权限。虽然账户zhangsan和lisi都是用于vsftpd服务程序认证的虚拟账户，但是我们依然想对这两人进行区别对待。比如，允许张三上传、创建、修改、查看、删除文件，只允许李四查看文件。这可以通过vsftpd服务程序来实现。只需新建一个目录，在里面分别创建两个以zhangsan和lisi命名的文件，其中在名为zhangsan的文件中写入允许的相关权限（使用匿名用户的参数）</p>
<pre><code>[root@linuxprobe ~]# mkdir /etc/vsftpd/vusers_dir/
[root@linuxprobe ~]# cd /etc/vsftpd/vusers_dir/
[root@linuxprobe vusers_dir]# touch lisi
[root@linuxprobe vusers_dir]# vim zhangsan
anon_upload_enable=YES
anon_mkdir_write_enable=YES
anon_other_write_enable=YES</code></pre>
<p>第7步：再次修改vsftpd主配置文件，通过添加user_config_dir参数来定义这两个虚拟用户不同权限的配置文件所存放的路径。为了让修改后的参数立即生效，需要重启vsftpd服务程序并将该服务添加到开机启动项中：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/vsftpd/vsftpd.conf
anonymous_enable=NO
local_enable=YES
guest_enable=YES
guest_username=virtual
allow_writeable_chroot=YES
write_enable=YES
local_umask=022
dirmessage_enable=YES
xferlog_enable=YES
connect_from_port_20=YES
xferlog_std_format=YES
listen=NO
listen_ipv6=YES
pam_service_name=vsftpd.vu
userlist_enable=YES
tcp_wrappers=YES
user_config_dir=/etc/vsftpd/vusers_dir
[root@linuxprobe ~]# systemctl restart vsftpd
[root@linuxprobe ~]# systemctl enable vsftpd
 ln -s &#39;/usr/lib/systemd/system/vsftpd.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/vsftpd.service</code></pre>
<p>第8步：设置SELinux域允许策略，然后使用虚拟用户模式登录FTP服务器。</p>
<pre><code>[root@linuxprobe ~]# getsebool -a | grep ftp
ftp_home_dir –&gt; off
ftpd_anon_write –&gt; off
ftpd_connect_all_unreserved –&gt; off
ftpd_connect_db –&gt; off
ftpd_full_access –&gt; off
……
[root@linuxprobe ~]# setsebool -P ftpd_full_access=on</code></pre>
<p>第9步：然后在<strong>客户端</strong>上重新安装FTP服务器；然后用虚拟用户模式成功登录FTP服务器，还可以分别使用账户zhangsan和lisi来检验他们的权限。</p>
<pre><code>[root@linuxprobe ~]# ftp 192.168.10.10
Connected to 192.168.10.10 (192.168.10.10).
220 (vsFTPd 3.0.2)
Name (192.168.10.10:root): lisi
331 Please specify the password.
Password:此处输入虚拟用户的密码
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&gt; mkdir files
550 Permission denied.
ftp&gt; exit
221 Goodbye.
[root@linuxprobe ~]# ftp 192.168.10.10
Connected to 192.168.10.10 (192.168.10.10).
220 (vsFTPd 3.0.2)
Name (192.168.10.10:root): zhangsan
331 Please specify the password.
Password:此处输入虚拟用户的密码
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&gt; mkdir files
257 &quot;/files&quot; created
ftp&gt; rename files database
350 Ready for RNTO.
250 Rename successful.
ftp&gt; rmdir database
250 Remove directory operation successful.
ftp&gt; exit
221 Goodbye.</code></pre>
<h1 id="3-TFTP简单文件传输协议"><a href="#3-TFTP简单文件传输协议" class="headerlink" title="3.TFTP简单文件传输协议"></a>3.TFTP简单文件传输协议</h1><p>简单文件传输协议（Trivial File Transfer Protocol，TFTP）是一种基于UDP协议在客户端和服务器之间进行简单文件传输的协议。顾名思义，它提供不复杂、开销不大的文件传输服务（可将其当作FTP协议的简化版本）。</p>
<p>第1步：在服务器上安装tftp-server、tftp和xinetd：</p>
<pre><code>[root@linuxprobe ~]# yum install tftp-server tftp xinetd</code></pre>
<p>第2步：TFTP服务是使用xinetd服务程序来管理的。xinetd服务可以用来管理多种轻量级的网络服务，而且具有强大的日志功能。简单来说，在安装TFTP软件包后，还需要在xinetd服务程序中将其开启，把默认的禁用（disable）参数修改为no：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/xinetd.d/tftp
service tftp
&#123;
        socket_type             = dgram
        protocol                = udp
        wait                    = yes
        user                    = root
        server                  = /usr/sbin/in.tftpd
        server_args             = -s /var/lib/tftpboot
        disable                 = no
        per_source              = 11
        cps                     = 100 2
        flags                   = IPv4
&#125;</code></pre>
<p>第3步：重启xinetd服务并将它添加到系统的开机启动项中，以确保TFTP服务在系统重启后依然处于运行状态：</p>
<pre><code>[root@linuxprobe ~]# systemctl restart xinetd
[root@linuxprobe ~]# systemctl enable xinetd</code></pre>
<p>第4步：考虑到有些系统的防火墙默认没有允许UDP协议的69端口，因此需要手动将该端口号加入到防火墙的允许策略中（看电脑实际情况而定）：</p>
<pre><code>[root@linuxprobe ~]# firewall-cmd --permanent --add-port=69/udp
success
[root@linuxprobe ~]# firewall-cmd --reload 
success</code></pre>
<p>第5步：TFTP的根目录为/var/lib/tftpboot，可以在改目录中放置或新建自己想要传输的数据文件，如：</p>
<p>[root@linuxprobe ~]# echo “i love linux” &gt; /var/lib/tftpboot/readme.txt</p>
<p>第6步：在客户端上按照以上步骤重新安装tftp；安装完成后，我们可以使用刚安装好的tftp命令尝试访问服务器端目录中的文件，亲身体验TFTP服务的文件传输过程。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>?</td>
<td>帮助信息</td>
</tr>
<tr>
<td>put</td>
<td>上传文件</td>
</tr>
<tr>
<td>get</td>
<td>下载文件</td>
</tr>
<tr>
<td>verbose</td>
<td>显示详细的处理信息</td>
</tr>
<tr>
<td>status</td>
<td>显示当前的状态信息</td>
</tr>
<tr>
<td>binary</td>
<td>使用二进制进行传输</td>
</tr>
<tr>
<td>ascii</td>
<td>使用ASCII码进行传输</td>
</tr>
<tr>
<td>timeout</td>
<td>设置重传的超时时间</td>
</tr>
<tr>
<td>quit</td>
<td>退出</td>
</tr>
</tbody></table>
<pre><code>[root@linuxprobe ~]# tftp 192.168.10.10
tftp&gt; get readme.txt
tftp&gt; quit
[root@linuxprobe ~]# ls
anaconda-ks.cfg Documents initial-setup-ks.cfg Pictures readme.txt Videos
Desktop Downloads Music Public Templates
[root@linuxprobe ~]# cat readme.txt 
i love linux</code></pre>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第11章节：使用Vsftpd服务传输文件</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学-15:使用Postfix与Dovecot部署邮件系统</title>
    <url>/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="1-电子邮件系统"><a href="#1-电子邮件系统" class="headerlink" title="1.电子邮件系统"></a>1.电子邮件系统</h1><p>电子邮件系统基于邮件协议来完成电子邮件的传输，常见的邮件协议有下面这些：</p>
<a id="more"></a>

<pre><code>简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）：用于发送和中转发出的电子邮件，占用服务器的25/TCP端口。

邮局协议版本3（Post Office Protocol 3）：用于将电子邮件存储到本地主机，占用服务器的110/TCP端口。

Internet消息访问协议版本4（Internet Message Access Protocol 4）：用于在本地主机上访问邮件，占用服务器的143/TCP端口。</code></pre>
<p>MUA：Mail User Agent，邮件用户代理；    MDA：Mail Delivery Agent，邮件投递代理；    </p>
<p>MTA：Mail Transfer Agent，邮件传输代理。</p>
<img src="/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/1.png" class>

<p>在生产环境中部署企业级的电子邮件系统时，有4个注意事项请留意。</p>
<pre><code>1.添加反垃圾与反病毒模块：它能够很有效地阻止垃圾邮件或病毒邮件对企业信箱的干扰。
2.对邮件加密：可有效保护邮件内容不被黑客盗取和篡改。
3.添加邮件监控审核模块：可有效地监控企业全体员工的邮件中是否有敏感词、是否有透露企业资料等违规行为。
4.保障稳定性：电子邮件系统的稳定性至关重要，运维人员应做到保证电子邮件系统的稳定运行，并及时做好防范分布式拒绝服务（Distributed Denial of Service，DDoS）攻击的准备。</code></pre>
<h1 id="2-部署基础的电子邮件系统"><a href="#2-部署基础的电子邮件系统" class="headerlink" title="2.部署基础的电子邮件系统"></a>2.部署基础的电子邮件系统</h1><p>一个最基础的电子邮件系统肯定要能提供发件服务和收件服务，为此需要使用基于SMTP协议的Postfix服务程序提供发件服务功能，并使用基于POP3协议的Dovecot服务程序提供收件服务功能。</p>
<p>要想更好地检验电子邮件系统的配置效果，需要先部署bind服务程序，为电子邮件服务器和客户端提供DNS域名解析服务。</p>
<p>第1步：部署bind服务程序。</p>
<pre><code>[root@linuxprobe ~]# yum install bind-chroot</code></pre>
<p>第2步：配置服务器主机名称，需要保证服务器主机名称与发信域名保持一致：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/hostname
mail.linuxprobe.com
[root@linuxprobe ~]# hostname
mail.linuxprobe.com
[root@linuxprobe ~]# vim /etc/hosts
192.168.10.10 mail.linuxprobe.com</code></pre>
<p>第3步：清空iptables防火墙默认策略，并保存策略状态，避免因防火墙中默认存在的策略阻止了客户端DNS解析域名及收发邮件：</p>
<pre><code>[root@localhost ~]# iptables -F
[root@localhost ~]# service iptables save
iptables: Saving firewall rules to /etc/sysconfig/iptables:[  OK  ]</code></pre>
<p>第4步：为电子邮件系统提供域名解析。</p>
<pre><code>[root@linuxprobe ~]# cat /etc/named.conf
 10 options &#123;
 11 listen-on port 53 &#123; any; &#125;;
 12 listen-on-v6 port 53 &#123; ::1; &#125;;
 13 directory &quot;/var/named&quot;;
 14 dump-file &quot;/var/named/data/cache_dump.db&quot;;
 15 statistics-file &quot;/var/named/data/named_stats.txt&quot;;
 16 memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;
 17 allow-query &#123; any; &#125;;
 18 
 ………………省略部分输出信息………………

[root@linuxprobe ~]# cat /etc/named.rfc1912.zones
zone &quot;linuxprobe.com&quot; IN &#123;
type master;
file &quot;linuxprobe.com.zone&quot;;
allow-update &#123;none;&#125;;
&#125;;

[root@linuxprobe ~]# cat /var/named/linuxprobe.com.zone</code></pre>
<img src="/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/2.png" class>

<pre><code>[root@linuxprobe ~]# systemctl restart named
[root@linuxprobe ~]# systemctl enable named
ln -s &#39;/usr/lib/systemd/system/named.service&#39; 
&#39;/etc/systemd/system/multi-user.target.wants/named.service&#39;</code></pre>
<p>测试时重启named服务时，显示报错：Job for named.service failed because the control process exited with error code. See “systemctl status named.service” and “journalctl -xe” for details.用named-checkconf -z /etc/named.conf（纠错命令）查看发现是由于配置文件内容写错导致！</p>
<p>这样电子邮件系统所对应的服务器主机名即为mail.linuxprobe.com，而邮件域为@linuxprobe.com。把服务器的DNS地址修改成本地IP地址：</p>
<img src="/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/3.jpg" class>

<p>修改完IP地址后，需要重启网卡，之后可用ping mail.linuxprobe.com或nslookup命令测试下配置是否成功：</p>
<img src="/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/4.png" class>

<p>用nslookup命令测试时，出现以下报错：server can’t find mail.linuxprobe.com:NXDOMAIN，并提示当前的server 192.168.10.2 不能使用；此时可编辑/etc/resolv.conf文件，将报错的nameserver 192.168.10.2删除，保留nameserver 192.168.10.10即可！之后再重启网卡，测试一下！</p>
<h2 id="2-1配置Postfix服务程序"><a href="#2-1配置Postfix服务程序" class="headerlink" title="2.1配置Postfix服务程序"></a>2.1配置Postfix服务程序</h2><p>第1步：安装Postfix服务程序；在安装完Postfix服务程序后，需要禁用iptables防火墙，否则外部用户无法访问电子邮件系统。</p>
<pre><code>[root@linuxprobe ~]# yum install postfix
Loaded plugins: langpacks, product-id, subscription-manager
rhel7 | 4.1 kB 00:00
(1/2): rhel7/group_gz | 134 kB 00:00
(2/2): rhel7/primary_db | 3.4 MB 00:00
Package 2:postfix-2.10.1-6.el7.x86_64 already installed and latest version
Nothing to do
[root@linuxprobe ~]# systemctl disable iptables</code></pre>
<p>第2步：配置Postfix服务程序，Postfix服务程序主配置文件（/etc/ postfix/main.cf）。</p>
<p>Postfix服务程序主配置文件中的重要参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>myhostname</td>
<td>邮局系统的主机名</td>
</tr>
<tr>
<td>mydomain</td>
<td>邮局系统的域名</td>
</tr>
<tr>
<td>myorigin</td>
<td>从本机发出邮件的域名名称</td>
</tr>
<tr>
<td>inet_interfaces</td>
<td>监听的网卡接口</td>
</tr>
<tr>
<td>mydestination</td>
<td>可接收邮件的主机名或域名</td>
</tr>
<tr>
<td>mynetworks</td>
<td>设置可转发哪些主机的邮件</td>
</tr>
<tr>
<td>relay_domains</td>
<td>设置可转发哪些网域的邮件</td>
</tr>
</tbody></table>
<p>在Postfix服务程序的主配置文件中，总计需要修改5处。首先是在第76行定义一个名为myhostname的变量，用来保存服务器的主机名称。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/postfix/main.cf
………………省略部分输出信息………………
68 # INTERNET HOST AND DOMAIN NAMES
69 # 
70 # The myhostname parameter specifies the internet hostname of this
71 # mail system. The default is to use the fully-qualified domain name
72 # from gethostname(). $myhostname is used as a default value for many
73 # other configuration parameters.
74 #
75 #myhostname = host.domain.tld
76 myhostname = mail.linuxprobe.com
………………省略部分输出信息………………</code></pre>
<p>然后在第83行定义一个名为mydomain的变量，用来保存邮件域的名称。大家也要记住这个变量名称，下面将调用它：</p>
<pre><code>78 # The mydomain parameter specifies the local internet domain name.
79 # The default is to use $myhostname minus the first component.
80 # $mydomain is used as a default value for many other configuration
81 # parameters.
82 #
83 mydomain = linuxprobe.com</code></pre>
<p>在第99行调用前面的mydomain变量，用来定义发出邮件的域。调用变量的好处是避免重复写入信息，以及便于日后统一修改：</p>
<pre><code>94 # For the sake of consistency between sender and recipient addresses,
95 # myorigin also specifies the default domain name that is appended
96 # to recipient addresses that have no @domain part.
97 #
98 #myorigin = $myhostname
99 myorigin = $mydomain</code></pre>
<p>第4处修改是在第116行定义网卡监听地址。可以指定要使用服务器的哪些IP地址对外提供电子邮件服务；也可以干脆写成all，代表所有IP地址都能提供电子邮件服务：</p>
<pre><code>111 # Note: you need to stop/start Postfix when this parameter changes.
112 #
113 #inet_interfaces = all
114 #inet_interfaces = $myhostname
115 #inet_interfaces = $myhostname, localhost
116 inet_interfaces = all</code></pre>
<p>最后一处修改是在第164行定义可接收邮件的主机名或域名列表。这里可以直接调用前面定义好的myhostname和mydomain变量（如果不想调用变量，也可以直接调用变量中的值）：</p>
<pre><code>162 # See also below, section &quot;REJECTING MAIL FOR UNKNOWN LOCAL USERS&quot;.
163 #
164 mydestination = $myhostname , $mydomain
165 #mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain
166 #mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain,</code></pre>
<p>第3步：创建电子邮件系统的登录账户。Postfix与vsftpd服务程序一样，都可以调用本地系统的账户和密码，因此在本地系统创建常规账户即可。最后重启配置妥当的postfix服务程序，并将其添加到开机启动项中。大功告成！</p>
<pre><code>[root@linuxprobe ~]# useradd boss
[root@linuxprobe ~]# echo &quot;linuxprobe&quot; | passwd --stdin boss
Changing password for user boss. passwd: all authentication tokens updated successfully.
[root@linuxprobe ~]# systemctl restart postfix
[root@linuxprobe ~]# systemctl enable postfix
ln -s &#39;/usr/lib/systemd/system/postfix.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/postfix.service&#39;</code></pre>
<h2 id="2-2配置Dovecot服务程序"><a href="#2-2配置Dovecot服务程序" class="headerlink" title="2.2配置Dovecot服务程序"></a>2.2配置Dovecot服务程序</h2><p>第1步：安装Dovecot服务程序软件包。大家可自行配置Yum软件仓库、挂载光盘镜像到指定目录，然后输入要安装的dovecot软件包名称即可：</p>
<pre><code>[root@linuxprobe ~]# yum install dovecot</code></pre>
<p>第2步：配置部署Dovecot服务程序。在Dovecot服务程序的主配置文件中进行如下修改。首先是第24行，把Dovecot服务程序支持的电子邮件协议修改为imap、pop3和lmtp。然后在这一行下面添加一行参数，允许用户使用明文进行密码验证。之所以这样操作，是因为Dovecot服务程序为了保证电子邮件系统的安全而默认强制用户使用加密方式进行登录，而由于当前还没有加密系统，因此需要添加该参数来允许用户的明文登录。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/dovecot/dovecot.conf
………………省略部分输出信息………………
23 # Protocols we want to be serving.
24 protocols = imap pop3 lmtp
25 disable_plaintext_auth = no
………………省略部分输出信息………………</code></pre>
<p>在主配置文件中的第48行，设置允许登录的网段地址，也就是说我们可以在这里限制只有来自于某个网段的用户才能使用电子邮件系统。如果想允许所有人都能使用，则不用修改本参数：</p>
<pre><code>44 # Space separated list of trusted network ranges. Connections from these
45 # IPs are allowed to override their IP addresses and ports (for logging and
46 # for authentication checks). disable_plaintext_auth is also ignored for
47 # these networks. Typically you&#39;d specify your IMAP proxy servers here.
48 login_trusted_networks = 192.168.10.0/24</code></pre>
<p>第3步：配置邮件格式与存储路径。在Dovecot服务程序单独的子配置文件中，定义一个路径，用于指定要将收到的邮件存放到服务器本地的哪个位置。这个路径默认已经定义好了，我们只需要将该配置文件中第24行前面的井号（#）删除即可。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/dovecot/conf.d/10-mail.conf
21 # See doc/wiki/Variables.txt for full list. Some examples:
22 #
23 # mail_location = maildir:~/Maildir
24 mail_location = mbox:~/mail:INBOX=/var/mail/%u
25 # mail_location = mbox:/var/mail/%d/%1n/%n:INDEX=/var/indexes/%d/%1n/%n
………………省略部分输出信息………………</code></pre>
<p>然后切换到配置Postfix服务程序时创建的boss账户，并在家目录中建立用于保存邮件的目录。记得要重启Dovecot服务并将其添加到开机启动项中。</p>
<pre><code>[root@linuxprobe ~]# su - linuxprobe
Last login: Sat Aug 15 16:15:58 CST 2017 on pts/1
[linuxprobe@mail ~]$ mkdir -p mail/.imap/INBOX
[linuxprobe@mail ~]$ exit
[root@linuxprobe ~]# systemctl restart dovecot 
[root@linuxprobe ~]# systemctl enable dovecot 
ln -s &#39;/usr/lib/systemd/system/dovecot.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/dovecot.service&#39;</code></pre>
<h2 id="2-3使用电子邮件系统"><a href="#2-3使用电子邮件系统" class="headerlink" title="2.3使用电子邮件系统"></a>2.3使用电子邮件系统</h2><p> 服务器与客户端的操作系统与IP地址：</p>
<table>
<thead>
<tr>
<th>主机名称</th>
<th>操作系统</th>
<th>IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>电子邮件系统及DNS服务器</td>
<td>RHEL 7</td>
<td>192.168.10.10</td>
</tr>
<tr>
<td>客户端主机</td>
<td>Windows 10</td>
<td>192.168.10.30</td>
</tr>
</tbody></table>
<img src="/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/5.png" class>

<p>第1步：在win10系统中安装foxmail软件；安装后在软件账号管理-账号处新建账号，输入E-mail地址（如<a href="mailto:&#108;&#x69;&#x6e;&#x75;&#120;&#112;&#114;&#111;&#x62;&#x65;&#x40;&#108;&#105;&#110;&#x75;&#x78;&#x70;&#x72;&#111;&#98;&#x65;&#46;&#99;&#111;&#109;">&#108;&#x69;&#x6e;&#x75;&#120;&#112;&#114;&#111;&#x62;&#x65;&#x40;&#108;&#105;&#110;&#x75;&#x78;&#x70;&#x72;&#111;&#98;&#x65;&#46;&#99;&#111;&#109;</a>,linuxprobe是linux用户名）和用户密码：</p>
<img src="/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/6.png" class>

<p>第2步：设置接收服务器类型为POP3，输入邮件帐号和密码，设置POP服务器和SMTP服务器地址，两个为同一地址，如192.168.10.10，SSL端口处不勾选，之后创建成功！</p>
<img src="/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/7.png" class>

<p>第3步：账号建立后，即可从win 10系统向linux发送邮件：</p>
<img src="/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/8.png" class>

<p>第4步：发送邮件后，可在linux系统内部输入mail命令，并输入对应邮件数值编号查看邮件：</p>
<img src="/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/9.png" class>

<p>第5步：从linux系统向win10电脑发送邮件，只需输入mail 邮件地址，然后输入subject和正文；最后输入点（.)结束：</p>
<img src="/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/10.png" class>

<h1 id="3-设置用户别名邮箱"><a href="#3-设置用户别名邮箱" class="headerlink" title="3.设置用户别名邮箱"></a>3.设置用户别名邮箱</h1><p>用户别名功能是一项简单实用的邮件账户伪装技术，可以用来设置多个虚拟信箱的账户以接受发送的邮件，从而保证自身的邮件地址不被泄露，还可以用来接收自己的多个信箱中的邮件。</p>
<pre><code>[root@linuxprobe ~]# cat /etc/aliases
#
# Aliases in this file will NOT be expanded in the header from
# Mail, but WILL be visible over networks or from /bin/mail.
#
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The program &quot;newaliases&quot; must be run after
# &gt;&gt; NOTE &gt;&gt; this file is updated for any changes to
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; show through to sendmail.
#
# Basic system aliases -- these MUST be present.
mailer-daemon: postmaster
postmaster: root
# General redirections for pseudo accounts.
bin: root
daemon: root
adm: root
lp: root
sync: root
shutdown: root
halt: root
mail: root
news: root
……</code></pre>
<p>保存并退出aliases邮件别名服务的配置文件后，需要再执行一下newaliases命令，其目的是让新的用户别名配置文件立即生效。</p>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第15章节：使用Postfix与Dovecot部署邮件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：iptables与firewalld防火墙</title>
    <url>/2021/02/03/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Aiptables%E4%B8%8Efirewalld%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    <content><![CDATA[<h1 id="1-Iptables"><a href="#1-Iptables" class="headerlink" title="1.Iptables"></a>1.Iptables</h1><h2 id="（1）策略与规则链"><a href="#（1）策略与规则链" class="headerlink" title="（1）策略与规则链"></a>（1）策略与规则链</h2><p>iptables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链，而规则链则依据数据包处理位置的不同进行分类，具体如下：</p>
<a id="more"></a>

<pre><code>在进行路由选择前处理数据包（PREROUTING）；

处理流入的数据包（INPUT）；

处理流出的数据包（OUTPUT）；

处理转发的数据包（FORWARD）；

在进行路由选择后处理数据包（POSTROUTING）。</code></pre>
<p>iptables服务的术语分别是ACCEPT（允许流量通过）、REJECT（拒绝流量通过）、LOG（记录日志信息）、DROP（拒绝流量通过）。REJECT和DROP的不同点：就DROP来说，它是直接将流量丢弃而且不响应；REJECT则会在拒绝流量后再回复一条“您的信息已经收到，但是被扔掉了”信息，从而让流量发送方清晰地看到数据被拒绝的响应信息。</p>
<h2 id="（2）基本命令参数"><a href="#（2）基本命令参数" class="headerlink" title="（2）基本命令参数"></a>（2）基本命令参数</h2><p>防火墙策略规则的匹配顺序是从上至下的，因此要把较为严格、优先级较高的策略规则放到前面，以免发生错误。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-P</td>
<td>设置默认策略</td>
</tr>
<tr>
<td>-F</td>
<td>清空规则链</td>
</tr>
<tr>
<td>-L</td>
<td>查看规则链</td>
</tr>
<tr>
<td>-A</td>
<td>在规则链的末尾加入新规则</td>
</tr>
<tr>
<td>-I num</td>
<td>在规则链的头部加入新规则</td>
</tr>
<tr>
<td>-D num</td>
<td>删除某一条规则</td>
</tr>
<tr>
<td>-s</td>
<td>匹配来源地址IP/MASK，加叹号“!”表示除这个IP外</td>
</tr>
<tr>
<td>-d</td>
<td>匹配目标地址</td>
</tr>
<tr>
<td>-p</td>
<td>匹配协议，如TCP、UDP、ICMP</td>
</tr>
<tr>
<td>–dport num</td>
<td>匹配目标端口号</td>
</tr>
<tr>
<td>–sport num</td>
<td>匹配来源端口号</td>
</tr>
</tbody></table>
<p>规则链的默认策略拒绝动作只能是DROP，而不能是REJECT。</p>
<p>防火墙策略规则是按照从上到下的顺序匹配的，因此一定要把允许动作放到拒绝动作前面，否则所有的流量就将被拒绝掉，从而导致任何主机都无法访问我们的服务。</p>
<p>向INPUT规则链中添加拒绝192.168.10.5主机访问本机80端口（Web服务）的策略规则：</p>
<pre><code>[root@linuxprobe ~]# iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT</code></pre>
<p>向INPUT规则链中添加拒绝所有主机访问本机1000～1024端口的策略规则：</p>
<pre><code>[root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT
[root@linuxprobe ~]# iptables -A INPUT -p udp --dport 1000:1024 -j REJECT</code></pre>
<p>使用iptables命令配置的防火墙规则默认会在系统下一次重启时失效，如果想让配置的防火墙策略永久生效，还要执行保存命令：</p>
<pre><code>[root@linuxprobe ~]# service iptables save
iptables: Saving firewall rules to /etc/sysconfig/iptables: [ OK ]</code></pre>
<h1 id="2-Firewalld"><a href="#2-Firewalld" class="headerlink" title="2.Firewalld"></a>2.Firewalld</h1><table>
<thead>
<tr>
<th>区域</th>
<th>默认规则策略</th>
</tr>
</thead>
<tbody><tr>
<td>trusted</td>
<td>允许所有的数据包</td>
</tr>
<tr>
<td>home</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>internal</td>
<td>等同于home区域</td>
</tr>
<tr>
<td>work</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>public</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>external</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td>
</tr>
<tr>
<td>dmz</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td>
</tr>
<tr>
<td>block</td>
<td>拒绝流入的流量，除非与流出的流量相关</td>
</tr>
<tr>
<td>drop</td>
<td>拒绝流入的流量，除非与流出的流量相关</td>
</tr>
</tbody></table>
<h2 id="2-1图形管理工具"><a href="#2-1图形管理工具" class="headerlink" title="2.1图形管理工具"></a>2.1图形管理工具</h2><img src="/2021/02/03/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Aiptables%E4%B8%8Efirewalld%E9%98%B2%E7%81%AB%E5%A2%99/1.png" class>

<p>我们先将当前区域中请求http服务的流量设置为允许，但仅限当前生效：</p>
<img src="/2021/02/03/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Aiptables%E4%B8%8Efirewalld%E9%98%B2%E7%81%AB%E5%A2%99/2.png" class>

<p>试添加一条防火墙策略规则，使其放行访问8080～8088端口（TCP协议）的流量，并将其设置为永久生效，配置完毕之后，还需要在Options菜单中单击Reload Firewalld命令，让配置的防火墙策略立即生效：</p>
<img src="/2021/02/03/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Aiptables%E4%B8%8Efirewalld%E9%98%B2%E7%81%AB%E5%A2%99/3.png" class>

<img src="/2021/02/03/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Aiptables%E4%B8%8Efirewalld%E9%98%B2%E7%81%AB%E5%A2%99/4.png" class>

<p>使用iptables命令实现SNAT技术(Source Network Address Translation，源网络地址转换),可以使得多个内网中的用户通过同一个外网IP接入Internet:</p>
<img src="/2021/02/03/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Aiptables%E4%B8%8Efirewalld%E9%98%B2%E7%81%AB%E5%A2%99/5.png" class>

<p>将本机888端口的流量转发到22端口，且要求当前和长期均有效:</p>
<img src="/2021/02/03/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Aiptables%E4%B8%8Efirewalld%E9%98%B2%E7%81%AB%E5%A2%99/6.png" class>

<img src="/2021/02/03/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Aiptables%E4%B8%8Efirewalld%E9%98%B2%E7%81%AB%E5%A2%99/7.png" class>

<p>配置富规则，让192.168.10.20主机访问到本机的1234端口号:</p>
<img src="/2021/02/03/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Aiptables%E4%B8%8Efirewalld%E9%98%B2%E7%81%AB%E5%A2%99/8.png" class>

<p>把网卡与防火墙策略区域进行绑定:</p>
<img src="/2021/02/03/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Aiptables%E4%B8%8Efirewalld%E9%98%B2%E7%81%AB%E5%A2%99/9.png" class>

<h2 id="2-3服务的访问控制列表"><a href="#2-3服务的访问控制列表" class="headerlink" title="2.3服务的访问控制列表"></a>2.3服务的访问控制列表</h2><p>TCP Wrappers是RHEL 7系统中默认启用的一款流量监控程序，它能够根据来访主机的地址与本机的目标服务程序作出允许或拒绝的操作。换句话说，Linux系统中其实有两个层面的防火墙，第一种是前面讲到的基于TCP/IP协议的流量过滤工具，而TCP Wrappers服务则是能允许或禁止Linux系统提供服务的防火墙，从而在更高层面保护了Linux系统的安全运行。</p>
<p>在配置TCP Wrappers服务时需要遵循两个原则：</p>
<pre><code>（1）编写拒绝策略规则时，填写的是服务名称，而非协议名称；
（2）建议先编写拒绝策略规则（/etc/hosts.deny），再编写允许策略规则（/etc/hosts.allow），以便直观地看到相应的效果。</code></pre>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第8章节：iptables与firewalld防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：linux命令</title>
    <url>/2020/12/28/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Alinux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式"></a>1.命令格式</h1><p>格式要求： 命令名称 [命令参数]  [命令对象]<br>注意：<br>（1）命令名称、命令参数、命令对象之间需用空格键分隔；<br>（2）多个参数之间也要有空格，参数有长格式和短格式之分，分别用（–）和（-）作为前缀；长格式和长格式之间、长格式和短格式之间不能合并，短格式和短格式之间可以合并，共用一个空格，合并后仅保留一个-即可。</p>
<a id="more"></a>
<p>在命令行终端中输入”man 命令”来查看命令自身的帮助信息，在命令帮助信息的界面中，常用操作按键如下所示：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>空格键</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>PaGe down</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>PaGe up</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>home</td>
<td>直接前往首页</td>
</tr>
<tr>
<td>end</td>
<td>直接前往尾页</td>
</tr>
<tr>
<td>/</td>
<td>从上往下搜索某个关键词，如“/linux”</td>
</tr>
<tr>
<td>？</td>
<td>从下往上搜索某个关键词</td>
</tr>
<tr>
<td>n</td>
<td>定位到下一个搜索到的关键词</td>
</tr>
<tr>
<td>N</td>
<td>定位到上一个搜索到的关键词</td>
</tr>
<tr>
<td>q</td>
<td>退出帮助文档</td>
</tr>
</tbody></table>
<h1 id="2-常用的工作命令"><a href="#2-常用的工作命令" class="headerlink" title="2.常用的工作命令"></a>2.常用的工作命令</h1><ol>
<li>echo：用于在终端输出字符串或变量提取后的值，如： echo 字符串/$变量</li>
<li>date：用于显示及设置系统的时间或日期；<br> 直接输入date命令用于查看当前系统时间；<br> date “+%Y-%m-%d %H:%M:%S”:按照“年-月-日 小时:分钟:秒”的格式查看当前系统时间；<br> date -s “20200105 8:30:00”：将系统时间设置为2020年1月5日8点30分；<br> date “+%j”:用于查看今天是当年中的第几天；</li>
<li>reboot：用于重启系统；</li>
<li>poweroff：用于系统关机；</li>
<li>wget命令：用于在终端中下载网络文件（需连接网络才可以下载），如：wget http：//<a href="http://www.linuxprobe.com/docs/linuxprobe.pdf%EF%BC%9B">www.linuxprobe.com/docs/linuxprobe.pdf；</a></li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-b</td>
<td>后台下载模式</td>
</tr>
<tr>
<td>-P</td>
<td>下载到指定目录</td>
</tr>
<tr>
<td>-c</td>
<td>断点续传</td>
</tr>
<tr>
<td>-p</td>
<td>下载页面内的所有资源，包括图片、视频</td>
</tr>
<tr>
<td>-r</td>
<td>递归下载</td>
</tr>
</tbody></table>
<ol start="6">
<li>ps:用于查看系统中的进程状态；</li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>显示所有进程（包括其他用户）</td>
</tr>
<tr>
<td>-u</td>
<td>用户及其他详细信息</td>
</tr>
<tr>
<td>-x</td>
<td>显示没有控制终端的进程</td>
</tr>
</tbody></table>
<p>进程状态：R（运行）、S（休眠）、D（不可中断）、Z（僵死）、T（停止）；<br>7. top：用于动态地监视进程活动与系统负载等信息；<br>8. pidof：用于查询某个指定服务进程的PID值，如pidof sshd；<br>9. kill：用于终止某个指定PID的服务进程，如kill 2156；<br>10. killall：用于终止某个指定名称的服务所对应的全部进程；</p>
<h1 id="3-系统状态检测命令"><a href="#3-系统状态检测命令" class="headerlink" title="3.系统状态检测命令"></a>3.系统状态检测命令</h1><ol>
<li>ifconfig：用于获取网卡配置与网络状态等信息，可以查看到网卡名称、IP地址和物理地址；</li>
<li>uname：用于查看系统内核与系统版本等信息，加上-a参数能完整地查看当前系统的内核名称等信息；</li>
<li>uptime：用于查看系统的负载信息；负载值越低越好，尽量不要长期超过1，生产环境中不要超过5；</li>
<li>free：用于显示当前系统中内存的使用量信息，结合-h参数能以更人性化的方式树池当前内存的实时信息；</li>
<li>who：用于查看当前登入主机的用户终端信息；</li>
<li>last：用于查看所有系统的登陆记录，但仅供参考，其中内容可能会被篡改；</li>
<li>history：用于显示历史执行过的命令（默认为最近1000条的命令），使用-c参数则会清空所有的历史记录，使用“！编码数字”的方式可以重复执行某一次的命令；<br> 注：只有在终端关闭的时候，才会同步信息；</li>
<li>sosreport：用于收集系统配置及架构信息并输出诊断文档；</li>
</ol>
<h1 id="4-工作目录切换命令"><a href="#4-工作目录切换命令" class="headerlink" title="4.工作目录切换命令"></a>4.工作目录切换命令</h1><ol>
<li>pwd：用于显示用户当前所处的工作目录；</li>
<li>cd：用于切换工作路径，其中cd -：表示返回到上一次所处的目录； cd..:表示进入上级目录； cd~：表示切换到当前用户的家目录；</li>
<li>ls：用于显示目录中的文件信息，其中ls -a：表示查看全部文件（包括隐藏文件)；  ls -l：查看文件的属性、大小等详细信息； ls -d：查看目录及其详细信息；</li>
</ol>
<h1 id="5-文本文件编辑命令"><a href="#5-文本文件编辑命令" class="headerlink" title="5.文本文件编辑命令"></a>5.文本文件编辑命令</h1><ol>
<li>cat：用于查看纯文本文件（内容较少的），cat -n：显示行号；</li>
<li>more：用于查看纯文本文件（内容较多的）；按回车键向下走一行，空格键向下走一页；</li>
<li>head：用于查看文本文档的前N行内容，如 head -n 20 initial.cfg:查看initial.cfg文件的前20行内容；</li>
<li>tail：用于查看文本文档的后N行内容，如 tail -n 20 initial.cfg:查看initial.cfg文件的后20行内容；tail -f 文件名：用于实时查看最新日志文件；</li>
<li>tr：用于替换文本文件中的字符，格式为：tr [原始字符] [目标字符]，如 tr[a-z] [A-Z];</li>
<li>wc:用于统计指定文本的行数、字数和字节数；</li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td>只显示行数</td>
</tr>
<tr>
<td>-w</td>
<td>只显示单词数</td>
</tr>
<tr>
<td>-c</td>
<td>只显示字节数</td>
</tr>
<tr>
<td>-d</td>
<td>同时修改atime和mtime</td>
</tr>
</tbody></table>
<ol start="7">
<li>stat：用于查看文件的具体存储信息和时间等信息；其中Access表示最后一次访问文件的时间；Modify表示真实修改文件内容的时间；Change表示修改文件属性信息的时间。</li>
<li>cut：用于按“列”提取文本字符；-d参数：用于设置间隔符号； -f参数：用于设置想看的列数；</li>
<li>diff：用于比较多个文本文件的差异； –brief参数:用于确认两个文件是否不同；  -c参数：用于比较多个文件的差异之处。查询结果中有“！”开头的行，表示内容有不同。</li>
</ol>
<h1 id="6-文件目录管理命令"><a href="#6-文件目录管理命令" class="headerlink" title="6.文件目录管理命令"></a>6.文件目录管理命令</h1><p>1.touch：用于创建空白文件或设置文件的时间；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>修改读取时间</td>
</tr>
<tr>
<td>-m</td>
<td>修改修改时间</td>
</tr>
<tr>
<td>-c</td>
<td>修改更改权限时间</td>
</tr>
<tr>
<td>-d</td>
<td>同时修改atime和mtime</td>
</tr>
</tbody></table>
<p>2.mkdir：用于创建空白目录；mkdir -p：能够递归创建具有嵌套关系的文件目录。<br>3.cp：用于复制文件或目录；格式为：cp [选项] 源文件 目标文件<br>复制操作分为3种情况：<br>（1）如果目标文件为目录，则把源文件复制到该目录中；<br>（2）如果目标文件为文件，则会询问是否要覆盖它；<br>（3）如果目标文件不存在，则执行正常的复制操作；<br>4.mv：用于剪切文件或将文件重命名，格式为：mv [选项]  源文件 [目标路径|目标文件名]<br>5.rm：用于删除文件或目录； -f：强制删除； -r：用于删除文件夹或目录；<br>6.dd：用于按照指定大小和个数的数据块来复制文件或转换文件；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>if</td>
<td>输入的文件名称</td>
</tr>
<tr>
<td>of</td>
<td>输出的文件名称</td>
</tr>
<tr>
<td>bs</td>
<td>每个“块”的大小</td>
</tr>
<tr>
<td>count</td>
<td>复制“块”的个数</td>
</tr>
</tbody></table>
<p>如：dd if=/dev/zero of=560_file count=1 bs=560M</p>
<p>7.file:用于查看文件的类型；</p>
<h1 id="7-打包压缩与搜索命令"><a href="#7-打包压缩与搜索命令" class="headerlink" title="7.打包压缩与搜索命令"></a>7.打包压缩与搜索命令</h1><p>1.tar：用于将文件进行打包压缩或解压；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>创建压缩文件</td>
</tr>
<tr>
<td>-x</td>
<td>解开压缩文件</td>
</tr>
<tr>
<td>-z</td>
<td>用Gzip压缩或解压</td>
</tr>
<tr>
<td>-j</td>
<td>用bzip2压缩或解压</td>
</tr>
<tr>
<td>-v</td>
<td>显示压缩或解压的过程</td>
</tr>
<tr>
<td>-f</td>
<td>目标文件名</td>
</tr>
<tr>
<td>-C</td>
<td>指定解压到的目录</td>
</tr>
</tbody></table>
<p>将文件打包压缩：tar -czvf 压缩包名称.tar.gz 要打包的目录； 如： tar -czvf etc.tar.gz /etc<br>解压命令：tar -xzvf 压缩包名称.tar.gz; 如： tar xzvf etc.tar.gz -C /root/etc</p>
<p>2.grep:用于在文本中执行关键词搜索； -n：用来显示搜索到信息的行号； -v：用于反选信息；<br>3.find：用于按照指定条件来查找文件；格式为：find [查找路径] 寻找条件 操作； 如： find /etc -name “host*” -print<br>-exec:用于将find命令搜索到的结果交由后面的命令作进一步处理，exec虽然是长格式，但只需要一个“-”。</p>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第2章节：linux命令</tag>
      </tags>
  </entry>
</search>
