<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>linux就该这么学：linux命令</title>
    <url>/2020/12/28/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Alinux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式"></a>1.命令格式</h1><p>格式要求： 命令名称 [命令参数]  [命令对象]<br>注意：<br>（1）命令名称、命令参数、命令对象之间需用空格键分隔；<br>（2）多个参数之间也要有空格，参数有长格式和短格式之分，分别用（–）和（-）作为前缀；长格式和长格式之间、长格式和短格式之间不能合并，短格式和短格式之间可以合并，共用一个空格，合并后仅保留一个-即可。</p>
<a id="more"></a>
<p>在命令行终端中输入”man 命令”来查看命令自身的帮助信息，在命令帮助信息的界面中，常用操作按键如下所示：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>空格键</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>PaGe down</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>PaGe up</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>home</td>
<td>直接前往首页</td>
</tr>
<tr>
<td>end</td>
<td>直接前往尾页</td>
</tr>
<tr>
<td>/</td>
<td>从上往下搜索某个关键词，如“/linux”</td>
</tr>
<tr>
<td>？</td>
<td>从下往上搜索某个关键词</td>
</tr>
<tr>
<td>n</td>
<td>定位到下一个搜索到的关键词</td>
</tr>
<tr>
<td>N</td>
<td>定位到上一个搜索到的关键词</td>
</tr>
<tr>
<td>q</td>
<td>退出帮助文档</td>
</tr>
</tbody></table>
<h1 id="2-常用的工作命令"><a href="#2-常用的工作命令" class="headerlink" title="2.常用的工作命令"></a>2.常用的工作命令</h1><ol>
<li>echo：用于在终端输出字符串或变量提取后的值，如： echo 字符串/$变量</li>
<li>date：用于显示及设置系统的时间或日期；<br> 直接输入date命令用于查看当前系统时间；<br> date “+%Y-%m-%d %H:%M:%S”:按照“年-月-日 小时:分钟:秒”的格式查看当前系统时间；<br> date -s “20200105 8:30:00”：将系统时间设置为2020年1月5日8点30分；<br> date “+%j”:用于查看今天是当年中的第几天；</li>
<li>reboot：用于重启系统；</li>
<li>poweroff：用于系统关机；</li>
<li>wget命令：用于在终端中下载网络文件（需连接网络才可以下载），如：wget http：//<a href="http://www.linuxprobe.com/docs/linuxprobe.pdf%EF%BC%9B">www.linuxprobe.com/docs/linuxprobe.pdf；</a></li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-b</td>
<td>后台下载模式</td>
</tr>
<tr>
<td>-P</td>
<td>下载到指定目录</td>
</tr>
<tr>
<td>-c</td>
<td>断点续传</td>
</tr>
<tr>
<td>-p</td>
<td>下载页面内的所有资源，包括图片、视频</td>
</tr>
<tr>
<td>-r</td>
<td>递归下载</td>
</tr>
</tbody></table>
<ol start="6">
<li>ps:用于查看系统中的进程状态；</li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>显示所有进程（包括其他用户）</td>
</tr>
<tr>
<td>-u</td>
<td>用户及其他详细信息</td>
</tr>
<tr>
<td>-x</td>
<td>显示没有控制终端的进程</td>
</tr>
</tbody></table>
<p>进程状态：R（运行）、S（休眠）、D（不可中断）、Z（僵死）、T（停止）；<br>7. top：用于动态地监视进程活动与系统负载等信息；<br>8. pidof：用于查询某个指定服务进程的PID值，如pidof sshd；<br>9. kill：用于终止某个指定PID的服务进程，如kill 2156；<br>10. killall：用于终止某个指定名称的服务所对应的全部进程；</p>
<h1 id="3-系统状态检测命令"><a href="#3-系统状态检测命令" class="headerlink" title="3.系统状态检测命令"></a>3.系统状态检测命令</h1><ol>
<li>ifconfig：用于获取网卡配置与网络状态等信息，可以查看到网卡名称、IP地址和物理地址；</li>
<li>uname：用于查看系统内核与系统版本等信息，加上-a参数能完整地查看当前系统的内核名称等信息；</li>
<li>uptime：用于查看系统的负载信息；负载值越低越好，尽量不要长期超过1，生产环境中不要超过5；</li>
<li>free：用于显示当前系统中内存的使用量信息，结合-h参数能以更人性化的方式树池当前内存的实时信息；</li>
<li>who：用于查看当前登入主机的用户终端信息；</li>
<li>last：用于查看所有系统的登陆记录，但仅供参考，其中内容可能会被篡改；</li>
<li>history：用于显示历史执行过的命令（默认为最近1000条的命令），使用-c参数则会清空所有的历史记录，使用“！编码数字”的方式可以重复执行某一次的命令；<br> 注：只有在终端关闭的时候，才会同步信息；</li>
<li>sosreport：用于收集系统配置及架构信息并输出诊断文档；</li>
</ol>
<h1 id="4-工作目录切换命令"><a href="#4-工作目录切换命令" class="headerlink" title="4.工作目录切换命令"></a>4.工作目录切换命令</h1><ol>
<li>pwd：用于显示用户当前所处的工作目录；</li>
<li>cd：用于切换工作路径，其中cd -：表示返回到上一次所处的目录； cd..:表示进入上级目录； cd~：表示切换到当前用户的家目录；</li>
<li>ls：用于显示目录中的文件信息，其中ls -a：表示查看全部文件（包括隐藏文件)；  ls -l：查看文件的属性、大小等详细信息； ls -d：查看目录及其详细信息；</li>
</ol>
<h1 id="5-文本文件编辑命令"><a href="#5-文本文件编辑命令" class="headerlink" title="5.文本文件编辑命令"></a>5.文本文件编辑命令</h1><ol>
<li>cat：用于查看纯文本文件（内容较少的），cat -n：显示行号；</li>
<li>more：用于查看纯文本文件（内容较多的）；按回车键向下走一行，空格键向下走一页；</li>
<li>head：用于查看文本文档的前N行内容，如 head -n 20 initial.cfg:查看initial.cfg文件的前20行内容；</li>
<li>tail：用于查看文本文档的后N行内容，如 tail -n 20 initial.cfg:查看initial.cfg文件的后20行内容；tail -f 文件名：用于实时查看最新日志文件；</li>
<li>tr：用于替换文本文件中的字符，格式为：tr [原始字符] [目标字符]，如 tr[a-z] [A-Z];</li>
<li>wc:用于统计指定文本的行数、字数和字节数；</li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td>只显示行数</td>
</tr>
<tr>
<td>-w</td>
<td>只显示单词数</td>
</tr>
<tr>
<td>-c</td>
<td>只显示字节数</td>
</tr>
<tr>
<td>-d</td>
<td>同时修改atime和mtime</td>
</tr>
</tbody></table>
<ol start="7">
<li>stat：用于查看文件的具体存储信息和时间等信息；其中Access表示最后一次访问文件的时间；Modify表示真实修改文件内容的时间；Change表示修改文件属性信息的时间。</li>
<li>cut：用于按“列”提取文本字符；-d参数：用于设置间隔符号； -f参数：用于设置想看的列数；</li>
<li>diff：用于比较多个文本文件的差异； –brief参数:用于确认两个文件是否不同；  -c参数：用于比较多个文件的差异之处。查询结果中有“！”开头的行，表示内容有不同。</li>
</ol>
<h1 id="6-文件目录管理命令"><a href="#6-文件目录管理命令" class="headerlink" title="6.文件目录管理命令"></a>6.文件目录管理命令</h1><p>1.touch：用于创建空白文件或设置文件的时间；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>修改读取时间</td>
</tr>
<tr>
<td>-m</td>
<td>修改修改时间</td>
</tr>
<tr>
<td>-c</td>
<td>修改更改权限时间</td>
</tr>
<tr>
<td>-d</td>
<td>同时修改atime和mtime</td>
</tr>
</tbody></table>
<p>2.mkdir：用于创建空白目录；mkdir -p：能够递归创建具有嵌套关系的文件目录。<br>3.cp：用于复制文件或目录；格式为：cp [选项] 源文件 目标文件<br>复制操作分为3种情况：<br>（1）如果目标文件为目录，则把源文件复制到该目录中；<br>（2）如果目标文件为文件，则会询问是否要覆盖它；<br>（3）如果目标文件不存在，则执行正常的复制操作；<br>4.mv：用于剪切文件或将文件重命名，格式为：mv [选项]  源文件 [目标路径|目标文件名]<br>5.rm：用于删除文件或目录； -f：强制删除； -r：用于删除文件夹或目录；<br>6.dd：用于按照指定大小和个数的数据块来复制文件或转换文件；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>if</td>
<td>输入的文件名称</td>
</tr>
<tr>
<td>of</td>
<td>输出的文件名称</td>
</tr>
<tr>
<td>bs</td>
<td>每个“块”的大小</td>
</tr>
<tr>
<td>count</td>
<td>复制“块”的个数</td>
</tr>
</tbody></table>
<p>如：dd if=/dev/zero of=560_file count=1 bs=560M</p>
<p>7.file:用于查看文件的类型；</p>
<h1 id="7-打包压缩与搜索命令"><a href="#7-打包压缩与搜索命令" class="headerlink" title="7.打包压缩与搜索命令"></a>7.打包压缩与搜索命令</h1><p>1.tar：用于将文件进行打包压缩或解压；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>创建压缩文件</td>
</tr>
<tr>
<td>-x</td>
<td>解开压缩文件</td>
</tr>
<tr>
<td>-z</td>
<td>用Gzip压缩或解压</td>
</tr>
<tr>
<td>-j</td>
<td>用bzip2压缩或解压</td>
</tr>
<tr>
<td>-v</td>
<td>显示压缩或解压的过程</td>
</tr>
<tr>
<td>-f</td>
<td>目标文件名</td>
</tr>
<tr>
<td>-C</td>
<td>指定解压到的目录</td>
</tr>
</tbody></table>
<p>将文件打包压缩：tar -czvf 压缩包名称.tar.gz 要打包的目录； 如： tar -czvf etc.tar.gz /etc<br>解压命令：tar -xzvf 压缩包名称.tar.gz; 如： tar xzvf etc.tar.gz -C /root/etc</p>
<p>2.grep:用于在文本中执行关键词搜索； -n：用来显示搜索到信息的行号； -v：用于反选信息；<br>3.find：用于按照指定条件来查找文件；格式为：find [查找路径] 寻找条件 操作； 如： find /etc -name “host*” -print<br>-exec:用于将find命令搜索到的结果交由后面的命令作进一步处理，exec虽然是长格式，但只需要一个“-”。</p>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第2章节：linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：管道符、重定向与环境变量</title>
    <url>/2021/01/09/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%AE%A1%E9%81%93%E7%AC%A6%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="1-输入输出重定向"><a href="#1-输入输出重定向" class="headerlink" title="1.输入输出重定向"></a>1.输入输出重定向</h1><p>输入重定向：是指把文件导入到命令中； 输出重定向：是指把原本要输出到屏幕的数据写入到指定文件中。输出重定向又分为标准输出重定向和错误输出重定向。<br>输入重定向中用到的符号及其作用：</p>
<a id="more"></a>


<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>命令 &lt; 文件</td>
<td>将文件作为命令的标准输入</td>
</tr>
<tr>
<td>命令 &lt;&lt; 分界符（tag）</td>
<td>将开始标记 tag 和结束标记 tag 之间的内容作为输入</td>
</tr>
</tbody></table>
<p>输入重定向中用到的符号及其作用：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>命令 &gt; 文件</td>
<td>将输出重定向到文件（会清空原有数据）</td>
</tr>
<tr>
<td>命令 &gt;&gt; 文件</td>
<td>将输出以追加的方式重定向到文件</td>
</tr>
<tr>
<td>n &gt; 文件</td>
<td>将文件描述符为 n 的文件重定向到文件</td>
</tr>
<tr>
<td>n &gt;&gt; 文件</td>
<td>将文件描述符为 n 的文件以追加的方式重定向到文件</td>
</tr>
<tr>
<td>n &gt;&amp; m</td>
<td>将输出文件 m 和 n 合并</td>
</tr>
<tr>
<td>n &lt;&amp; m</td>
<td>将输入文件 m 和 n 合并</td>
</tr>
<tr>
<td>&lt;&lt; tag</td>
<td>将开始标记 tag 和结束标记 tag 之间的内容作为输入</td>
</tr>
</tbody></table>
<p>注意：文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p>
<h1 id="2-管道命令符"><a href="#2-管道命令符" class="headerlink" title="2. 管道命令符"></a>2. 管道命令符</h1><p>命令符：可以把前一个命令原本要输出到屏幕的数据当作是后一个命令的标准输入；</p>
<h1 id="3-命令行的通配符"><a href="#3-命令行的通配符" class="headerlink" title="3.命令行的通配符"></a>3.命令行的通配符</h1><p>星号（*）：代表匹配零个或多个字符； 问号（？）：代表匹配单个字符； [0-9]:代表匹配0-9之间的单个数字； [abc]:代表匹配a、b、c三个字符中的任意一个；<br>[^…]和[!…]表示匹配不在方括号里面的字符（不包括空字符）；这两种写法是等价的。</p>
<h1 id="4-转义字符"><a href="#4-转义字符" class="headerlink" title="4.转义字符"></a>4.转义字符</h1><p>反斜杠（\）：使反斜杠后面变量称为单纯的字符串；<br>单引号（’’）：转义其中所有的变量为单纯的字符串；<br>双引号（””）:保留其中的变量属性，不尽兴转义处理；<br>反引号（``）:把其中的命令执行后返回结果。</p>
<h1 id="5-环境变量"><a href="#5-环境变量" class="headerlink" title="5.环境变量"></a>5.环境变量</h1><p>变量是计算机系统用于保存可变值得数据类型，变量名称一般都是大写的；环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录、邮件存放位置等。</p>
<p>前面讲过，在 Linux 系统中“一切皆文件”，Linux 命令也不例外。那么，当编辑完成 Linux 命令并回车后，系统底层到底发生了什么事情呢？</p>
<p>简单来说，Linux 命令的执行过程分为如下 4 个步骤。</p>
<pre><code>1) 判断路径
    判断用户是否以绝对路径或相对路径的方式输入命令（如 /bin/ls），如果是的话直接执行。

2) 检查别名
    Linux 系统会检查用户输入的命令是否为“别名命令”。要知道，通过 alias 命令是可以给现有命令自定义别名的，即用一个自定义的命令名称来替换原本的命令名称。

    例如，我们经常使用的 rm 命令，其实就是 rm -i 这个整体的别名：
    [root@localhost ~]# alias rm
    alias rm=&#39;rm -i&#39;

    这使得当使用 rm 命令删除指定文件时，Linux 系统会要求我们再次确认是否执行删除操作。例如：
    [root@localhost ~]# rm a.txt &lt;-- 假定当前目录中已经存在 a.txt 文件
    rm: remove regular file &#39;a.txt&#39;? y  &lt;-- 手动输入 y，即确定删除
    [root@localhost ~]#

    这里可以使用 unalias 命令，将 Linux 系统设置的 rm 别名删除掉，执行命令如下：
    [root@localhost ~]# alias rm
    alias rm=&#39;rm -i&#39;
    [root@localhost ~]# unalias rm
    [root@localhost ~]# rm a.txt
    [root@localhost ~]#  &lt;--直接删除，不再询问


    注意，这里仅是为了演示 unalisa 的用法，建议读者删除 rm 别名之后，再手动添加到系统中，执行如下命令即可再次成功添加：
    [root@localhost ~]# alias rm=&#39;rm -i&#39;

3) 判断是内部命令还是外部命令
    Linux命令行解释器（又称为 Shell）会判断用户输入的命令是内部命令还是外部命令。其中，内部命令指的是解释器内部的命令，会被直接执行；而用户通常输入的命令都是外部命令，这些命令交给步骤四继续处理。
    内部命令由 Shell 自带，会随着系统启动，可以直接从内存中读取；而外部命令仅是在系统中有对应的可执行文件，执行时需要读取该文件。

    判断一个命令属于内部命令还是外部命令，可以使用 type 命令实现。例如：
    [root@localhost ~]# type pwd
    pwd is a shell builtin  &lt;-- pwd是内部命令
    [root@localhost ~]# type top
    top is /usr/bin/top  &lt;-- top是外部命令

4) 查找外部命令对应的可执行文件
    当用户执行的是外部命令时，系统会在指定的多个路径中查找该命令的可执行文件，而定义这些路径的变量，就称为 PATH 环境变量，其作用就是告诉 Shell 待执行命令的可执行文件可能存放的位置，也就是说，Shell 会在 PATH 变量包含的多个路径中逐个查找，直到找到为止（如果找不到，Shell 会提供用户“找不到此命令”）</code></pre>
<p>自己创建的变量不具有全局性，作用范围有限，默认情况下不能被其他用户使用，因此，可通过export命令（如：export WORKDIR）将其提升为全局变量，这样其他用户也可以使用了！</p>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第3章节：管道符、重定向与环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title>图片加载命令</title>
    <url>/2020/12/07/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<img src="/2020/12/07/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%91%BD%E4%BB%A4/114.jpg" class="">
]]></content>
  </entry>
  <entry>
    <title>用hexo和github免费创建自己的博客</title>
    <url>/2020/12/06/%E7%94%A8hexo%E5%92%8Cgithub%E5%85%8D%E8%B4%B9%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="1-安装Nodejs"><a href="#1-安装Nodejs" class="headerlink" title="1.安装Nodejs"></a>1.安装Nodejs</h2><p>官方网站: <a href="https://nodejs.org/">https://nodejs.org</a>, 安装步骤非常简单，一直next，下一步就可以了，默认安装就行。</p>
<h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h2><p>官方网站：<a href="https://git-scm.com/downloads%EF%BC%8C">https://git-scm.com/downloads，</a> 然后我们选择windows版本的下载，安装也是一直点下一步，安装官方默认的来就行，<br>tips：这个Git Bash下载下来就相当于Linux中的终端窗口了，以后我们就用这个东东来打开终端。</p>
<a id="more"></a>
<h2 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h2><p>新建一个文件夹，比如我这里建了blog；打开你的文件夹，然后在空白处点鼠标的右键，选择 ==Git Bash Here==；<br>看看 node，npm是否安装成功，没有成功的就重新安装node：<br>node -v    #查看node版本<br>npm -v    #查看npm版本<br>我们需要先来安装个cnpm提高速度，以后下载什么东西都用cnpm，在上面终端继续输入：<br>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a><br>测试cnpm-成功:<br>cnpm -v    #查看cnpm版本<br>完成之后安装hexo：<br>cnpm install -g hexo-cli    #安装hexo框架<br>验证是否安装成功：<br>hexo -v    #查看hexo版本<br>用pwd命令查看当前路径，然后新建文件夹blog1：<br>mkdir blog1    #创建blog1目录<br>cd blog1     #进入blog1目录目录<br>hexo init     #生成博客 初始化博客（用Git Bash运行）<br>hexo s    #启动本地博客服务<br><a href="http://localhost:4000/">http://localhost:4000/</a>    #本地访问地址<br>hexo n “我的第一篇文章” #创建新的文章 </p>
<h2 id="4-返回blog目录"><a href="#4-返回blog目录" class="headerlink" title="4.返回blog目录"></a>4.返回blog目录</h2><p>hexo clean #清理<br>hexo g #生成</p>
<h2 id="5-将博客部署到GitHub上"><a href="#5-将博客部署到GitHub上" class="headerlink" title="5.将博客部署到GitHub上"></a>5.将博客部署到GitHub上</h2><p>在Github创建一个新的仓库 YourGithubName.github.io<br>然后输入cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件</p>
<h2 id="6-配置-config-yml"><a href="#6-配置-config-yml" class="headerlink" title="6.配置_config.yml"></a>6.配置_config.yml</h2><pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
      type: git
     repo: https://github.com/YourGithubName/YourGithubName.github.io.git
      branch: master</code></pre>
<p>win10 记得在 hexo d 之前输入以下命令：<br>git config –global user.email “xxx”<br>git config –global user.name “xxx”<br>然后用hexo d命令将博客部署到Github仓库里<br><a href="https://yourgithubname.github.io/">https://YourGithubName.github.io/</a>  #访问这个地址可以查看博客<br>注：<br>如果在输入hexo d命令时，提示有以下报错：ERROR Deployer not found: git<br>则在hexo的文件目录内输入以下命令：npm install –save hexo-deployer-git，之后再次输入hexo d命令即可</p>
<h2 id="7-安装主题"><a href="#7-安装主题" class="headerlink" title="7.安装主题"></a>7.安装主题</h2><p>下载yilia主题到本地：git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia<br>修改hexo根目录下的 _config.yml 文件 ： theme: yilia<br>hexo c    #清理一下<br>hexo g    #生成<br>hexo d    #部署到远程Github仓库<br><a href="https://yourgithubname.github.io/">https://YourGithubName.github.io/</a>  #查看博客</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
