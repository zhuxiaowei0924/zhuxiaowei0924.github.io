<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>linux内核升级到rhel7.9版本</title>
    <url>/2021/03/08/linux%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7%E5%88%B0rhel7.9%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<p>当前的系统版本为rhel7.0，内核版本为“Linux 3.10.0-123.el7.x86_64”</p>
<pre><code>[root@rhel7_0 ~]# hostnamectl
    ……
    Operating System: Red Hat Enterprise Linux Server 7.0 (Maipo)
    Kernel: Linux 3.10.0-123.el7.x86_64
    ……
[root@rhel0 ~]# uname -rs
    Linux 3.10.0-123.el7.x86_64</code></pre>
<p>1、从网上下载RHEL7.9版本的系统镜像文件，然后在 RHEL7.0 服务器上进行挂载，并配置在本地YUM源：</p>
<pre><code>[root@rhel7_0 ~]# mount /dev/cdrom /mnt/
[root@rhel7_0 ~]# cat /etc/yum.repos.d/rhel_local.repo 
    [mnt]
    name=mnt
    baseurl=file:///mnt
    enable=1
    gpgcheck=0</code></pre>
<p>2、在RHEL7.0服务器上先执行yum clean all，再使用yum list kernel命令查看当前服务器上已安装的内核以及可更新的高版本内核。</p>
<pre><code>[root@rhel7_0 ~]# yum list kernel
Loaded plugins: product-id, search-disabled-repos, subscription-manager
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
Installed Packages
kernel.x86_64                                                    3.10.0-123.el7                                                    @anaconda/7.2
Available Packages
kernel.x86_64                                                    3.10.0-1160.el7                                                    mnt          </code></pre>
<p>3、安装新内核.</p>
<pre><code>[root@rhel7_0 ~]# yum install -y kernel   
[root@rhel7_0 ~]# uname -rs</code></pre>
<p>　　    Linux 3.10.0-123.el7.x86_64</p>
<p>安装完成之后，再查看内核，发现没有变化，还是跟之前的一样。</p>
<p>查看/boot/grub2/grub.cfg 配置文件，可以看到新内核3.10.0-1160.el7.x86_64已经是排在最前边了，RHEL7 可以不用调整内核启动顺序，默认会从新内核启动。</p>
<p>这是进行系统重启reboot，系统会从新内核3.10.0-1160.el7.x86_64启动，但在登录界面显示一片黑屏或其他报错，因此在系统升级完后，不要着急重启，需要在终端输入：<strong>yum update</strong>进行更新，之后再重启，一切正常！</p>
<p>正常情况下，是不需要修改内核启动顺序的，如果发现内核启动顺序不对，可以按下面的方式来修改：</p>
<pre><code>[root@rhel7_0 ~]# grub2-editenv list  --查看系统默认内核版本
saved_entry=Red Hat Enterprise Linux Server (3.10.0-1160.el7.x86_64) 7.9 (Maipo)
[root@rhel7_0 ~]# grep &quot;menuentry &quot; /boot/grub2/grub.cfg  --查看配置文件里的内核顺序；这个菜单条目对应上图中的三条选项。
menuentry &#39;Red Hat Enterprise Linux Server (3.10.0-1160.el7.x86_64) 7.9 (Maipo)&#39; --class red --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option &#39;gnulinux-3.10.0-123.el7.x86_64-advanced-e2de1cc9-e059-4306-a1a5-2389e3f83c70&#39; &#123;
menuentry &#39;Red Hat Enterprise Linux Server (3.10.0-123.el7.x86_64) 7.0 (Maipo)&#39; --class red --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option &#39;gnulinux-3.10.0-123.el7.x86_64-advanced-e2de1cc9-e059-4306-a1a5-2389e3f83c70&#39; &#123;
menuentry &#39;Red Hat Enterprise Linux Server (0-rescue-1fbd678500124daea255a3b7a98e320c) 7.0 (Maipo)&#39; --class red --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option &#39;gnulinux-0-rescue-1fbd678500124daea255a3b7a98e320c-advanced-e2de1cc9-e059-4306-a1a5-2389e3f83c70&#39; &#123;
[root@rhel7_0 ~]# grub2-set-default &#39;Red Hat Enterprise Linux Server (3.10.0-1160.el7.x86_64) 7.9 (Maipo)&#39;   --配置默认内核
[root@rhel7_0 ~]# grub2-mkconfig -o /boot/grub2/grub.cfg    --将修改的内容写入到grub.cfg配置文件。
Generating grub configuration file ...
Found linux image: /boot/vmlinuz-3.10.0-1160.el7.x86_64
Found initrd image: /boot/initramfs-3.10.0-1160.el7.x86_64.img
Found linux image: /boot/vmlinuz-3.10.0-123.el7.x86_64
Found initrd image: /boot/initramfs-3.10.0-123.el7.x86_64.img
Found linux image: /boot/vmlinuz-0-rescue-1fbd678500124daea255a3b7a98e320c
Found initrd image: /boot/initramfs-0-rescue-1fbd678500124daea255a3b7a98e320c.img
done</code></pre>
<p>系统内核更新成功！</p>
]]></content>
      <categories>
        <category>linux系统</category>
      </categories>
      <tags>
        <tag>linux内核升级</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学-12:使用Samba或NFS实现文件共享</title>
    <url>/2021/02/11/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-12-%E4%BD%BF%E7%94%A8Samba%E6%88%96NFS%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<h1 id="1-SAMBA文件共享服务"><a href="#1-SAMBA文件共享服务" class="headerlink" title="1.SAMBA文件共享服务"></a>1.SAMBA文件共享服务</h1><p>Samba服务程序现在已经成为在Linux系统与Windows系统之间共享文件的最佳选择。</p>
<p>首先需要先通过Yum软件仓库来安装Samba服务程序：</p>
<a id="more"></a> 

<pre><code>[root@linuxprobe ~ ]# yum install samba</code></pre>
<p> Samba服务程序中的参数以及作用:</p>
<pre><code>[global]                                    #全局参数。

    workgroup = MYGROUP                        #工作组名称

    server string = Samba Server Version %v    #服务器介绍信息，参数%v为显示SMB版本号

    log file = /var/log/samba/log.%m        #定义日志文件的存放位置与名称，参数%m为来访的主机名

    max log size = 50                        #定义日志文件的最大容量为50KB

    security = user                            #安全验证的方式，总共有4种

    #share：来访主机无需验证口令；比较方便，但安全性很差

    #user：需验证来访主机提供的口令后才可以访问；提升了安全性

    #server：使用独立的远程主机验证来访主机提供的口令（集中管理账户）

    #domain：使用域控制器进行身份验证

    passdb backend = tdbsam                    #定义用户后台的类型，共有3种

    #smbpasswd：使用smbpasswd命令为系统用户设置Samba服务程序的密码

    #tdbsam：创建数据库文件并使用pdbedit命令建立Samba服务程序的用户

    #ldapsam：基于LDAP服务进行账户验证

    load printers = yes                        #设置在Samba服务启动时是否共享打印机设备

    cups options = raw                        #打印机的选项

[homes]                                        #共享参数

    comment = Home Directories                #描述信息

    browseable = no                            #指定共享信息是否在“网上邻居”中可见

    writable = yes                            #定义是否可以执行写入操作，与“read only”相反

[printers]                                    #打印机共享参数

    comment = All Printers    

    path = /var/spool/samba                    #共享文件的实际路径(重要)。

    browseable = no    
    guest ok = no                            #是否所有人可见，等同于&quot;public&quot;参数。

    writable = no    

    printable = yes    

[root@linuxprobe ~]# cat /etc/samba/smb.conf</code></pre>
<h2 id="1-1配置共享资源"><a href="#1-1配置共享资源" class="headerlink" title="1.1配置共享资源"></a>1.1配置共享资源</h2><p>用于设置Samba服务程序的参数以及作用：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>[database]</td>
<td>共享名称为database</td>
</tr>
<tr>
<td>comment = Do not arbitrarily modify the database file</td>
<td>警告用户不要随意修改数据库</td>
</tr>
<tr>
<td>path = /home/database</td>
<td>共享目录为/home/database</td>
</tr>
<tr>
<td>public = no</td>
<td>关闭“所有人可见”</td>
</tr>
<tr>
<td>writable = yes</td>
<td>允许写入操作</td>
</tr>
</tbody></table>
<p>第1步：创建用于访问共享资源的账户信息。在RHEL 7系统中，Samba服务程序默认使用的是用户口令认证模式（user）。这种认证模式可以确保仅让有密码且受信任的用户访问共享资源，而且验证过程也十分简单。不过，只有建立账户信息数据库之后，才能使用用户口令认证模式。另外，Samba服务程序的数据库要求账户必须在当前系统中已经存在，否则日后创建文件时将导致文件的权限属性混乱不堪，由此引发错误。</p>
<p>pdbedit命令用于管理SMB服务程序的账户信息数据库，格式为“pdbedit [选项] 账户”。在第一次把账户信息写入到数据库时需要使用-a参数，以后在执行修改密码、删除账户等操作时就不再需要该参数了。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-a 用户名</td>
<td>建立Samba用户</td>
</tr>
<tr>
<td>-x 用户名</td>
<td>删除Samba用户</td>
</tr>
<tr>
<td>-L</td>
<td>列出用户列表</td>
</tr>
<tr>
<td>-Lv</td>
<td>列出用户详细信息的列表</td>
</tr>
</tbody></table>
<pre><code>[root@linuxprobe ~]# id linuxprobe
uid=1000(linuxprobe) gid=1000(linuxprobe) groups=1000(linuxprobe)
[root@linuxprobe ~]# pdbedit -a -u linuxprobe
new password:此处输入该账户在Samba服务数据库中的密码
retype new password:再次输入密码进行确认
Unix username: linuxprobe
NT username: 
Account Flags: [U ]
……
Logon hours : FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code></pre>
<p>第2步：创建用于共享资源的文件目录。</p>
<pre><code>[root@linuxprobe ~]# mkdir /home/database
[root@linuxprobe ~]# chown -Rf linuxprobe:linuxprobe /home/database
[root@linuxprobe ~]# semanage fcontext -a -t samba_share_t /home/database
[root@linuxprobe ~]# restorecon -Rv /home/database
restorecon reset /home/database context unconfined_u:object_r:home_root_t:s0-&gt;unconfined_u:object_r:samba_share_t:s0</code></pre>
<p>第3步：设置SELinux服务与策略，使其允许通过Samba服务程序访问普通用户家目录。</p>
<pre><code>[root@linuxprobe ~]# getsebool -a | grep samba
samba_create_home_dirs --&gt; off
samba_domain_controller --&gt; off
samba_enable_home_dirs --&gt; off
……
[root@linuxprobe ~]# setsebool -P samba_enable_home_dirs on</code></pre>
<p>第4步：在Samba服务程序的主配置文件中，写入共享信息。在原始的配置文件中，[homes]参数为来访用户的家目录共享信息，[printers]参数为共享的打印机设备可以手动删除，这没有任何问题。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/samba/smb.conf 
[global]
 workgroup = MYGROUP
 server string = Samba Server Version %v
 log file = /var/log/samba/log.%m
 max log size = 50
 security = user
 passdb backend = tdbsam
 load printers = yes
 cups options = raw
[database]
 comment = Do not arbitrarily modify the database file
 path = /home/database
 public = no
 writable = yes</code></pre>
<p>第5步：Samba服务程序的配置工作基本完毕。接下来重启smb服务（Samba服务程序在Linux系统中的名字为smb）并清空iptables防火墙。</p>
<pre><code>[root@linuxprobe ~]# systemctl restart smb
[root@linuxprobe ~]# systemctl enable smb
 ln -s &#39;/usr/lib/systemd/system/smb.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/smb.service&#39;
[root@linuxprobe ~]# iptables -F
[root@linuxprobe ~]# service iptables save
iptables: Saving firewall rules to /etc/sysconfig/iptables:[ OK ]</code></pre>
<h2 id="1-2windows挂载共享"><a href="#1-2windows挂载共享" class="headerlink" title="1.2windows挂载共享"></a>1.2windows挂载共享</h2><p>Samba服务器和Windows客户端使用的操作系统以及IP地址（举例）：</p>
<p>| 主机名称 | 操作系统 | IP地址 |<br>| — | — |<br>| Samba共享服务器 |     RHEL 7 | 192.168.10.10 |<br>| Linux客户端 | RHEL 7 | 192.168.10.20 |<br>| Windows客户端 | Windows 7 | 192.168.10.30 |</p>
<p>要在Windows系统中访问共享资源，只需在Windows的“运行”命令框中输入两个反斜杠，然后再加服务器的IP地址即可：</p>
<img src="/2021/02/11/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-12-%E4%BD%BF%E7%94%A8Samba%E6%88%96NFS%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/1.png" class>

<p>在RHEL 7系统中，Samba服务程序使用的果然是独立的账户信息数据库。所以，即便在Linux系统中有一个linuxprobe账户，Samba服务程序使用的账户信息数据库中也有一个同名的linuxprobe账户，大家也一定要弄清楚它们各自所对应的密码。</p>
<img src="/2021/02/11/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-12-%E4%BD%BF%E7%94%A8Samba%E6%88%96NFS%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/2.jpg" class>

<p>正确输入linuxprobe账户名以及使用pdbedit命令设置的密码后，就可以登录到共享界面中了!</p>
<p>由于Windows系统的缓存原因，有可能您在第二次登录时提供了正确的账户和密码，依然会报错，这时只需要重新启动一下Windows客户端就没问题了!</p>
<h2 id="1-3linux挂载共享"><a href="#1-3linux挂载共享" class="headerlink" title="1.3linux挂载共享"></a>1.3linux挂载共享</h2><p> Samba共享服务器和Linux客户端各自使用的操作系统以及IP地址：</p>
<p>| 主机名称 | 操作系统 | IP地址 |<br>| — | — |<br>| Samba共享服务器 |     RHEL 7 | 192.168.10.10 |<br>| Linux客户端 | RHEL 7 | 192.168.10.20 |<br>| Windows客户端 | Windows 7 | 192.168.10.30 |</p>
<pre><code>[root@linuxprobe ~]# yum install cifs-utils
Loaded plugins: langpacks, product-id, subscription-manager
rhel | 4.1 kB 00:00 
Resolving Dependencies
--&gt; Running transaction check
---&gt; Package cifs-utils.x86_64 0:6.2-6.el7 will be installed
--&gt; Finished Dependency Resolution
Dependencies Resolved
……
Installed:
 cifs-utils.x86_64 0:6.2-6.el7 
Complete!</code></pre>
<p>在Linux客户端，按照Samba服务的用户名、密码、共享域的顺序将相关信息写入到一个认证文件中。为了保证不被其他人随意看到，最后把这个认证文件的权限修改为仅root管理员才能够读写：</p>
<pre><code>[root@linuxprobe ~]# vim auth.smb
username=linuxprobe
password=redhat
domain=MYGROUP
[root@linuxprobe ~]# chmod -Rf 600 auth.smb</code></pre>
<p>现在，在Linux客户端上创建一个用于挂载Samba服务共享资源的目录，并把挂载信息写入到/etc/fstab文件中，以确保共享挂载信息在服务器重启后依然生效：</p>
<pre><code>[root@linuxprobe ~]# mkdir /database
[root@linuxprobe ~]# vim /etc/fstab
/dev/mapper/rhel-swap swap swap defaults 0 0
/dev/cdrom /media/cdrom iso9660 defaults 0 0 
//192.168.10.10/database /database cifs credentials=/root/auth.smb 0 0
[root@linuxprobe ~]# mount -a</code></pre>
<p>Linux客户端成功地挂载了Samba服务的共享资源。进入到挂载目录/database后就可以看到Windows系统访问Samba服务程序时留下来的文件了（即文件Memo.txt）。当然，我们也可以对该文件进行读写操作并保存。</p>
<pre><code>[root@linuxprobe ~]# cat /database/Memo.txt</code></pre>
<h1 id="2-NFS网络文件系统"><a href="#2-NFS网络文件系统" class="headerlink" title="2.NFS网络文件系统"></a>2.NFS网络文件系统</h1><p>NFS服务：用于两台linux主机进行共享文件；</p>
<pre><code>[root@linuxprobe ~]# yum install nfs-utils</code></pre>
<p>| 主机名称 | 操作系统 | IP地址 |<br>| — | — |<br>| Linux服务端 |     RHEL 7 | 192.168.10.10 |<br>| Linux客户端 | RHEL 7 | 192.168.10.20 |</p>
<pre><code>[root@linuxprobe ~]# iptables -F
[root@linuxprobe ~]# service iptables save
iptables: Saving firewall rules to /etc/sysconfig/iptables:[ OK ]</code></pre>
<p>第2步：在NFS服务器上建立用于NFS文件共享的目录，并设置足够的权限确保其他人也有写入权限。</p>
<pre><code>[root@linuxprobe ~]# mkdir /nfsfile
[root@linuxprobe ~]# chmod -Rf 777 /nfsfile
[root@linuxprobe ~]# echo &quot;welcome to linuxprobe.com&quot; &gt; /nfsfile/readme</code></pre>
<p>第3步：NFS服务程序的配置文件为/etc/exports，默认情况下里面没有任何内容。我们可以按照“共享目录的路径 允许访问的NFS客户端（共享权限参数）”的格式，定义要共享的目录与相应的权限。</p>
<p>用于配置NFS服务程序配置文件的参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ro</td>
<td>只读</td>
</tr>
<tr>
<td>rw</td>
<td>读写</td>
</tr>
<tr>
<td>root_squash</td>
<td>当NFS客户端以root管理员访问时，映射为NFS服务器的匿名用户</td>
</tr>
<tr>
<td>no_root_squash</td>
<td>当NFS客户端以root管理员访问时，映射为NFS服务器的root管理员</td>
</tr>
<tr>
<td>all_squash</td>
<td>无论NFS客户端使用什么账户访问，均映射为NFS服务器的匿名用户</td>
</tr>
<tr>
<td>sync</td>
<td>同时将数据写入到内存与硬盘中，保证不丢失数据</td>
</tr>
<tr>
<td>async</td>
<td>优先将数据保存到内存，然后再写入硬盘；这样效率更高，但可能会丢失数据</td>
</tr>
</tbody></table>
<p>请注意，NFS客户端地址与权限之间没有空格。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/exports
/nfsfile 192.168.10.*(rw,sync,root_squash)</code></pre>
<p>第4步：启动和启用NFS服务程序。由于在使用NFS服务进行文件共享之前，需要使用RPC（Remote Procedure Call，远程过程调用）服务将NFS服务器的IP地址和端口号等信息发送给客户端。因此，在启动NFS服务之前，还需要顺带重启并启用rpcbind服务程序，并将这两个服务一并加入开机启动项中。</p>
<pre><code>[root@linuxprobe ~]# systemctl restart rpcbind
[root@linuxprobe ~]# systemctl enable rpcbind
[root@linuxprobe ~]# systemctl start nfs-server
[root@linuxprobe ~]# systemctl enable nfs-server</code></pre>
<p>NFS客户端的配置步骤也十分简单。先使用showmount命令（以及必要的参数，见表12-8）查询NFS服务器的远程共享信息，其输出格式为“共享的目录名称 允许使用客户端地址”。</p>
<p>showmount命令中可用的参数以及作用：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-e</td>
<td>显示NFS服务器的共享列表</td>
</tr>
<tr>
<td>-a</td>
<td>显示本机挂载的文件资源的情况NFS资源的情况</td>
</tr>
<tr>
<td>-v</td>
<td>显示版本号</td>
</tr>
</tbody></table>
<pre><code>[root@linuxprobe ~]# showmount -e 192.168.10.10
Export list for 192.168.10.10:
/nfsfile 192.168.10.*</code></pre>
<p>然后在NFS客户端创建一个挂载目录。使用mount命令并结合-t参数，指定要挂载的文件系统的类型，并在命令后面写上服务器的IP地址、服务器上的共享目录以及要挂载到本地系统（即客户端）的目录。</p>
<pre><code>[root@linuxprobe ~]# mkdir /nfsfile
[root@linuxprobe ~]# mount -t nfs 192.168.10.10:/nfsfile /nfsfile</code></pre>
<p>如果希望NFS文件共享服务能一直有效，则需要将其写入到fstab文件中：</p>
<pre><code>[root@linuxprobe ~]# cat /nfsfile/readme
    welcome to linuxprobe.com
[root@linuxprobe ~]# vim /etc/fstab
    ……
    /dev/cdrom /media/cdrom iso9660 defaults 0 0 
    192.168.10.10:/nfsfile /nfsfile nfs defaults 0 0</code></pre>
<h1 id="3-AutoFs自动挂载服务"><a href="#3-AutoFs自动挂载服务" class="headerlink" title="3.AutoFs自动挂载服务"></a>3.AutoFs自动挂载服务</h1><pre><code>[root@linuxprobe ~]# yum install autofs</code></pre>
<p>在autofs服务程序的主配置文件中需要按照“挂载目录 <strong>子配置文件</strong>”的格式进行填写。挂载目录是设备挂载位置的上一级目录。例如，光盘设备一般挂载到/media/cdrom目录中，那么挂载目录写成/media即可。对应的<strong>子配置文件</strong>则是对这个挂载目录内的挂载设备信息作进一步的说明。<strong>子配置文件</strong>需要用户自行定义，文件名字没有严格要求，但后缀建议以.misc结束。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/auto.master
#
# Sample auto.master file
# This is an automounter map and it has the following format
# key [ -mount-options-separated-by-comma ] location
# For details of the format look at autofs(5).
#
/media /etc/iso.misc
/misc /etc/auto.misc
#
# NOTE: mounts done from a hosts map will be mounted with the
# &quot;nosuid&quot; and &quot;nodev&quot; options unless the &quot;suid&quot; and &quot;dev&quot;
# options are explicitly given.
……
    +auto.master</code></pre>
<p>在子配置文件中，应按照“挂载目录 挂载文件类型及权限 :设备名称”的格式进行填写，挂载目录写为iso，而-fstype为文件系统格式参数，iso9660为光盘设备格式，ro、nosuid及nodev为光盘设备具体的权限参数，/dev/cdrom则是定义要挂载的设备名称:</p>
<pre><code>[root@linuxprobe ~]# vim /etc/iso.misc
iso   -fstype=iso9660,ro,nosuid,nodev :/dev/cdrom
[root@linuxprobe ~]# systemctl start autofs 
[root@linuxprobe ~]# systemctl enable autofs 

[root@linuxprobe ~]# df -h
Filesystem Size Used Avail Use% Mounted on
/dev/mapper/rhel-root 18G 3.0G 15G 17% /
tmpfs 914M 0 914M 0% /sys/fs/cgroup
/dev/sda1 497M 119M 379M 24% /boot
[root@linuxprobe ~]# cd /media
[root@linuxprobe media]# ls
[root@linuxprobe media]# cd iso
[root@linuxprobe iso]# ls -l
total 812
dr-xr-xr-x. 4 root root 2048 May 7 2017 addons
dr-xr-xr-x. 3 root root 2048 May 7 2017 EFI
[root@linuxprobe ~]# df -h
Filesystem Size Used Avail Use% Mounted on
/dev/cdrom 3.5G 3.5G 0 100% /media/iso</code></pre>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第12章节：使用Samba或NFS实现文件共享</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学-14：使用DHCP动态管理主机地址</title>
    <url>/2021/02/15/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-14%EF%BC%9A%E4%BD%BF%E7%94%A8DHCP%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h1 id="1-动态主机地址管理协议"><a href="#1-动态主机地址管理协议" class="headerlink" title="1.动态主机地址管理协议"></a>1.动态主机地址管理协议</h1><p>DHCP：Dynamic Host Configuration Protocol，动态主机配置协议；该协议用于自动管理局域网内主机的IP地址、子网掩码、网关地址及DNS地址等参数，可以有效地提升IP地址的利用率，提高配置效率，并降低管理与维护成本。</p>
<a id="more"></a>

<pre><code>作用域：一个完整的IP地址段，DHCP协议根据作用域来管理网络的分布、分配IP地址及其他配置参数。

超级作用域：用于管理处于同一个物理网络中的多个逻辑子网段。超级作用域中包含了可以统一管理的作用域列表。

排除范围：把作用域中的某些IP地址排除，确保这些IP地址不会分配给DHCP客户端。

地址池：在定义了DHCP的作用域并应用了排除范围后，剩余的用来动态分配给DHCP客户端的IP地址范围。

租约：DHCP客户端能够使用动态分配的IP地址的时间。

预约：保证网络中的特定设备总是获取到相同的IP地址。</code></pre>
<h1 id="2-部署dhcpd服务程序"><a href="#2-部署dhcpd服务程序" class="headerlink" title="2.部署dhcpd服务程序"></a>2.部署dhcpd服务程序</h1><pre><code>[root@linuxprobe ~]# yum install dhcp</code></pre>
<p>查看dhcpd服务程序的配置文件内容：</p>
<pre><code>[root@linuxprobe ~]# cat /etc/dhcp/dhcpd.conf</code></pre>
<p>dhcp的服务程序的配置文件中只有3行注释语句，这意味着我们需要自行编写这个文件。如果读者不知道怎么编写，可以看一下配置文件中第2行的参考示例文件，其组成架构如图：</p>
<img src="/2021/02/15/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-14%EF%BC%9A%E4%BD%BF%E7%94%A8DHCP%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80/1.png" class>

<p>一个标准的配置文件应该包括全局配置参数、子网网段声明、地址配置选项以及地址配置参数。其中，全局配置参数用于定义dhcpd服务程序的整体运行参数；子网网段声明用于配置整个子网段的地址属性。</p>
<p>dhcpd服务程序配置文件中使用的常见参数以及作用:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ddns-update-style 类型</td>
<td>定义DNS服务动态更新的类型，类型包括：none（不支持动态更新）、interim（互动更新模式）与ad-hoc（特殊更新模式）</td>
</tr>
<tr>
<td>allow/ignore client-updates</td>
<td>允许/忽略客户端更新DNS记录</td>
</tr>
<tr>
<td>default-lease-time 21600</td>
<td>默认超时时间</td>
</tr>
<tr>
<td>max-lease-time 43200</td>
<td>最大超时时间</td>
</tr>
<tr>
<td>option domain-name-servers 8.8.8.8</td>
<td>定义DNS服务器地址</td>
</tr>
<tr>
<td>option domain-name “domain.org”</td>
<td>定义DNS域名</td>
</tr>
<tr>
<td>range</td>
<td>定义用于分配的IP地址池</td>
</tr>
<tr>
<td>option subnet-mask</td>
<td>定义客户端的子网掩码</td>
</tr>
<tr>
<td>option routers</td>
<td>定义客户端的网关地址</td>
</tr>
<tr>
<td>broadcast-address 广播地址</td>
<td>定义客户端的广播地址</td>
</tr>
<tr>
<td>ntp-server IP地址</td>
<td>定义客户端的网络时间服务器（NTP）</td>
</tr>
<tr>
<td>nis-servers IP地址</td>
<td>定义客户端的NIS域服务器的地址</td>
</tr>
<tr>
<td>hardware 硬件类型 MAC地址</td>
<td>指定网卡接口的类型与MAC地址</td>
</tr>
<tr>
<td>server-name 主机名</td>
<td>向DHCP客户端通知DHCP服务器的主机名</td>
</tr>
<tr>
<td>fixed-address IP地址</td>
<td>将某个固定的IP地址分配给指定主机</td>
</tr>
<tr>
<td>time-offset 偏移差</td>
<td>指定客户端与格林尼治时间的偏移差</td>
</tr>
</tbody></table>
<h1 id="3-自动管理IP地址"><a href="#3-自动管理IP地址" class="headerlink" title="3.自动管理IP地址"></a>3.自动管理IP地址</h1><p>DHCP协议的设计初衷是为了更高效地集中管理局域网内的IP地址资源。DHCP服务器会自动把IP地址、子网掩码、网关、DNS地址等网络信息分配给有需要的客户端，而且当客户端的租约时间到期后还可以自动回收所分配的IP地址，以便交给新加入的客户端。</p>
<p>DHCP服务器以及客户端的配置信息：</p>
<table>
<thead>
<tr>
<th>主机类型</th>
<th>操作系统</th>
<th>IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>DHCP服务器</td>
<td>RHEL 7</td>
<td>192.168.10.1</td>
</tr>
<tr>
<td>DHCP客户机</td>
<td>RHEL 7</td>
<td>DHCP自动获取地址</td>
</tr>
</tbody></table>
<p>作用域一般是个完整的IP地址段，而地址池中的IP地址才是真正供客户端使用的，因此地址池应该小于或等于作用域的IP地址范围。另外，由于VMware Workstation虚拟机软件自带DHCP服务，为了避免与自己配置的dhcpd服务程序产生冲突，应该将虚拟机软件（包括服务器和客户端）自带的DHCP功能关闭。</p>
<img src="/2021/02/15/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-14%EF%BC%9A%E4%BD%BF%E7%94%A8DHCP%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80/2.png" class>

<img src="/2021/02/15/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-14%EF%BC%9A%E4%BD%BF%E7%94%A8DHCP%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80/3.jpg" class>

<p>此外还要注意，DHCP客户端与服务器需要处于同一种网络模式—仅主机模式（Hostonly），否则就会产生物理隔离，从而无法获取IP地址。</p>
<p>在确认DHCP服务器的IP地址等网络信息配置妥当后就可以配置dhcpd服务程序了。请注意，在配置dhcpd服务程序时，配置文件中的每行参数后面都需要以分号（;）结尾，这是规定。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/dhcp/dhcpd.conf
ddns-update-style none;
ignore client-updates;
subnet 192.168.10.0 netmask 255.255.255.0 &#123;
range 192.168.10.50 192.168.10.150;
option subnet-mask 255.255.255.0;
option routers 192.168.10.1;
option domain-name &quot;linuxprobe.com&quot;;
option domain-name-servers 192.168.10.1;
default-lease-time 21600;
max-lease-time 43200;
&#125;</code></pre>
<p>dhcpd服务程序配置文件中使用的参数以及作用：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ddns-update-style none;</td>
<td>设置DNS服务不自动进行动态更新</td>
</tr>
<tr>
<td>ignore client-updates;</td>
<td>忽略客户端更新DNS记录</td>
</tr>
<tr>
<td>subnet 192.168.10.0 netmask 255.255.255.0 {</td>
<td>作用域为192.168.10.0/24网段</td>
</tr>
<tr>
<td>range 192.168.10.50 192.168.10.150;</td>
<td>IP地址池为192.168.10.50-150（约100个IP地址）</td>
</tr>
<tr>
<td>option subnet-mask 255.255.255.0;</td>
<td>定义客户端默认的子网掩码</td>
</tr>
<tr>
<td>option routers 192.168.10.1;</td>
<td>定义客户端的网关地址</td>
</tr>
<tr>
<td>option domain-name “linuxprobe.com”;</td>
<td>定义默认的搜索域</td>
</tr>
<tr>
<td>option domain-name-servers 192.168.10.1;</td>
<td>定义客户端的DNS地址</td>
</tr>
<tr>
<td>default-lease-time 21600;</td>
<td>定义默认租约时间（单位：秒）</td>
</tr>
<tr>
<td>max-lease-time 43200;</td>
<td>定义最大预约时间（单位：秒）</td>
</tr>
<tr>
<td>}</td>
<td>结束符</td>
</tr>
</tbody></table>
<p>把配置过的dhcpd服务加入到开机启动项中，以确保当服务器下次开机后dhcpd服务依然能自动启动，并顺利地为客户端分配IP地址等信息：</p>
<pre><code>[root@linuxprobe ~]# systemctl start dhcpd
[root@linuxprobe ~]# systemctl enable dhcpd
 ln -s &#39;/usr/lib/systemd/system/dhcpd.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/dhcpd.service&#39;</code></pre>
<p>把dhcpd服务程序配置妥当之后就可以开启客户端来检验IP分配效果了。重启客户端的网卡服务后即可看到自动分配到的IP地址：</p>
<img src="/2021/02/15/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-14%EF%BC%9A%E4%BD%BF%E7%94%A8DHCP%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80/4.jpg" class>

<h1 id="4-分配固定IP地址"><a href="#4-分配固定IP地址" class="headerlink" title="4.分配固定IP地址"></a>4.分配固定IP地址</h1><p>在DHCP协议中有个术语是“预约”，它用来确保局域网中特定的设备总是获取到固定的IP地址。换句话说，就是dhcpd服务程序会把某个IP地址私藏下来，只将其用于相匹配的特定设备。</p>
<p>要想把某个IP地址与某台主机进行绑定，就需要用到这台主机的MAC地址。</p>
<img src="/2021/02/15/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-14%EF%BC%9A%E4%BD%BF%E7%94%A8DHCP%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80/5.jpg" class>

<p>也可以启动dhcpd服务程序，为主机分配一个IP地址，这样就会在DHCP服务器本地的日志文件中保存这次的IP地址分配记录，然后通过查看日志文件，获悉主机的MAC地址：</p>
<pre><code>[root@linuxprobe ~]# tail -f /var/log/messages 
Mar 30 05:33:17 localhost dhcpd: Copyright 2004-2013 Internet Systems Consortium.
Mar 30 05:33:17 localhost dhcpd: All rights reserved.
Mar 30 05:33:17 localhost dhcpd: For info, please visit https://www.isc.org/software/dhcp/
Mar 30 05:33:17 localhost dhcpd: Not searching LDAP since ldap-server, ldap-port and ldap-base-dn were not specified in the config file
Mar 30 05:33:17 localhost dhcpd: Wrote 0 leases to leases file.
Mar 30 05:33:17 localhost dhcpd: Listening on LPF/eno16777728/00:0c:29:c4:a4:09/192.168.10.0/24
Mar 30 05:33:17 localhost dhcpd: Sending on LPF/eno16777728/00:0c:29:c4:a4:09/192.168.10.0/24
Mar 30 05:33:17 localhost dhcpd: Sending on Socket/fallback/fallback-net
Mar 30 05:33:26 localhost dhcpd: DHCPDISCOVER from **00:0c:29:27:c6:12** via eno16777728</code></pre>
<p>在dhcpd服务程序的配置文件中，按照如下格式将IP地址与MAC地址进行绑定（MAC地址的间隔符为冒号（:））：</p>
<img src="/2021/02/15/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-14%EF%BC%9A%E4%BD%BF%E7%94%A8DHCP%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80/6.png" class>

<p>确认参数填写正确后就可以保存退出配置文件，然后就可以重启dhcpd服务程序了：</p>
<pre><code>[root@linuxprobe ~]# systemctl restart dhcpd</code></pre>
<p>需要说明的是，如果刚刚为这台主机分配了IP地址，则它的IP地址租约时间还没有到期，因此不会立即换成新绑定的IP地址。要想立即查看绑定效果，则需要重启一下客户端的网络服务：</p>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第14章节：使用DHCP动态管理主机地址</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学-15:使用Postfix与Dovecot部署邮件系统</title>
    <url>/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="1-电子邮件系统"><a href="#1-电子邮件系统" class="headerlink" title="1.电子邮件系统"></a>1.电子邮件系统</h1><p>电子邮件系统基于邮件协议来完成电子邮件的传输，常见的邮件协议有下面这些：</p>
<a id="more"></a>

<pre><code>简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）：用于发送和中转发出的电子邮件，占用服务器的25/TCP端口。

邮局协议版本3（Post Office Protocol 3）：用于将电子邮件存储到本地主机，占用服务器的110/TCP端口。

Internet消息访问协议版本4（Internet Message Access Protocol 4）：用于在本地主机上访问邮件，占用服务器的143/TCP端口。</code></pre>
<p>MUA：Mail User Agent，邮件用户代理；    MDA：Mail Delivery Agent，邮件投递代理；    </p>
<p>MTA：Mail Transfer Agent，邮件传输代理。</p>
<img src="/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/1.png" class>

<p>在生产环境中部署企业级的电子邮件系统时，有4个注意事项请留意。</p>
<pre><code>1.添加反垃圾与反病毒模块：它能够很有效地阻止垃圾邮件或病毒邮件对企业信箱的干扰。
2.对邮件加密：可有效保护邮件内容不被黑客盗取和篡改。
3.添加邮件监控审核模块：可有效地监控企业全体员工的邮件中是否有敏感词、是否有透露企业资料等违规行为。
4.保障稳定性：电子邮件系统的稳定性至关重要，运维人员应做到保证电子邮件系统的稳定运行，并及时做好防范分布式拒绝服务（Distributed Denial of Service，DDoS）攻击的准备。</code></pre>
<h1 id="2-部署基础的电子邮件系统"><a href="#2-部署基础的电子邮件系统" class="headerlink" title="2.部署基础的电子邮件系统"></a>2.部署基础的电子邮件系统</h1><p>一个最基础的电子邮件系统肯定要能提供发件服务和收件服务，为此需要使用基于SMTP协议的Postfix服务程序提供发件服务功能，并使用基于POP3协议的Dovecot服务程序提供收件服务功能。</p>
<p>要想更好地检验电子邮件系统的配置效果，需要先部署bind服务程序，为电子邮件服务器和客户端提供DNS域名解析服务。</p>
<p>第1步：部署bind服务程序。</p>
<pre><code>[root@linuxprobe ~]# yum install bind-chroot</code></pre>
<p>第2步：配置服务器主机名称，需要保证服务器主机名称与发信域名保持一致：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/hostname
mail.linuxprobe.com
[root@linuxprobe ~]# hostname
mail.linuxprobe.com
[root@linuxprobe ~]# vim /etc/hosts
192.168.10.10 mail.linuxprobe.com</code></pre>
<p>第3步：清空iptables防火墙默认策略，并保存策略状态，避免因防火墙中默认存在的策略阻止了客户端DNS解析域名及收发邮件：</p>
<pre><code>[root@localhost ~]# iptables -F
[root@localhost ~]# service iptables save
iptables: Saving firewall rules to /etc/sysconfig/iptables:[  OK  ]</code></pre>
<p>第4步：为电子邮件系统提供域名解析。</p>
<pre><code>[root@linuxprobe ~]# cat /etc/named.conf
 10 options &#123;
 11 listen-on port 53 &#123; any; &#125;;
 12 listen-on-v6 port 53 &#123; ::1; &#125;;
 13 directory &quot;/var/named&quot;;
 14 dump-file &quot;/var/named/data/cache_dump.db&quot;;
 15 statistics-file &quot;/var/named/data/named_stats.txt&quot;;
 16 memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;
 17 allow-query &#123; any; &#125;;
 18 
 ………………省略部分输出信息………………

[root@linuxprobe ~]# cat /etc/named.rfc1912.zones
zone &quot;linuxprobe.com&quot; IN &#123;
type master;
file &quot;linuxprobe.com.zone&quot;;
allow-update &#123;none;&#125;;
&#125;;

[root@linuxprobe ~]# cat /var/named/linuxprobe.com.zone</code></pre>
<img src="/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/2.png" class>

<pre><code>[root@linuxprobe ~]# systemctl restart named
[root@linuxprobe ~]# systemctl enable named
ln -s &#39;/usr/lib/systemd/system/named.service&#39; 
&#39;/etc/systemd/system/multi-user.target.wants/named.service&#39;</code></pre>
<p>测试时重启named服务时，显示报错：Job for named.service failed because the control process exited with error code. See “systemctl status named.service” and “journalctl -xe” for details.用named-checkconf -z /etc/named.conf（纠错命令）查看发现是由于配置文件内容写错导致！</p>
<p>这样电子邮件系统所对应的服务器主机名即为mail.linuxprobe.com，而邮件域为@linuxprobe.com。把服务器的DNS地址修改成本地IP地址：</p>
<img src="/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/3.jpg" class>

<p>修改完IP地址后，需要重启网卡，之后可用ping mail.linuxprobe.com或nslookup命令测试下配置是否成功：</p>
<img src="/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/4.png" class>

<p>用nslookup命令测试时，出现以下报错：server can’t find mail.linuxprobe.com:NXDOMAIN，并提示当前的server 192.168.10.2 不能使用；此时可编辑/etc/resolv.conf文件，将报错的nameserver 192.168.10.2删除，保留nameserver 192.168.10.10即可！之后再重启网卡，测试一下！</p>
<h2 id="2-1配置Postfix服务程序"><a href="#2-1配置Postfix服务程序" class="headerlink" title="2.1配置Postfix服务程序"></a>2.1配置Postfix服务程序</h2><p>第1步：安装Postfix服务程序；在安装完Postfix服务程序后，需要禁用iptables防火墙，否则外部用户无法访问电子邮件系统。</p>
<pre><code>[root@linuxprobe ~]# yum install postfix
Loaded plugins: langpacks, product-id, subscription-manager
rhel7 | 4.1 kB 00:00
(1/2): rhel7/group_gz | 134 kB 00:00
(2/2): rhel7/primary_db | 3.4 MB 00:00
Package 2:postfix-2.10.1-6.el7.x86_64 already installed and latest version
Nothing to do
[root@linuxprobe ~]# systemctl disable iptables</code></pre>
<p>第2步：配置Postfix服务程序，Postfix服务程序主配置文件（/etc/ postfix/main.cf）。</p>
<p>Postfix服务程序主配置文件中的重要参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>myhostname</td>
<td>邮局系统的主机名</td>
</tr>
<tr>
<td>mydomain</td>
<td>邮局系统的域名</td>
</tr>
<tr>
<td>myorigin</td>
<td>从本机发出邮件的域名名称</td>
</tr>
<tr>
<td>inet_interfaces</td>
<td>监听的网卡接口</td>
</tr>
<tr>
<td>mydestination</td>
<td>可接收邮件的主机名或域名</td>
</tr>
<tr>
<td>mynetworks</td>
<td>设置可转发哪些主机的邮件</td>
</tr>
<tr>
<td>relay_domains</td>
<td>设置可转发哪些网域的邮件</td>
</tr>
</tbody></table>
<p>在Postfix服务程序的主配置文件中，总计需要修改5处。首先是在第76行定义一个名为myhostname的变量，用来保存服务器的主机名称。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/postfix/main.cf
………………省略部分输出信息………………
68 # INTERNET HOST AND DOMAIN NAMES
69 # 
70 # The myhostname parameter specifies the internet hostname of this
71 # mail system. The default is to use the fully-qualified domain name
72 # from gethostname(). $myhostname is used as a default value for many
73 # other configuration parameters.
74 #
75 #myhostname = host.domain.tld
76 myhostname = mail.linuxprobe.com
………………省略部分输出信息………………</code></pre>
<p>然后在第83行定义一个名为mydomain的变量，用来保存邮件域的名称。大家也要记住这个变量名称，下面将调用它：</p>
<pre><code>78 # The mydomain parameter specifies the local internet domain name.
79 # The default is to use $myhostname minus the first component.
80 # $mydomain is used as a default value for many other configuration
81 # parameters.
82 #
83 mydomain = linuxprobe.com</code></pre>
<p>在第99行调用前面的mydomain变量，用来定义发出邮件的域。调用变量的好处是避免重复写入信息，以及便于日后统一修改：</p>
<pre><code>94 # For the sake of consistency between sender and recipient addresses,
95 # myorigin also specifies the default domain name that is appended
96 # to recipient addresses that have no @domain part.
97 #
98 #myorigin = $myhostname
99 myorigin = $mydomain</code></pre>
<p>第4处修改是在第116行定义网卡监听地址。可以指定要使用服务器的哪些IP地址对外提供电子邮件服务；也可以干脆写成all，代表所有IP地址都能提供电子邮件服务：</p>
<pre><code>111 # Note: you need to stop/start Postfix when this parameter changes.
112 #
113 #inet_interfaces = all
114 #inet_interfaces = $myhostname
115 #inet_interfaces = $myhostname, localhost
116 inet_interfaces = all</code></pre>
<p>最后一处修改是在第164行定义可接收邮件的主机名或域名列表。这里可以直接调用前面定义好的myhostname和mydomain变量（如果不想调用变量，也可以直接调用变量中的值）：</p>
<pre><code>162 # See also below, section &quot;REJECTING MAIL FOR UNKNOWN LOCAL USERS&quot;.
163 #
164 mydestination = $myhostname , $mydomain
165 #mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain
166 #mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain,</code></pre>
<p>第3步：创建电子邮件系统的登录账户。Postfix与vsftpd服务程序一样，都可以调用本地系统的账户和密码，因此在本地系统创建常规账户即可。最后重启配置妥当的postfix服务程序，并将其添加到开机启动项中。大功告成！</p>
<pre><code>[root@linuxprobe ~]# useradd boss
[root@linuxprobe ~]# echo &quot;linuxprobe&quot; | passwd --stdin boss
Changing password for user boss. passwd: all authentication tokens updated successfully.
[root@linuxprobe ~]# systemctl restart postfix
[root@linuxprobe ~]# systemctl enable postfix
ln -s &#39;/usr/lib/systemd/system/postfix.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/postfix.service&#39;</code></pre>
<h2 id="2-2配置Dovecot服务程序"><a href="#2-2配置Dovecot服务程序" class="headerlink" title="2.2配置Dovecot服务程序"></a>2.2配置Dovecot服务程序</h2><p>第1步：安装Dovecot服务程序软件包。大家可自行配置Yum软件仓库、挂载光盘镜像到指定目录，然后输入要安装的dovecot软件包名称即可：</p>
<pre><code>[root@linuxprobe ~]# yum install dovecot</code></pre>
<p>第2步：配置部署Dovecot服务程序。在Dovecot服务程序的主配置文件中进行如下修改。首先是第24行，把Dovecot服务程序支持的电子邮件协议修改为imap、pop3和lmtp。然后在这一行下面添加一行参数，允许用户使用明文进行密码验证。之所以这样操作，是因为Dovecot服务程序为了保证电子邮件系统的安全而默认强制用户使用加密方式进行登录，而由于当前还没有加密系统，因此需要添加该参数来允许用户的明文登录。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/dovecot/dovecot.conf
………………省略部分输出信息………………
23 # Protocols we want to be serving.
24 protocols = imap pop3 lmtp
25 disable_plaintext_auth = no
………………省略部分输出信息………………</code></pre>
<p>在主配置文件中的第48行，设置允许登录的网段地址，也就是说我们可以在这里限制只有来自于某个网段的用户才能使用电子邮件系统。如果想允许所有人都能使用，则不用修改本参数：</p>
<pre><code>44 # Space separated list of trusted network ranges. Connections from these
45 # IPs are allowed to override their IP addresses and ports (for logging and
46 # for authentication checks). disable_plaintext_auth is also ignored for
47 # these networks. Typically you&#39;d specify your IMAP proxy servers here.
48 login_trusted_networks = 192.168.10.0/24</code></pre>
<p>第3步：配置邮件格式与存储路径。在Dovecot服务程序单独的子配置文件中，定义一个路径，用于指定要将收到的邮件存放到服务器本地的哪个位置。这个路径默认已经定义好了，我们只需要将该配置文件中第24行前面的井号（#）删除即可。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/dovecot/conf.d/10-mail.conf
21 # See doc/wiki/Variables.txt for full list. Some examples:
22 #
23 # mail_location = maildir:~/Maildir
24 mail_location = mbox:~/mail:INBOX=/var/mail/%u
25 # mail_location = mbox:/var/mail/%d/%1n/%n:INDEX=/var/indexes/%d/%1n/%n
………………省略部分输出信息………………</code></pre>
<p>然后切换到配置Postfix服务程序时创建的boss账户，并在家目录中建立用于保存邮件的目录。记得要重启Dovecot服务并将其添加到开机启动项中。</p>
<pre><code>[root@linuxprobe ~]# su - linuxprobe
Last login: Sat Aug 15 16:15:58 CST 2017 on pts/1
[linuxprobe@mail ~]$ mkdir -p mail/.imap/INBOX
[linuxprobe@mail ~]$ exit
[root@linuxprobe ~]# systemctl restart dovecot 
[root@linuxprobe ~]# systemctl enable dovecot 
ln -s &#39;/usr/lib/systemd/system/dovecot.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/dovecot.service&#39;</code></pre>
<h2 id="2-3使用电子邮件系统"><a href="#2-3使用电子邮件系统" class="headerlink" title="2.3使用电子邮件系统"></a>2.3使用电子邮件系统</h2><p> 服务器与客户端的操作系统与IP地址：</p>
<table>
<thead>
<tr>
<th>主机名称</th>
<th>操作系统</th>
<th>IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>电子邮件系统及DNS服务器</td>
<td>RHEL 7</td>
<td>192.168.10.10</td>
</tr>
<tr>
<td>客户端主机</td>
<td>Windows 10</td>
<td>192.168.10.30</td>
</tr>
</tbody></table>
<img src="/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/5.png" class>

<p>第1步：在win10系统中安装foxmail软件；安装后在软件账号管理-账号处新建账号，输入E-mail地址（如<a href="mailto:&#x6c;&#105;&#110;&#117;&#x78;&#112;&#114;&#111;&#x62;&#101;&#x40;&#108;&#x69;&#x6e;&#117;&#x78;&#112;&#114;&#111;&#98;&#x65;&#x2e;&#x63;&#111;&#109;">&#x6c;&#105;&#110;&#117;&#x78;&#112;&#114;&#111;&#x62;&#101;&#x40;&#108;&#x69;&#x6e;&#117;&#x78;&#112;&#114;&#111;&#98;&#x65;&#x2e;&#x63;&#111;&#109;</a>,linuxprobe是linux用户名）和用户密码：</p>
<img src="/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/6.png" class>

<p>第2步：设置接收服务器类型为POP3，输入邮件帐号和密码，设置POP服务器和SMTP服务器地址，两个为同一地址，如192.168.10.10，SSL端口处不勾选，之后创建成功！</p>
<img src="/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/7.png" class>

<p>第3步：账号建立后，即可从win 10系统向linux发送邮件：</p>
<img src="/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/8.png" class>

<p>第4步：发送邮件后，可在linux系统内部输入mail命令，并输入对应邮件数值编号查看邮件：</p>
<img src="/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/9.png" class>

<p>第5步：从linux系统向win10电脑发送邮件，只需输入mail 邮件地址，然后输入subject和正文；最后输入点（.)结束：</p>
<img src="/2021/02/16/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-15-%E4%BD%BF%E7%94%A8Postfix%E4%B8%8EDovecot%E9%83%A8%E7%BD%B2%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/10.png" class>

<h1 id="3-设置用户别名邮箱"><a href="#3-设置用户别名邮箱" class="headerlink" title="3.设置用户别名邮箱"></a>3.设置用户别名邮箱</h1><p>用户别名功能是一项简单实用的邮件账户伪装技术，可以用来设置多个虚拟信箱的账户以接受发送的邮件，从而保证自身的邮件地址不被泄露，还可以用来接收自己的多个信箱中的邮件。</p>
<pre><code>[root@linuxprobe ~]# cat /etc/aliases
#
# Aliases in this file will NOT be expanded in the header from
# Mail, but WILL be visible over networks or from /bin/mail.
#
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The program &quot;newaliases&quot; must be run after
# &gt;&gt; NOTE &gt;&gt; this file is updated for any changes to
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; show through to sendmail.
#
# Basic system aliases -- these MUST be present.
mailer-daemon: postmaster
postmaster: root
# General redirections for pseudo accounts.
bin: root
daemon: root
adm: root
lp: root
sync: root
shutdown: root
halt: root
mail: root
news: root
……</code></pre>
<p>保存并退出aliases邮件别名服务的配置文件后，需要再执行一下newaliases命令，其目的是让新的用户别名配置文件立即生效。</p>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第15章节：使用Postfix与Dovecot部署邮件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学-19:使用PXE+Kickstart无人值守安装服务</title>
    <url>/2021/02/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-19-%E4%BD%BF%E7%94%A8PXE-Kickstart%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="1-无人值守系统"><a href="#1-无人值守系统" class="headerlink" title="1.无人值守系统"></a>1.无人值守系统</h1><p>无人值守安装系统的工作流程：</p>
<a id="more"></a>

<img src="/2021/02/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-19-%E4%BD%BF%E7%94%A8PXE-Kickstart%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1/1.png" class>

<p>PXE（Preboot eXecute Environment，预启动执行环境）是由Intel公司开发的技术，可以让计算机通过网络来启动操作系统（前提是计算机上安装的网卡支持PXE技术），主要用于在无人值守安装系统中引导客户端主机安装Linux操作系统。</p>
<p>Kickstart是一种无人值守的安装方式，其工作原理是预先把原本需要运维人员手工填写的参数保存成一个ks.cfg文件，当安装过程中需要填写参数时则自动匹配Kickstart生成的文件。所以只要Kickstart文件包含了安装过程中需要人工填写的所有参数，那么从理论上来讲完全不需要运维人员的干预，就可以自动完成安装工作。</p>
<p>由于当前的客户端主机并没有完整的操作系统，也就不能完成FTP协议的验证了，所以需要使用TFTP协议帮助客户端获取引导及驱动文件。vsftpd服务程序用于将完整的系统安装镜像通过网络传输给客户端。当然，只要能将系统安装镜像成功传输给客户端即可，因此也可以使用httpd来替代vsftpd服务程序。</p>
<h1 id="2-部署相关服务程序"><a href="#2-部署相关服务程序" class="headerlink" title="2.部署相关服务程序"></a>2.部署相关服务程序</h1><h2 id="2-1配置DHCP服务程序"><a href="#2-1配置DHCP服务程序" class="headerlink" title="2.1配置DHCP服务程序"></a>2.1配置DHCP服务程序</h2><p>DHCP服务程序用于为客户端主机分配可用的IP地址，而且这是服务器与客户端主机进行文件传输的基础，因此我们先行配置DHCP服务程序。</p>
<p>无人值守系统与客户端的设置：</p>
<table>
<thead>
<tr>
<th>主机名称</th>
<th>操作系统</th>
<th>IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>无人值守系统</td>
<td>RHEL 7</td>
<td>192.168.10.10</td>
</tr>
<tr>
<td>客户端</td>
<td>未安装操作系统</td>
<td>-</td>
</tr>
</tbody></table>
<img src="/2021/02/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-19-%E4%BD%BF%E7%94%A8PXE-Kickstart%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1/2.png" class>

<img src="/2021/02/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-19-%E4%BD%BF%E7%94%A8PXE-Kickstart%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1/3.jpg" class>

<pre><code>[root@linuxprobe ~]# yum install dhcp
Loaded plugins: langpacks, product-id, subscription-manager
This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.
rhel | 4.1 kB 00:00 
……
Installed:
 dhcp.x86_64 12:4.2.5-27.el7 
Complete!</code></pre>
<p>在这里使用的配置文件与之前的配置文件有两个主要区别：允许了BOOTP引导程序协议，旨在让局域网内暂时没有操作系统的主机也能获取静态IP地址；在配置文件的最下面加载了引导驱动文件pxelinux.0（这个文件会在下面的步骤中创建），其目的是让客户端主机获取到IP地址后主动获取引导驱动文件，自行进入下一步的安装过程。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/dhcp/dhcpd.conf
allow booting;
allow bootp;
ddns-update-style interim;
ignore client-updates;
subnet 192.168.10.0 netmask 255.255.255.0 &#123;
        option subnet-mask      255.255.255.0;
        option domain-name-servers  192.168.10.10;
        range dynamic-bootp 192.168.10.100 192.168.10.200;
        default-lease-time      21600;
        max-lease-time          43200;
        next-server             192.168.10.10;
        filename                &quot;pxelinux.0&quot;;
&#125;</code></pre>
<p>在确认DHCP服务程序的参数都填写正确后，重新启动该服务程序，并将其添加到开机启动项中。这样在设备下一次重启之后，在无须人工干预的情况下，自动为客户端主机安装系统。</p>
<pre><code>[root@linuxprobe ~]# systemctl restart dhcpd
[root@linuxprobe ~]# systemctl enable dhcpd
ln -s &#39;/usr/lib/systemd/system/dhcpd.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/dhcpd.service&#39;</code></pre>
<h2 id="2-2-配置TFTP服务程序"><a href="#2-2-配置TFTP服务程序" class="headerlink" title="2.2 配置TFTP服务程序"></a>2.2 配置TFTP服务程序</h2><p>vsftpd是一款功能丰富的文件传输服务程序，允许用户以匿名开放模式、本地用户模式、虚拟用户模式来进行访问认证。但是，当前的客户端主机还没有安装操作系统，该如何进行登录认证呢？而TFTP作为一种基于UDP协议的简单文件传输协议，不需要进行用户认证即可获取到所需的文件资源。因此接下来配置TFTP服务程序，为客户端主机提供引导及驱动文件。当客户端主机有了基本的驱动程序之后，再通过vsftpd服务程序将完整的光盘镜像文件传输过去。</p>
<pre><code>[root@linuxprobe ~]# yum install tftp-server</code></pre>
<p>TFTP是一种非常精简的文件传输服务程序，它的运行和关闭是由xinetd网络守护进程服务来管理的。xinetd服务程序会同时监听系统的多个端口，然后根据用户请求的端口号调取相应的服务程序来响应用户的请求。需要开启TFTP服务程序，只需在xinetd服务程序的配置文件中把disable参数改成no就可以了。保存配置文件并退出，然后重启xinetd服务程序，并将其加入到开机启动项中。</p>
<pre><code>[root@linuxprobe ~]# yum install xinetd
[root@linuxprobe ~.d]# vim /etc/xinetd.d/tftp
service tftp
&#123;
        socket_type             = dgram
        protocol                = udp
        wait                    = yes
        user                    = root
        server                  = /usr/sbin/in.tftpd
        server_args             = -s /var/lib/tftpboot
        disable                 = no
        per_source              = 11
        cps                     = 100 2
        flags                   = IPv4
[root@linuxprobe xinetd.d]# systemctl restart xinetd
[root@linuxprobe xinetd.d]# systemctl enable xinetd</code></pre>
<p>TFTP服务程序默认使用的是UDP协议，占用的端口号为69，所以在生产环境中还需要在firewalld防火墙管理工具中写入使其永久生效的允许策略，以便让客户端主机顺利获取到引导文件。</p>
<pre><code>[root@linuxprobe ~]# firewall-cmd --permanent --add-port=69/udp
success
[root@linuxprobe ~]# firewall-cmd --reload 
success</code></pre>
<h2 id="2-3-配置SYSLinux服务程序"><a href="#2-3-配置SYSLinux服务程序" class="headerlink" title="2.3 配置SYSLinux服务程序"></a>2.3 配置SYSLinux服务程序</h2><p>SYSLinux是一个用于提供引导加载的服务程序。与其说SYSLinux是一个服务程序，不如说更需要里面的引导文件，在安装好SYSLinux服务程序软件包后，/usr/share/syslinux目录中会出现很多引导文件。</p>
<pre><code>[root@linuxprobe ~]# yum install syslinux</code></pre>
<p>我们首先需要把SYSLinux提供的引导文件复制到TFTP服务程序的默认目录中，也就是前文提到的文件pxelinux.0，这样客户端主机就能够顺利地获取到引导文件了。另外在RHEL 7系统光盘镜像中也有一些我们需要调取的引导文件。确认光盘镜像已经被挂载到/media/cdrom目录后，使用复制命令将光盘镜像中自带的一些引导文件也复制到TFTP服务程序的默认目录中。</p>
<pre><code>[root@linuxprobe ~]# cd /var/lib/tftpboot
[root@linuxprobe tftpboot]# cp /usr/share/syslinux/pxelinux.0 .
[root@linuxprobe tftpboot]# cp /media/cdrom/images/pxeboot/&#123;vmlinuz,initrd.img&#125; .
[root@linuxprobe tftpboot]# cp /media/cdrom/isolinux/&#123;vesamenu.c32,boot.msg&#125; .</code></pre>
<p>然后在TFTP服务程序的目录中新建pxelinux.cfg目录，虽然该目录的名字带有后缀，但依然也是目录，而非文件！将系统光盘中的开机选项菜单复制到该目录中，并命名为default。</p>
<pre><code>[root@linuxprobe tftpboot]# mkdir pxelinux.cfg
[root@linuxprobe tftpboot]# cp /media/cdrom/isolinux/isolinux.cfg pxelinux.cfg/default</code></pre>
<p>默认的开机菜单中有两个选项，要么是安装系统，要么是对安装介质进行检验。既然我们已经确定采用无人值守的方式安装系统，还需要为每台主机手动选择相应的选项，未免与我们的主旨（无人值守安装）相悖。现在我们编辑这个default文件，把第1行的default参数修改为linux，这样系统在开机时就会默认执行那个名称为linux的选项了。对应的linux选项大约在64行，我们将默认的光盘镜像安装方式修改成FTP文件传输方式，并指定好光盘镜像的获取网址以及Kickstart应答文件的获取路径：</p>
<pre><code>[root@linuxprobe tftpboot]# vim pxelinux.cfg/default
 1 default linux
 2 timeout 600
 3
 4 display boot.msg
 5
 61 label linux
 62 menu label ^Install Red Hat Enterprise Linux 7.0
 63 kernel vmlinuz
 64 append initrd=initrd.img inst.stage2=ftp://192.168.10.10 ks=ftp://192.168.10.10/pub/ks.cfg quiet
 65
………………省略部分输出信息………………</code></pre>
<h2 id="2-4-配置VSftpd服务程序"><a href="#2-4-配置VSftpd服务程序" class="headerlink" title="2.4 配置VSftpd服务程序"></a>2.4 配置VSftpd服务程序</h2><p>在我们这套无人值守安装系统的服务中，光盘镜像是通过FTP协议传输的，因此势必要用到vsftpd服务程序。当然，也可以使用httpd服务程序来提供Web网站访问的方式，只要能确保将光盘镜像顺利传输给客户端主机即可。如果打算使用Web网站服务来提供光盘镜像，一定记得将上面配置文件中的光盘镜像获取网址和Kickstart应答文件获取网址修改一下。</p>
<pre><code>[root@linuxprobe ~]# yum install vsftpd</code></pre>
<p>在配置文件修改正确之后，一定将相应的服务程序添加到开机启动项中，这样无论是在生产环境中还是在红帽认证考试中，都可以在设备重启之后依然能提供相应的服务。</p>
<pre><code>[root@linuxprobe ~]# systemctl restart vsftpd
[root@linuxprobe ~]# systemctl enable vsftpd
ln -s &#39;/usr/lib/systemd/system/vsftpd.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/vsftpd.service&#39;</code></pre>
<p>在确认系统光盘镜像已经正常挂载到/media/cdrom目录后，把目录中的光盘镜像文件全部复制到vsftpd服务程序的工作目录中。</p>
<pre><code>[root@linuxprobe ~]# cp -r /media/cdrom/* /var/ftp</code></pre>
<p>这个过程大约需要3～5分钟。在此期间，我们也别闲着，在firewalld防火墙管理工具中写入使FTP协议永久生效的允许策略，然后在SELinux中放行FTP传输：</p>
<pre><code>[root@linuxprobe ~]# firewall-cmd --permanent --add-service=ftp
success
[root@linuxprobe ~]# firewall-cmd --reload 
success
[root@linuxprobe ~]# setsebool -P ftpd_connect_all_unreserved=on</code></pre>
<h2 id="2-5-创建KickStart应答文件"><a href="#2-5-创建KickStart应答文件" class="headerlink" title="2.5 创建KickStart应答文件"></a>2.5 创建KickStart应答文件</h2><p>Kickstart应答文件中包含了系统安装过程中需要使用的选项和参数信息，系统可以自动调取这个应答文件的内容，从而彻底实现了无人值守安装系统。那么，既然这个文件如此重要，该去哪里找呢？其实在root管理员的家目录中有一个名为anaconda-ks.cfg的文件，它就是应答文件。下面将这个文件复制到vsftpd服务程序的工作目录中（在开机选项菜单的配置文件中已经定义了该文件的获取路径，也就是vsftpd服务程序数据目录中的pub子目录中）。使用chmod命令设置该文件的权限，确保所有人都有可读的权限，以保证客户端主机可以顺利获取到应答文件及里面的内容：</p>
<pre><code>[root@linuxprobe ~]# cp ~/anaconda-ks.cfg /var/ftp/pub/ks.cfg
[root@linuxprobe ~]# chmod +r /var/ftp/pub/ks.cfg</code></pre>
<p>Kickstart应答文件并没有想象中的那么复杂，它总共只有46行左右的参数和注释内容，大家完全可以通过参数的名称及介绍来快速了解每个参数的作用。首先把第6行的光盘镜像安装方式修改成FTP协议，仔细填写好FTP服务器的IP地址，并用本地浏览器尝试打开下检查有没有报错。然后把第21行的时区修改成上海(Asia/Shanghai)，最后再把29行的磁盘选项设置为清空所有磁盘内容并初始化磁盘：</p>
<pre><code>[root@linuxprobe ~]# vim /var/ftp/pub/ks.cfg 
 1 #version=RHEL7
 2 # System authorization information
 3 auth --enableshadow --passalgo=sha512
 4 
 5 # Use CDROM installation media
 6 url --url=ftp://192.168.10.10
 7 # Run the Setup Agent on first boot
 20 # System timezone
 21 timezone Asia/Shanghai --isUtc
 22 user --name=linuxprobe --password=$6$a9v3InSTNbweIR7D$JegfYWbCdoOokj9sodEccdO.zL F4oSH2AZ2ss2R05B6Lz2A0v2K.RjwsBALL2FeKQVgf640oa/tok6J.7GUtO/ --iscrypted --gecos =&quot;linuxprobe&quot;
 23 # X Window System configuration information
 24 xconfig --startxonboot
 25 # System bootloader configuration
 26 bootloader --location=mbr --boot-drive=sda
 27 autopart --type=lvm
 28 # Partition clearing information
 29 clearpart --all --initlabel
 30 
 31 %packages</code></pre>
<p>如果觉得系统默认自带的应答文件参数较少，不能满足生产环境的需求，则可以通过Yum软件仓库来安装system-config-kickstart软件包。这是一款图形化的Kickstart应答文件生成工具，可以根据自己的需求生成自定义的应答文件，然后将生成的文件放到/var/ftp/pub目录中并将名字修改为ks.cfg即可。</p>
<h1 id="3-自动部署客户机"><a href="#3-自动部署客户机" class="headerlink" title="3. 自动部署客户机"></a>3. 自动部署客户机</h1><p>在按照上文讲解的方法成功部署各个相关的服务程序后，就可以使用PXE + Kickstart无人值守安装系统了。在采用下面的步骤建立虚拟主机时，一定要把客户端的网卡模式设定成与服务端一致的“仅主机模式”，否则两台设备无法进行通信，也就更别提自动安装系统了。其余硬件配置选项并没有强制性要求，大家可参考这里的配置选项来设定。</p>
<p>第1步：打开“新建虚拟机向导”程序，选择“典型（推荐） ”配置类型，然后单击“下一步”按钮，如图19-5所示。</p>
<img src="/2021/02/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-19-%E4%BD%BF%E7%94%A8PXE-Kickstart%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1/4.png" class>

<p>第2步：将虚拟机操作系统的安装来源设置为“稍后安装操作系统”。这样做的目的是让虚拟机真正从网络中获取系统安装镜像，同时也可避免VMware Workstation虚拟机软件按照内设的方法自行安装系统。单击“下一步”按钮，如图19-6所示。</p>
<img src="/2021/02/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-19-%E4%BD%BF%E7%94%A8PXE-Kickstart%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1/5.png" class>

<p>第3步：将“客户机操作系统”设置为“Red Hat Enterprise Linux 7 64位”，然后单击“下一步”按钮:</p>
<img src="/2021/02/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-19-%E4%BD%BF%E7%94%A8PXE-Kickstart%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1/6.png" class>

<p>第4步：对虚拟机进行命名并设置安装位置。大家可自行定义虚拟机的名称，而安装位置则尽量选择磁盘空间较大的分区。然后单击“下一步”按钮:</p>
<img src="/2021/02/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-19-%E4%BD%BF%E7%94%A8PXE-Kickstart%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1/7.png" class>

<p>第5步：指定磁盘容量。这里将“最大磁盘大小”设置为20GB，指的是虚拟机系统能够使用的最大上限，而不是会被立即占满，因此设置得稍微大一些也没有关系。然后单击“下一步”按钮。</p>
<img src="/2021/02/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-19-%E4%BD%BF%E7%94%A8PXE-Kickstart%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1/8.png" class>

<p>第6步：结束“新建虚拟机向导程序”后，先不要着急打开虚拟机系统。大家还需要单击图19-10中的“自定义硬件”按钮，在弹出的如下图所示的界面中，把“网络适配器”设备同样也设置为“仅主机模式”（这个步骤非常重要），然后单击“确定”按钮。</p>
<img src="/2021/02/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-19-%E4%BD%BF%E7%94%A8PXE-Kickstart%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1/9.png" class>

<img src="/2021/02/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-19-%E4%BD%BF%E7%94%A8PXE-Kickstart%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1/10.png" class>

<p>现在，我们就同时准备好了PXE + Kickstart无人值守安装系统与虚拟主机。在生产环境中，大家只需要将配置妥当的服务器上架，接通服务器和客户端主机之间的网线，然后启动客户端主机即可。接下来就会按照下图那样，开始传输光盘镜像文件并进行自动安装了—期间完全无须人工干预，直到安装完毕时才需要运维人员进行简单的初始化工作。</p>
<img src="/2021/02/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-19-%E4%BD%BF%E7%94%A8PXE-Kickstart%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1/11.png" class>

<img src="/2021/02/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-19-%E4%BD%BF%E7%94%A8PXE-Kickstart%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1/12.png" class>





]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第19章节：使用PXE+Kickstart无人值守安装服务</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：iptables与firewalld防火墙</title>
    <url>/2021/02/03/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Aiptables%E4%B8%8Efirewalld%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    <content><![CDATA[<h1 id="1-Iptables"><a href="#1-Iptables" class="headerlink" title="1.Iptables"></a>1.Iptables</h1><h2 id="（1）策略与规则链"><a href="#（1）策略与规则链" class="headerlink" title="（1）策略与规则链"></a>（1）策略与规则链</h2><p>iptables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链，而规则链则依据数据包处理位置的不同进行分类，具体如下：</p>
<a id="more"></a>

<pre><code>在进行路由选择前处理数据包（PREROUTING）；

处理流入的数据包（INPUT）；

处理流出的数据包（OUTPUT）；

处理转发的数据包（FORWARD）；

在进行路由选择后处理数据包（POSTROUTING）。</code></pre>
<p>iptables服务的术语分别是ACCEPT（允许流量通过）、REJECT（拒绝流量通过）、LOG（记录日志信息）、DROP（拒绝流量通过）。REJECT和DROP的不同点：就DROP来说，它是直接将流量丢弃而且不响应；REJECT则会在拒绝流量后再回复一条“您的信息已经收到，但是被扔掉了”信息，从而让流量发送方清晰地看到数据被拒绝的响应信息。</p>
<h2 id="（2）基本命令参数"><a href="#（2）基本命令参数" class="headerlink" title="（2）基本命令参数"></a>（2）基本命令参数</h2><p>防火墙策略规则的匹配顺序是从上至下的，因此要把较为严格、优先级较高的策略规则放到前面，以免发生错误。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-P</td>
<td>设置默认策略</td>
</tr>
<tr>
<td>-F</td>
<td>清空规则链</td>
</tr>
<tr>
<td>-L</td>
<td>查看规则链</td>
</tr>
<tr>
<td>-A</td>
<td>在规则链的末尾加入新规则</td>
</tr>
<tr>
<td>-I num</td>
<td>在规则链的头部加入新规则</td>
</tr>
<tr>
<td>-D num</td>
<td>删除某一条规则</td>
</tr>
<tr>
<td>-s</td>
<td>匹配来源地址IP/MASK，加叹号“!”表示除这个IP外</td>
</tr>
<tr>
<td>-d</td>
<td>匹配目标地址</td>
</tr>
<tr>
<td>-p</td>
<td>匹配协议，如TCP、UDP、ICMP</td>
</tr>
<tr>
<td>–dport num</td>
<td>匹配目标端口号</td>
</tr>
<tr>
<td>–sport num</td>
<td>匹配来源端口号</td>
</tr>
</tbody></table>
<p>规则链的默认策略拒绝动作只能是DROP，而不能是REJECT。</p>
<p>防火墙策略规则是按照从上到下的顺序匹配的，因此一定要把允许动作放到拒绝动作前面，否则所有的流量就将被拒绝掉，从而导致任何主机都无法访问我们的服务。</p>
<p>向INPUT规则链中添加拒绝192.168.10.5主机访问本机80端口（Web服务）的策略规则：</p>
<pre><code>[root@linuxprobe ~]# iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT</code></pre>
<p>向INPUT规则链中添加拒绝所有主机访问本机1000～1024端口的策略规则：</p>
<pre><code>[root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT
[root@linuxprobe ~]# iptables -A INPUT -p udp --dport 1000:1024 -j REJECT</code></pre>
<p>使用iptables命令配置的防火墙规则默认会在系统下一次重启时失效，如果想让配置的防火墙策略永久生效，还要执行保存命令：</p>
<pre><code>[root@linuxprobe ~]# service iptables save
iptables: Saving firewall rules to /etc/sysconfig/iptables: [ OK ]</code></pre>
<h1 id="2-Firewalld"><a href="#2-Firewalld" class="headerlink" title="2.Firewalld"></a>2.Firewalld</h1><table>
<thead>
<tr>
<th>区域</th>
<th>默认规则策略</th>
</tr>
</thead>
<tbody><tr>
<td>trusted</td>
<td>允许所有的数据包</td>
</tr>
<tr>
<td>home</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>internal</td>
<td>等同于home区域</td>
</tr>
<tr>
<td>work</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>public</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量</td>
</tr>
<tr>
<td>external</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td>
</tr>
<tr>
<td>dmz</td>
<td>拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量</td>
</tr>
<tr>
<td>block</td>
<td>拒绝流入的流量，除非与流出的流量相关</td>
</tr>
<tr>
<td>drop</td>
<td>拒绝流入的流量，除非与流出的流量相关</td>
</tr>
</tbody></table>
<h2 id="2-1图形管理工具"><a href="#2-1图形管理工具" class="headerlink" title="2.1图形管理工具"></a>2.1图形管理工具</h2><img src="/2021/02/03/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Aiptables%E4%B8%8Efirewalld%E9%98%B2%E7%81%AB%E5%A2%99/1.png" class>

<p>我们先将当前区域中请求http服务的流量设置为允许，但仅限当前生效：</p>
<img src="/2021/02/03/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Aiptables%E4%B8%8Efirewalld%E9%98%B2%E7%81%AB%E5%A2%99/2.png" class>

<p>试添加一条防火墙策略规则，使其放行访问8080～8088端口（TCP协议）的流量，并将其设置为永久生效，配置完毕之后，还需要在Options菜单中单击Reload Firewalld命令，让配置的防火墙策略立即生效：</p>
<img src="/2021/02/03/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Aiptables%E4%B8%8Efirewalld%E9%98%B2%E7%81%AB%E5%A2%99/3.png" class>

<img src="/2021/02/03/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Aiptables%E4%B8%8Efirewalld%E9%98%B2%E7%81%AB%E5%A2%99/4.png" class>

<p>使用iptables命令实现SNAT技术(Source Network Address Translation，源网络地址转换),可以使得多个内网中的用户通过同一个外网IP接入Internet:</p>
<img src="/2021/02/03/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Aiptables%E4%B8%8Efirewalld%E9%98%B2%E7%81%AB%E5%A2%99/5.png" class>

<p>将本机888端口的流量转发到22端口，且要求当前和长期均有效:</p>
<img src="/2021/02/03/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Aiptables%E4%B8%8Efirewalld%E9%98%B2%E7%81%AB%E5%A2%99/6.png" class>

<img src="/2021/02/03/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Aiptables%E4%B8%8Efirewalld%E9%98%B2%E7%81%AB%E5%A2%99/7.png" class>

<p>配置富规则，让192.168.10.20主机访问到本机的1234端口号:</p>
<img src="/2021/02/03/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Aiptables%E4%B8%8Efirewalld%E9%98%B2%E7%81%AB%E5%A2%99/8.png" class>

<p>把网卡与防火墙策略区域进行绑定:</p>
<img src="/2021/02/03/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Aiptables%E4%B8%8Efirewalld%E9%98%B2%E7%81%AB%E5%A2%99/9.png" class>

<h2 id="2-3服务的访问控制列表"><a href="#2-3服务的访问控制列表" class="headerlink" title="2.3服务的访问控制列表"></a>2.3服务的访问控制列表</h2><p>TCP Wrappers是RHEL 7系统中默认启用的一款流量监控程序，它能够根据来访主机的地址与本机的目标服务程序作出允许或拒绝的操作。换句话说，Linux系统中其实有两个层面的防火墙，第一种是前面讲到的基于TCP/IP协议的流量过滤工具，而TCP Wrappers服务则是能允许或禁止Linux系统提供服务的防火墙，从而在更高层面保护了Linux系统的安全运行。</p>
<p>在配置TCP Wrappers服务时需要遵循两个原则：</p>
<pre><code>（1）编写拒绝策略规则时，填写的是服务名称，而非协议名称；
（2）建议先编写拒绝策略规则（/etc/hosts.deny），再编写允许策略规则（/etc/hosts.allow），以便直观地看到相应的效果。</code></pre>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第8章节：iptables与firewalld防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：linux命令</title>
    <url>/2020/12/28/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Alinux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式"></a>1.命令格式</h1><p>格式要求： 命令名称 [命令参数]  [命令对象]<br>注意：<br>（1）命令名称、命令参数、命令对象之间需用空格键分隔；<br>（2）多个参数之间也要有空格，参数有长格式和短格式之分，分别用（–）和（-）作为前缀；长格式和长格式之间、长格式和短格式之间不能合并，短格式和短格式之间可以合并，共用一个空格，合并后仅保留一个-即可。</p>
<a id="more"></a>
<p>在命令行终端中输入”man 命令”来查看命令自身的帮助信息，在命令帮助信息的界面中，常用操作按键如下所示：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>空格键</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>PaGe down</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>PaGe up</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>home</td>
<td>直接前往首页</td>
</tr>
<tr>
<td>end</td>
<td>直接前往尾页</td>
</tr>
<tr>
<td>/</td>
<td>从上往下搜索某个关键词，如“/linux”</td>
</tr>
<tr>
<td>？</td>
<td>从下往上搜索某个关键词</td>
</tr>
<tr>
<td>n</td>
<td>定位到下一个搜索到的关键词</td>
</tr>
<tr>
<td>N</td>
<td>定位到上一个搜索到的关键词</td>
</tr>
<tr>
<td>q</td>
<td>退出帮助文档</td>
</tr>
</tbody></table>
<h1 id="2-常用的工作命令"><a href="#2-常用的工作命令" class="headerlink" title="2.常用的工作命令"></a>2.常用的工作命令</h1><ol>
<li>echo：用于在终端输出字符串或变量提取后的值，如： echo 字符串/$变量</li>
<li>date：用于显示及设置系统的时间或日期；<br> 直接输入date命令用于查看当前系统时间；<br> date “+%Y-%m-%d %H:%M:%S”:按照“年-月-日 小时:分钟:秒”的格式查看当前系统时间；<br> date -s “20200105 8:30:00”：将系统时间设置为2020年1月5日8点30分；<br> date “+%j”:用于查看今天是当年中的第几天；</li>
<li>reboot：用于重启系统；</li>
<li>poweroff：用于系统关机；</li>
<li>wget命令：用于在终端中下载网络文件（需连接网络才可以下载），如：wget http：//<a href="http://www.linuxprobe.com/docs/linuxprobe.pdf%EF%BC%9B">www.linuxprobe.com/docs/linuxprobe.pdf；</a></li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-b</td>
<td>后台下载模式</td>
</tr>
<tr>
<td>-P</td>
<td>下载到指定目录</td>
</tr>
<tr>
<td>-c</td>
<td>断点续传</td>
</tr>
<tr>
<td>-p</td>
<td>下载页面内的所有资源，包括图片、视频</td>
</tr>
<tr>
<td>-r</td>
<td>递归下载</td>
</tr>
</tbody></table>
<ol start="6">
<li>ps:用于查看系统中的进程状态；</li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>显示所有进程（包括其他用户）</td>
</tr>
<tr>
<td>-u</td>
<td>用户及其他详细信息</td>
</tr>
<tr>
<td>-x</td>
<td>显示没有控制终端的进程</td>
</tr>
</tbody></table>
<p>进程状态：R（运行）、S（休眠）、D（不可中断）、Z（僵死）、T（停止）；<br>7. top：用于动态地监视进程活动与系统负载等信息；<br>8. pidof：用于查询某个指定服务进程的PID值，如pidof sshd；<br>9. kill：用于终止某个指定PID的服务进程，如kill 2156；<br>10. killall：用于终止某个指定名称的服务所对应的全部进程；</p>
<h1 id="3-系统状态检测命令"><a href="#3-系统状态检测命令" class="headerlink" title="3.系统状态检测命令"></a>3.系统状态检测命令</h1><ol>
<li>ifconfig：用于获取网卡配置与网络状态等信息，可以查看到网卡名称、IP地址和物理地址；</li>
<li>uname：用于查看系统内核与系统版本等信息，加上-a参数能完整地查看当前系统的内核名称等信息；</li>
<li>uptime：用于查看系统的负载信息；负载值越低越好，尽量不要长期超过1，生产环境中不要超过5；</li>
<li>free：用于显示当前系统中内存的使用量信息，结合-h参数能以更人性化的方式树池当前内存的实时信息；</li>
<li>who：用于查看当前登入主机的用户终端信息；</li>
<li>last：用于查看所有系统的登陆记录，但仅供参考，其中内容可能会被篡改；</li>
<li>history：用于显示历史执行过的命令（默认为最近1000条的命令），使用-c参数则会清空所有的历史记录，使用“！编码数字”的方式可以重复执行某一次的命令；<br> 注：只有在终端关闭的时候，才会同步信息；</li>
<li>sosreport：用于收集系统配置及架构信息并输出诊断文档；</li>
</ol>
<h1 id="4-工作目录切换命令"><a href="#4-工作目录切换命令" class="headerlink" title="4.工作目录切换命令"></a>4.工作目录切换命令</h1><ol>
<li>pwd：用于显示用户当前所处的工作目录；</li>
<li>cd：用于切换工作路径，其中cd -：表示返回到上一次所处的目录； cd..:表示进入上级目录； cd~：表示切换到当前用户的家目录；</li>
<li>ls：用于显示目录中的文件信息，其中ls -a：表示查看全部文件（包括隐藏文件)；  ls -l：查看文件的属性、大小等详细信息； ls -d：查看目录及其详细信息；</li>
</ol>
<h1 id="5-文本文件编辑命令"><a href="#5-文本文件编辑命令" class="headerlink" title="5.文本文件编辑命令"></a>5.文本文件编辑命令</h1><ol>
<li>cat：用于查看纯文本文件（内容较少的），cat -n：显示行号；</li>
<li>more：用于查看纯文本文件（内容较多的）；按回车键向下走一行，空格键向下走一页；</li>
<li>head：用于查看文本文档的前N行内容，如 head -n 20 initial.cfg:查看initial.cfg文件的前20行内容；</li>
<li>tail：用于查看文本文档的后N行内容，如 tail -n 20 initial.cfg:查看initial.cfg文件的后20行内容；tail -f 文件名：用于实时查看最新日志文件；</li>
<li>tr：用于替换文本文件中的字符，格式为：tr [原始字符] [目标字符]，如 tr[a-z] [A-Z];</li>
<li>wc:用于统计指定文本的行数、字数和字节数；</li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td>只显示行数</td>
</tr>
<tr>
<td>-w</td>
<td>只显示单词数</td>
</tr>
<tr>
<td>-c</td>
<td>只显示字节数</td>
</tr>
<tr>
<td>-d</td>
<td>同时修改atime和mtime</td>
</tr>
</tbody></table>
<ol start="7">
<li>stat：用于查看文件的具体存储信息和时间等信息；其中Access表示最后一次访问文件的时间；Modify表示真实修改文件内容的时间；Change表示修改文件属性信息的时间。</li>
<li>cut：用于按“列”提取文本字符；-d参数：用于设置间隔符号； -f参数：用于设置想看的列数；</li>
<li>diff：用于比较多个文本文件的差异； –brief参数:用于确认两个文件是否不同；  -c参数：用于比较多个文件的差异之处。查询结果中有“！”开头的行，表示内容有不同。</li>
</ol>
<h1 id="6-文件目录管理命令"><a href="#6-文件目录管理命令" class="headerlink" title="6.文件目录管理命令"></a>6.文件目录管理命令</h1><p>1.touch：用于创建空白文件或设置文件的时间；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>修改读取时间</td>
</tr>
<tr>
<td>-m</td>
<td>修改修改时间</td>
</tr>
<tr>
<td>-c</td>
<td>修改更改权限时间</td>
</tr>
<tr>
<td>-d</td>
<td>同时修改atime和mtime</td>
</tr>
</tbody></table>
<p>2.mkdir：用于创建空白目录；mkdir -p：能够递归创建具有嵌套关系的文件目录。<br>3.cp：用于复制文件或目录；格式为：cp [选项] 源文件 目标文件<br>复制操作分为3种情况：<br>（1）如果目标文件为目录，则把源文件复制到该目录中；<br>（2）如果目标文件为文件，则会询问是否要覆盖它；<br>（3）如果目标文件不存在，则执行正常的复制操作；<br>4.mv：用于剪切文件或将文件重命名，格式为：mv [选项]  源文件 [目标路径|目标文件名]<br>5.rm：用于删除文件或目录； -f：强制删除； -r：用于删除文件夹或目录；<br>6.dd：用于按照指定大小和个数的数据块来复制文件或转换文件；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>if</td>
<td>输入的文件名称</td>
</tr>
<tr>
<td>of</td>
<td>输出的文件名称</td>
</tr>
<tr>
<td>bs</td>
<td>每个“块”的大小</td>
</tr>
<tr>
<td>count</td>
<td>复制“块”的个数</td>
</tr>
</tbody></table>
<p>如：dd if=/dev/zero of=560_file count=1 bs=560M</p>
<p>7.file:用于查看文件的类型；</p>
<h1 id="7-打包压缩与搜索命令"><a href="#7-打包压缩与搜索命令" class="headerlink" title="7.打包压缩与搜索命令"></a>7.打包压缩与搜索命令</h1><p>1.tar：用于将文件进行打包压缩或解压；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>创建压缩文件</td>
</tr>
<tr>
<td>-x</td>
<td>解开压缩文件</td>
</tr>
<tr>
<td>-z</td>
<td>用Gzip压缩或解压</td>
</tr>
<tr>
<td>-j</td>
<td>用bzip2压缩或解压</td>
</tr>
<tr>
<td>-v</td>
<td>显示压缩或解压的过程</td>
</tr>
<tr>
<td>-f</td>
<td>目标文件名</td>
</tr>
<tr>
<td>-C</td>
<td>指定解压到的目录</td>
</tr>
</tbody></table>
<p>将文件打包压缩：tar -czvf 压缩包名称.tar.gz 要打包的目录； 如： tar -czvf etc.tar.gz /etc<br>解压命令：tar -xzvf 压缩包名称.tar.gz; 如： tar xzvf etc.tar.gz -C /root/etc</p>
<p>2.grep:用于在文本中执行关键词搜索； -n：用来显示搜索到信息的行号； -v：用于反选信息；<br>3.find：用于按照指定条件来查找文件；格式为：find [查找路径] 寻找条件 操作； 如： find /etc -name “host*” -print<br>-exec:用于将find命令搜索到的结果交由后面的命令作进一步处理，exec虽然是长格式，但只需要一个“-”。</p>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第2章节：linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：使用RAID与LVM磁盘阵列技术</title>
    <url>/2021/02/02/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8RAID%E4%B8%8ELVM%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>RAID：Redundant Array of Independent Disks，独立冗余磁盘阵列；<br>LVM：Logical Volume Manager，逻辑卷管理器；</p>
<a id="more"></a>

<h1 id="1-RAID-0"><a href="#1-RAID-0" class="headerlink" title="1.RAID 0"></a>1.RAID 0</h1><img src="/2021/02/02/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8RAID%E4%B8%8ELVM%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E6%8A%80%E6%9C%AF/1.png" class>

<h1 id="2-RAID-1"><a href="#2-RAID-1" class="headerlink" title="2.RAID 1"></a>2.RAID 1</h1><img src="/2021/02/02/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8RAID%E4%B8%8ELVM%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E6%8A%80%E6%9C%AF/2.jpg" class>

<h1 id="3-RAID-5"><a href="#3-RAID-5" class="headerlink" title="3.RAID 5"></a>3.RAID 5</h1><img src="/2021/02/02/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8RAID%E4%B8%8ELVM%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E6%8A%80%E6%9C%AF/3.png" class>

<h1 id="4-RAID-10"><a href="#4-RAID-10" class="headerlink" title="4.RAID 10"></a>4.RAID 10</h1><img src="/2021/02/02/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8RAID%E4%B8%8ELVM%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E6%8A%80%E6%9C%AF/4.png" class>

<p>mdadm命令用于管理Linux系统中的软件RAID硬盘阵列，格式为“mdadm [模式] &lt;RAID设备名称&gt; [选项] [成员设备名称]”.</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>检测设备名称</td>
</tr>
<tr>
<td>-n</td>
<td>指定设备数量</td>
</tr>
<tr>
<td>-l</td>
<td>指定RAID级别</td>
</tr>
<tr>
<td>-C</td>
<td>创建</td>
</tr>
<tr>
<td>-v</td>
<td>显示过程</td>
</tr>
<tr>
<td>-D</td>
<td>查看详细信息</td>
</tr>
<tr>
<td>-r</td>
<td>移除设备</td>
</tr>
<tr>
<td>-S</td>
<td>停止RAID磁盘阵列</td>
</tr>
</tbody></table>
<p>-C参数代表创建一个RAID阵列卡；-v参数显示创建的过程，同时在后面追加一个设备名称/dev/md0，这样/dev/md0就是创建后的RAID磁盘阵列的名称；-a yes参数代表自动创建设备文件；-n 4参数代表使用4块硬盘来部署这个RAID磁盘阵列；而-l 10参数则代表RAID 10方案；最后再加上4块硬盘设备的名称就搞定了。</p>
<pre><code>[root@linuxprobe ~]# mdadm -Cv /dev/md0 -a yes -n 4 -l 10 /dev/sdb /dev/sdc /dev/sdd /dev/sde</code></pre>
<p>之后格式化mkfs.ext4，创建挂载点mkdir /RAID，查看详细信息mdadm -D /dev/md0，并把挂载信息写入配置文件。</p>
<h1 id="5-磁盘阵列-备份盘"><a href="#5-磁盘阵列-备份盘" class="headerlink" title="5.磁盘阵列+备份盘"></a>5.磁盘阵列+备份盘</h1><p>在下面的命令中，参数-n 3代表创建这个RAID 5磁盘阵列所需的硬盘数，参数-l 5代表RAID的级别，而参数-x 1则代表有一块备份盘。当查看/dev/md0（即RAID 5磁盘阵列的名称）磁盘阵列的时候就能看到有一块备份盘在等待中了：</p>
<pre><code>mdadm -Cv /dev/md0 -n 3 -l 5 -x 1 /dev/sdb /dev/sdc /dev/sdd /dev/sde</code></pre>
<h1 id="6-部署逻辑卷"><a href="#6-部署逻辑卷" class="headerlink" title="6.部署逻辑卷"></a>6.部署逻辑卷</h1>

<pre><code>[root@linuxprobe ~]# pvcreate /dev/sdb /dev/sdc
[root@linuxprobe ~]# vgcreate storage /dev/sdb /dev/sdc
[root@linuxprobe ~]# lvcreate -n vo -l 37 storage（在对逻辑卷进行切割时有两种计量单位。第一种是以容量为单位，所使用的参数为-L。例如，使用-L 150M生成一个大小为150MB的逻辑卷。另外一种是以基本单元的个数为单位，所使用的参数为-l。每个基本单元的大小默认为4MB。例如，使用-l 37可以生成一个大小为37×4MB=148MB的逻辑卷。）</code></pre>
<p>之后再格式化，挂载，写入配置文件中即可！</p>
<h1 id="7-扩容逻辑卷"><a href="#7-扩容逻辑卷" class="headerlink" title="7.扩容逻辑卷"></a>7.扩容逻辑卷</h1><p>扩展前请一定要记得卸载设备和挂载点的关联。</p>
<pre><code>[root@linuxprobe ~]# lvextend -L 290M /dev/storage/vo （逻辑卷vo扩展至290MB）
[root@linuxprobe ~]# e2fsck -f /dev/storage/vo （检查硬盘完整性）
[root@linuxprobe ~]# resize2fs /dev/storage/vo （重置硬盘容量）</code></pre>
<p>之后mount -a挂载硬盘设备即可！</p>
<h1 id="8-缩小逻辑卷"><a href="#8-缩小逻辑卷" class="headerlink" title="8.缩小逻辑卷"></a>8.缩小逻辑卷</h1><p>扩展前请一定要记得卸载设备和挂载点的关联。</p>
<pre><code>[root@linuxprobe ~]# e2fsck -f /dev/storage/vo
[root@linuxprobe ~]# resize2fs /dev/storage/vo 120M
[root@linuxprobe ~]# lvreduce -L 120M /dev/storage/vo</code></pre>
<p>之后mount -a挂载硬盘设备即可！</p>
<h1 id="9-逻辑卷快照"><a href="#9-逻辑卷快照" class="headerlink" title="9.逻辑卷快照"></a>9.逻辑卷快照</h1><p>LVM的快照卷功能有两个特点：</p>
<pre><code>快照卷的容量必须等同于逻辑卷的容量；

快照卷仅一次有效，一旦执行还原操作后则会被立即自动删除。

[root@linuxprobe ~]#  lvcreate -L 120M -s -n SNAP /dev/storage/vo （使用-s参数生成一个快照卷，使用-L参数指定切割的大小。另外，还需要在命令后面写上是针对哪个逻辑卷执行的快照操作。）
[root@linuxprobe ~]# umount /linuxprobe （记得先卸载掉逻辑卷设备与目录的挂载。）
[root@linuxprobe ~]# lvconvert --merge /dev/storage/SNAP
[root@linuxprobe ~]# mount -a</code></pre>
<h1 id="10-删除逻辑卷"><a href="#10-删除逻辑卷" class="headerlink" title="10.删除逻辑卷"></a>10.删除逻辑卷</h1><pre><code>[root@linuxprobe ~]# umount /linuxprobe （取消逻辑卷与目录的挂载关联）
[root@linuxprobe ~]# vim /etc/fstab （删除配置文件中永久生效的设备参数）
[root@linuxprobe ~]# lvremove /dev/storage/vo （删除逻辑卷设备，需要输入y来确认操作）
[root@linuxprobe ~]# vgremove storage （删除卷组，此处只写卷组名称即可，不需要设备的绝对路径）
[root@linuxprobe ~]# pvremove /dev/sdb /dev/sdc （删除物理卷设备）</code></pre>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第7章节：使用RAID与LVM磁盘阵列技术</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：使用ssh服务管理远程主机</title>
    <url>/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="1-配置网卡服务"><a href="#1-配置网卡服务" class="headerlink" title="1.配置网卡服务"></a>1.配置网卡服务</h1><p>介绍了SSH协议与sshd服务程序的理论知识、Linux系统的远程管理方法以及在系统中配置服务程序的方法，并采用实验的形式演示了使用基于密码验证的sshd服务程序进行远程登录，以及使用screen服务程序远程管理Linux系统的不间断会话等技术。</p>
<a id="more"></a>

<h1 id="1-1配置网卡参数"><a href="#1-1配置网卡参数" class="headerlink" title="1.1配置网卡参数"></a>1.1配置网卡参数</h1><img src="/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/1.png" class>

<img src="/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/2.png" class>

<img src="/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/3.png" class>

<img src="/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/4.png" class>

<img src="/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/5.png" class>

<img src="/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/6.png" class>

<img src="/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/7.png" class>

<img src="/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/8.png" class>

<p>用Vim编辑器将网卡配置文件中的ONBOOT参数修改成yes，这样在系统重启后网卡就被激活了:</p>
<pre><code>[root@linuxprobe ~]# vim /etc/sysconfig/network-scripts/ifcfg-eno16777736
TYPE=Ethernet
BOOTPROTO=none
...
ONBOOT=yes</code></pre>
<p>修改完Linux系统中的服务配置文件后,要手动重启相应的服务:</p>
<pre><code>[root@linuxprobe ~]# systemctl restart network</code></pre>
<h2 id="1-2创建网络会话"><a href="#1-2创建网络会话" class="headerlink" title="1.2创建网络会话"></a>1.2创建网络会话</h2><p>NetworkManager：是一种动态管理网络配置的守护进程，能够让网络设备保持连接状态；可以使用nmcli命令来管理Network Manager服务。</p>
<p>可以使用nmcli命令并按照“connection add con-name type ifname”的格式来创建网络会话。</p>
<p>使用con-name参数指定使用的网络会话名称company，然后依次用ifname参数指定网卡名称，用autoconnect no参数设置该网络会话默认不被自动激活，以及用ip4及gw4参数手动指定网络的IP地址：</p>
<pre><code>[root@linuxprobe ~]# nmcli connection add con-name company ifname eno16777736 autoconnect no type ethernet ip4 192.168.10.10/24 gw4 192.168.10.1</code></pre>
<p>使用con-name参数指定网络会话名称house，使用外部DHCP服务器自动获得IP地址，不需要进行手动指定：</p>
<pre><code>[root@linuxprobe ~]# nmcli connection add con-name house type ethernet ifname eno16777736</code></pre>
<p>使配置过的网络会话生效：</p>
<pre><code>[root@linuxprobe ~]# nmcli connection up house </code></pre>
<h2 id="1-3绑定两块网卡"><a href="#1-3绑定两块网卡" class="headerlink" title="1.3绑定两块网卡"></a>1.3绑定两块网卡</h2><img src="/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/9.png" class>

<img src="/2021/02/04/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8ssh%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/10.png" class>

<p>使用Vim文本编辑器来配置网卡设备的绑定参数：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/sysconfig/network-scripts/ifcfg-eno16777736
TYPE=Ethernet
BOOTPROTO=none
ONBOOT=yes
USERCTL=no
DEVICE=eno16777736
MASTER=bond0
SLAVE=yes
[root@linuxprobe ~]# vim /etc/sysconfig/network-scripts/ifcfg-eno33554968
TYPE=Ethernet
BOOTPROTO=none
ONBOOT=yes
USERCTL=no
DEVICE=eno33554968
MASTER=bond0
SLAVE=yes</code></pre>
<p>将绑定后的设备命名为bond0并把IP地址等信息填写进去，这样当用户访问相应服务的时候，实际上就是由这两块网卡设备在共同提供服务：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/sysconfig/network-scripts/ifcfg-bond0
TYPE=Ethernet
BOOTPROTO=none
ONBOOT=yes
USERCTL=no
DEVICE=bond0
IPADDR=192.168.10.10
PREFIX=24
DNS=192.168.10.1
NM_CONTROLLED=no</code></pre>
<p>让Linux内核支持网卡绑定驱动。常见的网卡绑定驱动有三种模式—mode0、mode1和mode6。下面以绑定两块网卡为例，讲解使用的情景。</p>
<pre><code>mode0（平衡负载模式）：平时两块网卡均工作，且自动备援，但需要在与服务器本地网卡相连的交换机设备上进行端口聚合来支持绑定技术。

mode1（自动备援模式）：平时只有一块网卡工作，在它故障后自动替换为另外的网卡。

mode6（平衡负载模式）：平时两块网卡均工作，且自动备援，无须交换机设备提供辅助支持。</code></pre>
<p>使用Vim文本编辑器创建一个用于网卡绑定的驱动文件，使得绑定后的bond0网卡设备能够支持绑定技术（bonding）；同时定义网卡以mode6模式进行绑定，且出现故障时自动切换的时间为100毫秒：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/modprobe.d/bond.conf
alias bond0 bonding
options bond0 miimon=100 mode=6</code></pre>
<p>重启网络服务后网卡绑定操作即可成功。正常情况下只有bond0网卡设备才会有IP地址等信息：</p>
<pre><code>[root@linuxprobe ~]# systemctl restart network</code></pre>
<h1 id="2-远程控制服务"><a href="#2-远程控制服务" class="headerlink" title="2.远程控制服务"></a>2.远程控制服务</h1><h2 id="2-1配置sshd服务"><a href="#2-1配置sshd服务" class="headerlink" title="2.1配置sshd服务"></a>2.1配置sshd服务</h2><p>想要使用SSH协议来远程管理Linux系统，则需要部署配置sshd服务程序。sshd是基于SSH协议开发的一款远程管理服务程序，不仅使用起来方便快捷，而且能够提供两种安全验证的方法：</p>
<pre><code>基于口令的验证—用账户和密码来验证登录；

基于密钥的验证—需要在本地生成密钥对，然后把密钥对中的公钥上传至服务器，并与服务器中的公钥进行比较；该方式相较来说更安全。</code></pre>
<p>sshd服务的配置信息保存在/etc/ssh/sshd_config文件中；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Port 22</td>
<td>默认的sshd服务端口</td>
</tr>
<tr>
<td>ListenAddress 0.0.0.0</td>
<td>设定sshd服务器监听的IP地址</td>
</tr>
<tr>
<td>Protocol 2</td>
<td>SSH协议的版本号</td>
</tr>
<tr>
<td>HostKey /tc/ssh/ssh_host_key</td>
<td>SSH协议版本为1时，DES私钥存放的位置</td>
</tr>
<tr>
<td>HostKey /etc/ssh/ssh_host_rsa_key</td>
<td>SSH协议版本为2时，RSA私钥存放的位置</td>
</tr>
<tr>
<td>HostKey /etc/ssh/ssh_host_dsa_key</td>
<td>SSH协议版本为2时，DSA私钥存放的位置</td>
</tr>
<tr>
<td>PermitRootLogin yes</td>
<td>设定是否允许root管理员直接登录</td>
</tr>
<tr>
<td>StrictModes yes</td>
<td>当远程用户的私钥改变时直接拒绝连接</td>
</tr>
<tr>
<td>MaxAuthTries 6</td>
<td>最大密码尝试次数</td>
</tr>
<tr>
<td>MaxSessions 10</td>
<td>最大终端数</td>
</tr>
<tr>
<td>PasswordAuthentication yes</td>
<td>是否允许密码验证</td>
</tr>
<tr>
<td>PermitEmptyPasswords no</td>
<td>是否允许空密码登录（很不安全）</td>
</tr>
</tbody></table>
<pre><code>[root@linuxprobe ~]# ssh 192.168.10.10
The authenticity of host &#39;192.168.10.10 (192.168.10.10)&#39; can&#39;t be established.
ECDSA key fingerprint is 4f:a7:91:9e:8d:6f:b9:48:02:32:61:95:48:ed:1e:3f.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &#39;192.168.10.10&#39; (ECDSA) to the list of known hosts.
root@192.168.10.10&#39;s password:此处输入远程主机root管理员的密码
Last login: Wed Apr 15 15:54:21 2017 from 192.168.10.10
[root@linuxprobe ~]# 
[root@linuxprobe ~]# exit
logout
Connection to 192.168.10.10 closed.</code></pre>
<p>禁止以root管理员的身份远程登录到服务器：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/ssh/sshd_config 
 ………………省略部分输出信息………………
 46 
 47 #LoginGraceTime 2m
 **48 PermitRootLogin no**
 49 #StrictModes yes
 50 #MaxAuthTries 6
 51 #MaxSessions 10
 52
 ………………省略部分输出信息………………</code></pre>
<p>让新配置文件生效，则需要手动重启相应的服务程序；最好也将这个服务程序加入到开机启动项中：</p>
<pre><code>[root@linuxprobe ~]# systemctl restart sshd
[root@linuxprobe ~]# systemctl enable sshd</code></pre>
<h2 id="2-2安全密钥验证"><a href="#2-2安全密钥验证" class="headerlink" title="2.2安全密钥验证"></a>2.2安全密钥验证</h2><p>第1步：在客户端主机中生成“密钥对”。</p>
<pre><code>[root@linuxprobe ~]# ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa):按回车键或设置密钥的存储路径
Created directory &#39;/root/.ssh&#39;.
Enter passphrase (empty for no passphrase):直接按回车键或设置密钥的密码
Enter same passphrase again:再次按回车键或设置密钥的密码
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
40:32:48:18:e4:ac:c0:c3:c1:ba:7c:6c:3a:a8:b5:22 root@linuxprobe.com
The key&#39;s randomart image is:
    +--[ RSA 2048]----+
    |+*..o .          |
    |*.o  +           |
    |o*    .          |
    |+ .    .         |
    |o..     S        |
    |.. +             |
    |. =              |
    |E+ .             |
    |+.o              |
    +-----------------+</code></pre>
<p>第2步：把客户端主机中生成的公钥文件传送至远程主机：</p>
<pre><code>[root@linuxprobe ~]# ssh-copy-id 192.168.10.10
The authenticity of host &#39;192.168.10.20 (192.168.10.10)&#39; can&#39;t be established.
ECDSA key fingerprint is 4f:a7:91:9e:8d:6f:b9:48:02:32:61:95:48:ed:1e:3f.
Are you sure you want to continue connecting (yes/no)? yes
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@192.168.10.10&#39;s password:此处输入远程服务器密码
Number of key(s) added: 1
Now try logging into the machine, with: &quot;ssh &#39;192.168.10.10&#39;&quot;
and check to make sure that only the key(s) you wanted were added.</code></pre>
<p>第3步：对服务器进行设置，使其只允许密钥验证，拒绝传统的口令验证方式。记得在修改配置文件后保存并重启sshd服务程序。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/ssh/sshd_config 
 ………………省略部分输出信息………………
 74 
 75 # To disable tunneled clear text passwords, change to no here!
 76 #PasswordAuthentication yes
 77 #PermitEmptyPasswords no
 **78 PasswordAuthentication no**
 79 
 ………………省略部分输出信息………………
[root@linuxprobe ~]# systemctl restart sshd</code></pre>
<p>第4步：在客户端尝试登录到服务器，此时无须输入密码也可成功登录。</p>
<pre><code>[root@linuxprobe ~]# ssh 192.168.10.10
Last login: Mon Apr 13 19:34:13 2017</code></pre>
<h2 id="2-3远程传输命令"><a href="#2-3远程传输命令" class="headerlink" title="2.3远程传输命令"></a>2.3远程传输命令</h2><p>scp（secure copy）是一个基于SSH协议在网络之间进行安全传输的命令，其格式为“scp [参数] 本地文件 远程帐户@远程IP地址:远程目录；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-v</td>
<td>显示详细的连接进度</td>
</tr>
<tr>
<td>-p</td>
<td>指定远程主机的sshd端口号</td>
</tr>
<tr>
<td>-r</td>
<td>用于传送文件夹</td>
</tr>
<tr>
<td>-6</td>
<td>使用IPv6协议</td>
</tr>
</tbody></table>
<p>在使用scp命令把文件从本地复制到远程主机时，首先需要以绝对路径的形式写清本地文件的存放位置：</p>
<pre><code>[root@linuxprobe ~]# echo &quot;Welcome to LinuxProbe.Com&quot; &gt; readme.txt
[root@linuxprobe ~]# scp /root/readme.txt 192.168.10.20:/home
root@192.168.10.20&#39;s password:此处输入远程服务器中root管理员的密码
readme.txt 100% 26 0.0KB/s 00:00</code></pre>
<p>使用scp命令把远程主机上的文件下载到本地主机，其命令格式为“scp [参数] 远程用户@远程IP地址:远程文件 本地目录”:</p>
<pre><code>[root@linuxprobe ~]# scp 192.168.10.20:/etc/redhat-release /root
root@192.168.10.20&#39;s password:此处输入远程服务器中root管理员的密码
redhat-release 100% 52 0.1KB/s 00:00 
[root@linuxprobe ~]# cat redhat-release 
Red Hat Enterprise Linux Server release 7.0 (Maipo)</code></pre>
<h1 id="3-不间断会话服务"><a href="#3-不间断会话服务" class="headerlink" title="3.不间断会话服务"></a>3.不间断会话服务</h1><p>screen是一款能够实现多窗口远程控制的开源服务程序，简单来说就是为了解决网络异常中断或为了同时控制多个远程终端窗口而设计的程序。用户还可以使用screen服务程序同时在多个远程会话中自由切换，能够做到实现如下功能。</p>
<pre><code>会话恢复：即便网络中断，也可让会话随时恢复，确保用户不会失去对远程会话的控制。

多窗口：每个会话都是独立运行的，拥有各自独立的输入输出终端窗口，终端窗口内显示过的信息也将被分开隔离保存，以便下次使用时依然能看到之前的操作记录。

会话共享：当多个用户同时登录到远程服务器时，便可以使用会话共享功能让用户之间的输入输出信息共享。</code></pre>
<h2 id="3-1管理远程会话"><a href="#3-1管理远程会话" class="headerlink" title="3.1管理远程会话"></a>3.1管理远程会话</h2><p>screen命令：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-S</td>
<td>创建会话窗口</td>
</tr>
<tr>
<td>-d</td>
<td>将指定会话进行离线处理</td>
</tr>
<tr>
<td>-r</td>
<td>恢复指定会话</td>
</tr>
<tr>
<td>-x</td>
<td>一次性恢复所有会话</td>
</tr>
<tr>
<td>-ls</td>
<td>显示当前已有会话</td>
</tr>
<tr>
<td>-wipe</td>
<td>将目前无法使用的会话删除</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第9章节：使用ssh服务管理远程主机</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：使用win10主机ping通虚拟机</title>
    <url>/2021/02/09/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8win10%E4%B8%BB%E6%9C%BAping%E9%80%9A%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p>在win10系统中安装了vm12版本，Linux我选用的是redhat 7版本；成功安装redhat 7后，将linux虚拟机的IP地址固定：</p>
<a id="more"></a>

<img src="/2021/02/09/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8win10%E4%B8%BB%E6%9C%BAping%E9%80%9A%E8%99%9A%E6%8B%9F%E6%9C%BA/1.png" class>

<p>linux虚拟机的外部连接方式为NAT模式，在linux虚拟机中能够ping通自己的IP，但无法ping通win10系统的IP，win10系统也无法ping通linux虚拟机IP。</p>
<img src="/2021/02/09/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8win10%E4%B8%BB%E6%9C%BAping%E9%80%9A%E8%99%9A%E6%8B%9F%E6%9C%BA/2.png" class>

<p>解决方法如下：</p>
<p>1.首先确认了本机的网络有无VMware Network Adapter VMnet8这两个网络：</p>
<img src="/2021/02/09/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8win10%E4%B8%BB%E6%9C%BAping%E9%80%9A%E8%99%9A%E6%8B%9F%E6%9C%BA/3.png" class>

<p>有以上两个网络的话，跳过此步骤；没有的话，则将VM虚拟机卸载，之后清理完之后再重新安装VM虚拟机软件。</p>
<p>2.安装好虚拟机后，打开终端，输入：vim /etc/sysconfig/network-scripts/ifcfg-eno16777728（网卡名称），编辑下网卡文件，将BOOTPROTO的值修改为static，并添加参数：IPADDR，GATEWAR，NETMASK，NM_CONTROLLED。IPADDR，GATEWAR这两个设置注意网段要与VMware Network Adapter VMnet8 的一致：</p>
<img src="/2021/02/09/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8win10%E4%B8%BB%E6%9C%BAping%E9%80%9A%E8%99%9A%E6%8B%9F%E6%9C%BA/4.png" class>

<p>3.设置好之后，保存退出；之后重启系统，用linux虚拟机ping下win10系统IP地址，测试是否能够ping通，如果可以，那就ok了。</p>
<p>linux虚拟机ping win10系统：</p>
<img src="/2021/02/09/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8win10%E4%B8%BB%E6%9C%BAping%E9%80%9A%E8%99%9A%E6%8B%9F%E6%9C%BA/5.png" class>

<p>win10系统ping linux虚拟机：</p>
<img src="/2021/02/09/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8win10%E4%B8%BB%E6%9C%BAping%E9%80%9A%E8%99%9A%E6%8B%9F%E6%9C%BA/6.png" class>



















]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>使用win10主机ping通虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：存储结构与磁盘划分</title>
    <url>/2021/02/01/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E7%A3%81%E7%9B%98%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<h1 id="1-一切从“-”开始"><a href="#1-一切从“-”开始" class="headerlink" title="1.一切从“/”开始"></a>1.一切从“/”开始</h1><p>Linux系统中的一切文件都是从“根（/）”目录开始的，并按照文件系统层次化标准（FHS）采用树形结构来存放文件，以及定义了常见目录的用途。另外，Linux系统中的文件和目录名称是严格区分大小写的。  </p>
<a id="more"></a>

<table>
<thead>
<tr>
<th>目录名称</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>/boot</td>
<td>开机所需文件—内核、开机菜单以及所需配置文件等</td>
</tr>
<tr>
<td>/dev</td>
<td>以文件形式存放任何设备与接口</td>
</tr>
<tr>
<td>/etc</td>
<td>配置文件</td>
</tr>
<tr>
<td>/home</td>
<td>用户主目录</td>
</tr>
<tr>
<td>/media</td>
<td>用于挂载设备文件的目录</td>
</tr>
</tbody></table>
<p>主分区或扩展分区的编号从1开始，到4结束；逻辑分区从编号5开始。</p>
<p>mount命令用于挂载文件系统，格式为“mount 文件系统 挂载目录”；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>挂载所有在/etc/fstab中定义的文件系统</td>
</tr>
<tr>
<td>-t</td>
<td>指定文件系统的类型</td>
</tr>
</tbody></table>
<p>如果想让硬件设备和目录永久地进行自动关联，就必须把挂载信息按照指定的填写格式“设备文件 挂载目录 格式类型 权限选项 是否备份 是否自检”（各字段的意义见表6-4）写入到/etc/fstab文件中。</p>
<p>umount命令用于撤销已经挂载的设备文件，格式为“umount [挂载点/设备文件]”。</p>
<h2 id="1-1添加硬盘设备"><a href="#1-1添加硬盘设备" class="headerlink" title="1.1添加硬盘设备"></a>1.1添加硬盘设备</h2><p>1.fdisk命令：用于管理磁盘分区，格式为“fdisk  [磁盘名称]”，它提供了集添加、删除、转换分区等功能于一身的“一站式分区服务”；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>m</td>
<td>查看全部可用的参数</td>
</tr>
<tr>
<td>n</td>
<td>添加新的分区</td>
</tr>
<tr>
<td>d</td>
<td>删除某个分区</td>
</tr>
<tr>
<td>p</td>
<td>查看分区表信息</td>
</tr>
<tr>
<td>w</td>
<td>保存并退出</td>
</tr>
<tr>
<td>q</td>
<td>不保存直接退出</td>
</tr>
</tbody></table>
<p>2.mkfs：存储设备进行分区后进行格式化操作；</p>
<p>3.mount：挂载存储设备；</p>
<p>4.du：查看文件数据占用量；du -sh /*命令来查看在Linux系统根目录下所有一级目录分别占用的空间大小。</p>
<p>如果想让这个设备文件的挂载永久有效，则需要把挂载的信息写入到配置文件中：</p>
<h2 id="1-2添加交换分区"><a href="#1-2添加交换分区" class="headerlink" title="1.2添加交换分区"></a>1.2添加交换分区</h2><p>SWAP（交换）分区是一种通过在硬盘中预先划分一定的空间，然后将把内存中暂时不常用的数据临时存放到硬盘中，以便腾出物理内存空间让更活跃的程序服务来使用的技术，其设计目的是为了解决真实物理内存不足的问题。但由于交换分区毕竟是通过硬盘设备读写数据的，速度肯定要比物理内存慢，所以只有当真实的物理内存耗尽后才会调用交换分区的资源。</p>
<p>生产环境中，交换分区的大小一般为真实物理内存的1.5～2倍；</p>
<pre><code>（1）fdisk
（2）mkswap:SWAP分区专用的格式化命令；
（3）free -m：用于查看交换分区的大小；
（4）将相关信息写入配置文件（/etc/fstab），并保存！如：/dev/sdb2 swap swap defaults 0 0 </code></pre>
<h2 id="1-3磁盘容量配额"><a href="#1-3磁盘容量配额" class="headerlink" title="1.3磁盘容量配额"></a>1.3磁盘容量配额</h2><p>使用quota命令进行磁盘容量配额管理，从而限制用户的硬盘可用容量或所能创建的最大文件个数。quota命令还有软限制和硬限制的功能。</p>
<p>软限制：当达到软限制时会提示用户，但仍允许用户在限定的额度内继续使用。</p>
<p>硬限制：当达到硬限制时会提示用户，且强制终止用户的操作。</p>
<p>1.xfs_quota：-c参数用于以参数的形式设置要执行的命令；-x参数是专家模式，让运维人员能够对quota服务进行更多复杂的配置。</p>
<pre><code>[root@linuxprobe ~]# xfs_quota -x -c &#39;limit bsoft=3m bhard=6m isoft=3 ihard=6 tom&#39; /boot
[root@linuxprobe ~]# xfs_quota -x -c report /boot</code></pre>
<p>2.edquota：用于编辑用户的quota配额限制，格式为“edquota [参数] [用户] ”。-u参数表示要针对哪个用户进行设置；-g参数表示要针对哪个用户组进行设置。</p>
<h2 id="1-4软硬方式链接"><a href="#1-4软硬方式链接" class="headerlink" title="1.4软硬方式链接"></a>1.4软硬方式链接</h2><p>硬链接： 是指针，所有的硬链接都是指向同一个磁盘块； 删除一个指针不会真正删除文件，只有把所有的指针都删除才会真正删除文件。<br>软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。</p>
<p>1.ln：用于创建链接文件，格式为“ln [选项] 目标”；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-s</td>
<td>创建“符号链接”（如果不带-s参数，则默认创建硬链接）</td>
</tr>
<tr>
<td>-f</td>
<td>强制创建文件或目录的链接</td>
</tr>
<tr>
<td>-i</td>
<td>覆盖前先询问</td>
</tr>
<tr>
<td>-v</td>
<td>显示创建链接的过程</td>
</tr>
</tbody></table>
<pre><code>[root@linuxprobe ~]# echo &quot;Welcome to linuxprobe.com&quot; &gt; readme.txt
[root@linuxprobe ~]# ln -s readme.txt readit.txt
[root@linuxprobe ~]# cat readme.txt 
 Welcome to linuxprobe.com
[root@linuxprobe ~]# cat readit.txt 
 Welcome to linuxprobe.com
[root@linuxprobe ~]# ls -l readme.txt 
 -rw-r--r-- 1 root root 26 Jan 11 00:08 readme.txt
[root@linuxprobe ~]# rm -f readme.txt 
[root@linuxprobe ~]# cat readit.txt 
 cat: readit.txt: No such file or directory</code></pre>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第6章节：存储结构与磁盘划分</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：安装samba服务时packagekit报错解决方法</title>
    <url>/2021/02/12/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E5%AE%89%E8%A3%85samba%E6%9C%8D%E5%8A%A1%E6%97%B6packagekit%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在linux虚拟机Redhat7.0版本系统终端中输入命令：yum install samba，安装samba服务时，在安装过程中，出现以下报错信息：</p>
<a id="more"></a>

<pre><code>Error: initscripts conflicts with redhat-release-server-7.0-1.el7.x86_64
 You could try using --skip-broken to work around the problem
Found 2 pre-existing rpmdb problem(s), &#39;yum check&#39; output follows:
PackageKit-0.8.9-11.el7.x86_64 has missing requires of PackageKit-backend
rhn-check-2.0.2-5.el7.noarch has missing requires of yum-rhn-plugin &gt;= (&#39;0&#39;, &#39;1.6.4&#39;, &#39;1&#39;)</code></pre>
<p>有2个problem，1个error；先解决problem：</p>
<pre><code>（1）在http://rpm.pbone.net/网站中下载PackageKit-yum-0.8.9-11.el7.x86_64.rpm,然后将rpm文件拖入linux系统中，输入命令：rpm -Uvh PackageKit-yum-0.8.9-11.el7.x86_64.rpm，解决第1个problem。
（2）在终端中输入命令：yum install yum-rhn-plugin，解决第2个problem。</code></pre>
<p>再解决initscripts conflicts的error：</p>
<pre><code>首先，先查一下本机的initscripts的版本，有没有更适合自己系统的，输入以下命令：yum list initscripts，

显示以下信息：

Loading mirror speeds from cached hostfile
Installed Packages
initscripts.x86_64                9.49.17-1.el7                @anaconda/7.0
Available Packages
initscripts.x86_64                9.49.53-1.el7_9.1                updates  

说明当前版本是initscripts.x86_64  9.49.17-1.el7   @anaconda/7.0  

可以用更适合系统的initscripts.x86_64   9.49.53-1.el7_9.1版本来替换。

再输入命令：yum list centos-release，看看合适的centos-release版本：

Loading mirror speeds from cached hostfile
Available Packages
centos-release.x86_64               7-9.2009.1.el7.centos                updates

使用以上命令可以知道，最合适的版本是centos-release.x86_64  7-9.2009.1.el7.centos

从http://rpm.pbone.net/网站中分别下载initscripts-9.49.53-1.el7.x86_64.rpm和centos-release-7-9.2009.1.el7.centos.x86_64.rpm，然后输入命令：rpm -e redhat-release-server-7.0-1.el7.x86_64 --nodeps，将有冲突的版本删掉，删除redhat-release以后，不重启机器，马上安装centos-release.x86_64：

[root@linuxprobe Desktop]# rpm -Uvh centos-release-7-9.2009.1.el7.centos.x86_64.rpm
Preparing...                          ################################# [100%]
Updating / installing...
   1:centos-release-7-9.2009.1.el7.cenwarning: /etc/yum.repos.d/CentOS-Base.repo created as /etc/yum.repos.d/CentOS-Base.repo.rpmnew
################################# [100%]
error: unpacking of archive failed on file /usr/share/doc/redhat-release: cpio: rename failed - Is a directory
error: centos-release-7-9.2009.1.el7.centos.x86_64: install failed</code></pre>
<p>安装时出错！提示“/usr/share/doc/redhat-release 失败：cpio: rename 失败 - 是一个目录”</p>
<p>推测：安装centos-release时，这个redhat-release目录碍事了，所以我们手动把它删除掉（注意备份）。</p>
<pre><code>[root@linuxprobe doc]# rm -r /usr/share/doc/redhat-release 
rm：是否删除目录 &quot;/usr/share/doc/redhat-release&quot;？y

如果还是报错，则再在/usr/share目录中删除redhat-release：

[root@linuxprobe share]# rm -r /usr/share/redhat-release 
rm：是否删除目录 &quot;/usr/share/redhat-release&quot;？y

然后再终端中输入命令：rpm -Uvh centos-release-7-9.2009.1.el7.centos.x86_64.rpm：

[root@linuxprobe Desktop]# rpm -Uvh centos-release-7-9.2009.1.el7.centos.x86_64.rpm
Preparing...                          ################################# [100%]
Updating / installing...
  1:centos-release-7-9.2009.1.el7.cenwarning: /etc/yum.repos.d/CentOS-Base.repo created as /etc/yum.repos.d/CentOS-Base.repo.rpmnew
################################# [100%]</code></pre>
<p>到这一步，基本安装samba服务过程中的problem和error都已经解决，但此时如果输入yum install samba命令安装samba服务时，</p>
<p>可能会引起SELinux的报警，因此需要将SELinux关闭；在/etc/selinux/config配置文件中查看SELinux的默认状态。如果是</p>
<p>enforcing，建议赶紧修改为permissive或disabled；SELinux服务的主配置文件中，定义的是SELinux的默认运行状态，可以将其</p>
<p>理解为系统重启后的状态，因此它不会在更改后立即生效。可以使用getenforce命令获得当前SELinux服务的运行模式：</p>
<pre><code>[root@linuxprobe ~]# getenforce 
Enforcing</code></pre>
<p>再用setenforce [0|1]命令修改SELinux当前的运行模式（0为禁用，1为启用）。注意，这种修改只是临时的，在系统重启后就会失效：</p>
<pre><code>[root@linuxprobe ~]# setenforce 0
[root@linuxprobe ~]# getenforce
Permissive</code></pre>
<p>之后在终端中输入：yum install samba，安装samba服务，成功！</p>
<p>具体方法可参考以下链接：</p>
<p><a href="http://www.likecs.com/default/index/show?id=20904">http://www.likecs.com/default/index/show?id=20904</a><br><a href="https://blog.csdn.net/zz24_com/article/details/105127746">https://blog.csdn.net/zz24_com/article/details/105127746</a></p>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>安装samba服务时packagekit报错解决方法</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：用户身份与文件权限</title>
    <url>/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h1 id="1-用户身份与能力"><a href="#1-用户身份与能力" class="headerlink" title="1.用户身份与能力"></a>1.用户身份与能力</h1><p>管理员UID为0：系统的管理员用户。</p>
<p>系统用户UID为1～999： Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会有独立的系统用户负责运行，进而有效控制被破坏范围。</p>
<p>普通用户UID从1000开始：是由管理员创建的用于日常工作的用户。</p>
<a id="more"></a>
<p>一个用户只有一个基本用户组，但是可以有多个扩展用户组，从而满足日常的工作需要。</p>
<p>（1）useradd：用于创建新的用户；默认的用户家目录会被存放在/home目录中，默认的Shell解释器为/bin/bash，而且默认会创建一个与该用户同名的基本用户组。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-d</td>
<td>指定用户的家目录</td>
</tr>
<tr>
<td>-u</td>
<td>指定该用户的默认UID</td>
</tr>
<tr>
<td>-g</td>
<td>指定一个初始的用户基本组（必须已存在）</td>
</tr>
<tr>
<td>-G</td>
<td>指定一个或多个扩展用户组</td>
</tr>
<tr>
<td>-s</td>
<td>指定该用户的默认Shell解释器</td>
</tr>
</tbody></table>
<p>/sbin/nologin，它是终端解释器中的一员，与Bash解释器有着天壤之别。一旦用户的解释器被设置为nologin，则代表该用户不能登录到系统中：</p>
<p>（2）groupadd:用于创建用户组；</p>
<p>（3）usermod：用于修改用户属性；用户的信息保存在/etc/passwd文件中，可以直接用文本编辑器来修改其中的用户参数项目，也可以用usermod命令修改已经创建的用户信息，诸如用户的UID、基本/扩展用户组、默认终端等。  </p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-d -m</td>
<td>参数-m与参数-d连用，可重新指定用户的家目录并自动把旧的数据转移过去</td>
</tr>
<tr>
<td>-g</td>
<td>变更所属用户组</td>
</tr>
<tr>
<td>-G</td>
<td>变更扩展用户组</td>
</tr>
<tr>
<td>-L</td>
<td>锁定用户禁止其登录系统</td>
</tr>
<tr>
<td>-U</td>
<td>解锁用户，允许其登陆系统</td>
</tr>
<tr>
<td>-s</td>
<td>变更默认终端</td>
</tr>
</tbody></table>
<p>（4）passwd：用于修改用户密码、过期时间、认证信息等；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td>锁定用户禁止其登录系统</td>
</tr>
<tr>
<td>-u</td>
<td>解锁用户，允许其登陆系统</td>
</tr>
<tr>
<td>–stdin</td>
<td>允许通过标准输入修改用户密码，如echo “NewPassWord”</td>
</tr>
<tr>
<td>-d</td>
<td>使该用户可用空密码登录系统</td>
</tr>
<tr>
<td>-e</td>
<td>强制用户在下次登录时修改密码</td>
</tr>
<tr>
<td>-S</td>
<td>显示用户的密码是否被锁定，以及密码所采用的加密算法名称</td>
</tr>
</tbody></table>
<p>（5）userdel：用于删除用户；</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-f</td>
<td>强制删除用户</td>
</tr>
<tr>
<td>-r</td>
<td>同时删除用户及用户家目录</td>
</tr>
</tbody></table>
<h1 id="2-文件权限与归属"><a href="#2-文件权限与归属" class="headerlink" title="2.文件权限与归属"></a>2.文件权限与归属</h1><p> -：普通文件；d：目录文件；l：链接文件；b：块设备文件；c：字符设备文件；p：管道文件</p>
<p>对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。</p>
<p>对目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。</p>
<h2 id="2-1-文件的特殊权限"><a href="#2-1-文件的特殊权限" class="headerlink" title="2.1 文件的特殊权限"></a>2.1 文件的特殊权限</h2><p>详细内容可参考：<a href="https://www.cnblogs.com/sparkdev/p/9651622.html%EF%BC%9B">https://www.cnblogs.com/sparkdev/p/9651622.html；</a></p>
<p>（1）SUID：让执行者临时获得命令的所有者的权限；</p>
<p>（2）SGID：目录内新文件所有组，继承原有目录所有组的名称！</p>
<p>1.SUID<br>在 Linux 中，所有账号的密码记录在 /etc/shadow 这个文件中，并且只有 root 可以读写入这个文件：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/1.png" class>

<p>如果另一个普通账号 tester 需要修改自己的密码，就要访问 /etc/shadow 这个文件。但是明明只有 root 才能访问 /etc/shadow 这个文件，这究竟是如何做到的呢？事实上，tester 用户是可以修改 /etc/shadow 这个文件内的密码的，就是通过 SUID 的功能。让我们看看 passwd 程序文件的权限信息：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/2.png" class>

<p>上图红框中的权限信息有些奇怪，owner 的信息为 rws 而不是 rwx。当 s 出现在文件拥有者的 x 权限上时，就被称为 SETUID BITS 或 SETUID ，其特点如下：</p>
<p>-SUID 权限仅对二进制可执行文件有效<br>-如果执行者对于该二进制可执行文件具有 x 的权限，执行者将具有该文件的所有者的权限<br>-本权限仅在执行该二进制可执行文件的过程中有效</p>
<p>下面我们来看 tester 用户是如何利用 SUID 权限完成密码修改的：</p>
<pre><code>(1)tester 用户对于 /usr/bin/passwd 这个程序具有执行权限，因此可以执行 passwd 程序
(2)passwd 程序的所有者为 root
(3)tester 用户执行 passwd 程序的过程中会暂时获得 root 权限
(4)因此 tester 用户在执行 passwd 程序的过程中可以修改 /etc/shadow 文件</code></pre>
<p>但是如果由 tester 用户执行 cat 命令去读取 /etc/shadow 文件确是不行的：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/3.png" class>

<p>原因很清楚，tester 用户没有读 /etc/shadow 文件的权限，同时 cat 程序也没有被设置 SUID。我们可以通过下图来理解这两种情况：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/4.png" class>

<p>如果想让任意用户通过 cat 命令读取 /etc/shadow 文件的内容也是非常容易的，给它设置 SUID 权限就可以了：</p>
<p>$ sudo chmod 4755 /bin/cat</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/5.png" class>

<p>现在 cat 已经具有了 SUID 权限，试试看，是不是已经可以 cat 到 /etc/shadow 的内容了。因为这样做非常不安全，所以赶快通过下面的命令把 cat 的 SUID 权限移除掉：</p>
<p>$ sudo chmod 755 /bin/cat</p>
<p>2.SGID</p>
<p>当 s 标志出现在用户组的 x 权限时称为 SGID。SGID 的特点与 SUID 相同，我们通过 /usr/bin/mlocate 程序来演示其用法。mlocate 程序通过查询数据库文件 /var/lib/mlocate/mlocate.db 实现快速的文件查找。 mlocate 程序的权限如下图所示：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/6.png" class>

<p>很明显，它被设置了 SGID 权限。下面是数据库文件 /var/lib/mlocate/mlocate.db 的权限信息：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/7.png" class>

<p>普通用户 tester 执行 mlocate 命令时，tester 就会获得用户组 mlocate 的执行权限，又由于用户组 mlocate 对 mlocate.db 具有读权限，所以 tester 就可以读取 mlocate.db 了。程序的执行过程如下图所示：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/8.png" class>

<p>除二进制程序外，SGID 也可以用在目录上。当一个目录设置了 SGID 权限后，它具有如下功能：</p>
<pre><code>(1)用户若对此目录具有 r 和 x 权限，该用户能够进入该目录
(2)用户在此目录下的有效用户组将变成该目录的用户组
(3)若用户在此目录下拥有 w 权限，则用户所创建的新文件的用户组与该目录的用户组相同</code></pre>
<p>下面看个例子，创建 testdir 目录，目录的权限设置如下：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/9.png" class>

<p>此时目录 testdir 的 owner 是 nick，所属的 group 为 tester。<br>先创建一个名为 nickfile 的文件：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/10.png" class>

<p>这个文件的权限看起来没有什么特别的。然后给 testdir 目录设置 SGID 权限：</p>
<p>$ sudo chmod 2775 testdir</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/11.png" class>

<p>然后再创建一个文件 nickfile2：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/12.png" class>

<p>新建的文件所属的组为 tester！</p>
<p>总结一下，当 SGID 作用于普通文件时，和 SUID 类似，在执行该文件时，用户将获得该文件所属组的权限。当 SGID 作用于目录时，意义就非常重大了。当用户对某一目录有写和执行权限时，该用户就可以在该目录下建立文件，如果该目录用 SGID 修饰，则该用户在这个目录下建立的文件都是属于这个目录所属的组。</p>
<p>SBIT<br>其实 SBIT 与 SUID 和 SGID 的关系并不大。<br>SBIT 是 the  restricted  deletion  flag  or  sticky  bit 的简称。<br>SBIT 目前只对目录有效，用来阻止非文件的所有者删除文件。比较常见的例子就是 /tmp 目录：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/13.png" class>

<p>权限信息中最后一位 t 表明该目录被设置了 SBIT 权限。SBIT 对目录的作用是：当用户在该目录下创建新文件或目录时，仅有自己和 root 才有权力删除。</p>
<p>设置 SUID、SGID、SBIT 权限<br>以数字的方式设置权限<br>SUID、SGID、SBIT 权限对应的数字如下：</p>
<p>SUID-&gt;4<br>SGID-&gt;2<br>SBIT-&gt;1<br>所以如果要为一个文件权限为 “-rwxr-xr-x” 的文件设置 SUID 权限，需要在原先的 755 前面加上 4，也就是 4755：</p>
<p>$ chmod 4755 filename</p>
<p>同样，可以用 2 和 1 来设置 SGID 和 SBIT 权限。设置完成后分别会用 s, s, t 代替文件权限中的 x。</p>
<p>其实，还可能出现 S 和 T 的情况。S 和 t 是替代 x 这个权限的，但是，如果它本身没有 x 这个权限，添加 SUID、SGID、SBIT 权限后就会显示为大写 S 或大写 T。比如我们为一个权限为 666 的文件添加 SUID、SGID、SBIT 权限：</p>
<img src="/2021/01/25/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/14.png" class>

<p>执行 chmod 7666 nickfile，因为 666 表示 “-rw-rw-rw”，均没有 x 权限，所以最后变成了 “-rwSrwSrwT”。</p>
<p>通过符号类型改变权限</p>
<p>除了使用数字来修改权限，还可以使用符号：</p>
<p>$ chmod u+s testfile # 为 testfile 文件加上 SUID 权限。<br>$ chmod g+s testdir  # 为 testdir 目录加上 SGID 权限。<br>$ chmod o+t testdir  # 为 testdir 目录加上 SBIT 权限。</p>
<p>总结<br>SUID、SGID、SBIT 权限都是为了实现特殊功能而设计的，其目的是弥补 ugo 权限无法实现的一些使用场景。</p>
<h2 id="2-2文件的隐藏属性"><a href="#2-2文件的隐藏属性" class="headerlink" title="2.2文件的隐藏属性"></a>2.2文件的隐藏属性</h2><p>linux文件除了具备一般权限和特殊权限外，还具有隐藏权限；  </p>
<p>1.chattr：用于设置文件的隐藏权限，添加隐藏功能“+参数”，移除隐藏功能“-参数”。  </p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而不能新建或删除文件</td>
</tr>
<tr>
<td>a</td>
<td>仅允许补充（追加）内容，无法覆盖/删除内容（Append Only）</td>
</tr>
<tr>
<td>s</td>
<td>彻底从硬盘中删除，不可恢复（用0填充原文件所在硬盘区域）</td>
</tr>
<tr>
<td>A</td>
<td>不再修改这个文件或目录的最后访问时间（atime）</td>
</tr>
<tr>
<td>b</td>
<td>不再修改文件或目录的存取时间</td>
</tr>
<tr>
<td>u</td>
<td>当删除该文件后依然保留其在硬盘中的数据，方便日后恢复</td>
</tr>
</tbody></table>
<p>2.lsattr：用于显示文件的隐藏权限；</p>
<h2 id="2-3-文件访问控制列表"><a href="#2-3-文件访问控制列表" class="headerlink" title="2.3 文件访问控制列表"></a>2.3 文件访问控制列表</h2><p>一般权限、特殊权限、隐藏权限其实有一个共性—权限是针对某一类用户设置的；如果需要对某个指定的用户进行单独的权限控制，就需要用到文件访问控制列表（ACL);如果针对某个目录设置了ACL，则目录中的文件会继承其ACL；若针对文件设置了ACL，则文件不再继承其所在目录的ACL。</p>
<p>1.setfacl：可以针对单一用户或用户组、单一文件或目录来进行读/写/执行权限的控制。<br>-R：针对目录文件；    -m：针对普通文件；    -b：删除文件的ACL</p>
<pre><code>[root@linuxprobe ~]# setfacl -Rm u:linuxprobe:rwx /root
[root@linuxprobe ~]# su - linuxprobe
Last login: Sat Mar 21 15:45:03 CST 2017 on pts/1
[linuxprobe@linuxprobe ~]$ cd /root
[linuxprobe@linuxprobe root]$ ls
anaconda-ks.cfg Downloads Pictures Public
[linuxprobe@linuxprobe root]$ cat anaconda-ks.cfg
[linuxprobe@linuxprobe root]$ exit</code></pre>
<p>当文件权限的最后一个点（.）变成（+）时，意味着文件设置了ACL。</p>
<p>2.getfacl：用于显示文件的ACL信息；</p>
<h2 id="2-4-su命令与sudo服务"><a href="#2-4-su命令与sudo服务" class="headerlink" title="2.4 su命令与sudo服务"></a>2.4 su命令与sudo服务</h2><p>su命令可以解决切换用户身份的需求，使得当前用户在不退出登录的情况下，顺畅地切换到其他用户；上面的su命令与用户名之间有一个减号（-），这意味着完全切换到新的用户，即把环境变量信息也变更为新用户的相应信息，而不是保留原始的信息。</p>
<p>sudo命令用于给普通用户提供额外的权限来完成原本root管理员才能完成的任务，格式为“sudo [参数] 命令名称”。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td>列出当前用户可执行的命令</td>
</tr>
<tr>
<td>-u</td>
<td>以指定的用户身份执行命令</td>
</tr>
<tr>
<td>-k</td>
<td>清空密码的有效时间，下次执行sudo时需要再次进行密码验证</td>
</tr>
<tr>
<td>-b</td>
<td>在后台执行指定的命令</td>
</tr>
<tr>
<td>-p</td>
<td>更改询问密码的提示语</td>
</tr>
</tbody></table>
<p>配置文件（/etc/sudoers）提供集中的用户管理、权限与主机等参数；只有root管理员才可以使用visudo命令编辑sudo服务的配置文件。  </p>
<pre><code>谁可以使用  允许使用的主机=（以谁的身份）  可执行命令的列表
99 linuxprobe ALL=(ALL) ALL
99 linuxprobe ALL=(ALL) /usr/bin/cat（命令的绝对路径）
99 linuxprobe ALL=NOPASSWD: /usr/sbin/poweroff</code></pre>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第5章节：用户身份与文件权限</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：管道符、重定向与环境变量</title>
    <url>/2021/01/09/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E7%AE%A1%E9%81%93%E7%AC%A6%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="1-输入输出重定向"><a href="#1-输入输出重定向" class="headerlink" title="1.输入输出重定向"></a>1.输入输出重定向</h1><p>输入重定向：是指把文件导入到命令中； 输出重定向：是指把原本要输出到屏幕的数据写入到指定文件中。输出重定向又分为标准输出重定向和错误输出重定向。<br>输入重定向中用到的符号及其作用：</p>
<a id="more"></a>


<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>命令 &lt; 文件</td>
<td>将文件作为命令的标准输入</td>
</tr>
<tr>
<td>命令 &lt;&lt; 分界符（tag）</td>
<td>将开始标记 tag 和结束标记 tag 之间的内容作为输入</td>
</tr>
</tbody></table>
<p>输入重定向中用到的符号及其作用：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>命令 &gt; 文件</td>
<td>将输出重定向到文件（会清空原有数据）</td>
</tr>
<tr>
<td>命令 &gt;&gt; 文件</td>
<td>将输出以追加的方式重定向到文件</td>
</tr>
<tr>
<td>n &gt; 文件</td>
<td>将文件描述符为 n 的文件重定向到文件</td>
</tr>
<tr>
<td>n &gt;&gt; 文件</td>
<td>将文件描述符为 n 的文件以追加的方式重定向到文件</td>
</tr>
<tr>
<td>n &gt;&amp; m</td>
<td>将输出文件 m 和 n 合并</td>
</tr>
<tr>
<td>n &lt;&amp; m</td>
<td>将输入文件 m 和 n 合并</td>
</tr>
<tr>
<td>&lt;&lt; tag</td>
<td>将开始标记 tag 和结束标记 tag 之间的内容作为输入</td>
</tr>
</tbody></table>
<p>注意：文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p>
<h1 id="2-管道命令符"><a href="#2-管道命令符" class="headerlink" title="2. 管道命令符"></a>2. 管道命令符</h1><p>命令符：可以把前一个命令原本要输出到屏幕的数据当作是后一个命令的标准输入；</p>
<h1 id="3-命令行的通配符"><a href="#3-命令行的通配符" class="headerlink" title="3.命令行的通配符"></a>3.命令行的通配符</h1><p>星号（*）：代表匹配零个或多个字符； 问号（？）：代表匹配单个字符； [0-9]:代表匹配0-9之间的单个数字； [abc]:代表匹配a、b、c三个字符中的任意一个；<br>[^…]和[!…]表示匹配不在方括号里面的字符（不包括空字符）；这两种写法是等价的。</p>
<h1 id="4-转义字符"><a href="#4-转义字符" class="headerlink" title="4.转义字符"></a>4.转义字符</h1><p>反斜杠（\）：使反斜杠后面变量称为单纯的字符串；<br>单引号（’’）：转义其中所有的变量为单纯的字符串；<br>双引号（””）:保留其中的变量属性，不尽兴转义处理；<br>反引号（``）:把其中的命令执行后返回结果。</p>
<h1 id="5-环境变量"><a href="#5-环境变量" class="headerlink" title="5.环境变量"></a>5.环境变量</h1><p>变量是计算机系统用于保存可变值得数据类型，变量名称一般都是大写的；环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录、邮件存放位置等。</p>
<p>前面讲过，在 Linux 系统中“一切皆文件”，Linux 命令也不例外。那么，当编辑完成 Linux 命令并回车后，系统底层到底发生了什么事情呢？</p>
<p>简单来说，Linux 命令的执行过程分为如下 4 个步骤。</p>
<pre><code>1) 判断路径
    判断用户是否以绝对路径或相对路径的方式输入命令（如 /bin/ls），如果是的话直接执行。

2) 检查别名
    Linux 系统会检查用户输入的命令是否为“别名命令”。要知道，通过 alias 命令是可以给现有命令自定义别名的，即用一个自定义的命令名称来替换原本的命令名称。

    例如，我们经常使用的 rm 命令，其实就是 rm -i 这个整体的别名：
    [root@localhost ~]# alias rm
    alias rm=&#39;rm -i&#39;

    这使得当使用 rm 命令删除指定文件时，Linux 系统会要求我们再次确认是否执行删除操作。例如：
    [root@localhost ~]# rm a.txt &lt;-- 假定当前目录中已经存在 a.txt 文件
    rm: remove regular file &#39;a.txt&#39;? y  &lt;-- 手动输入 y，即确定删除
    [root@localhost ~]#

    这里可以使用 unalias 命令，将 Linux 系统设置的 rm 别名删除掉，执行命令如下：
    [root@localhost ~]# alias rm
    alias rm=&#39;rm -i&#39;
    [root@localhost ~]# unalias rm
    [root@localhost ~]# rm a.txt
    [root@localhost ~]#  &lt;--直接删除，不再询问


    注意，这里仅是为了演示 unalisa 的用法，建议读者删除 rm 别名之后，再手动添加到系统中，执行如下命令即可再次成功添加：
    [root@localhost ~]# alias rm=&#39;rm -i&#39;

3) 判断是内部命令还是外部命令
    Linux命令行解释器（又称为 Shell）会判断用户输入的命令是内部命令还是外部命令。其中，内部命令指的是解释器内部的命令，会被直接执行；而用户通常输入的命令都是外部命令，这些命令交给步骤四继续处理。
    内部命令由 Shell 自带，会随着系统启动，可以直接从内存中读取；而外部命令仅是在系统中有对应的可执行文件，执行时需要读取该文件。

    判断一个命令属于内部命令还是外部命令，可以使用 type 命令实现。例如：
    [root@localhost ~]# type pwd
    pwd is a shell builtin  &lt;-- pwd是内部命令
    [root@localhost ~]# type top
    top is /usr/bin/top  &lt;-- top是外部命令

4) 查找外部命令对应的可执行文件
    当用户执行的是外部命令时，系统会在指定的多个路径中查找该命令的可执行文件，而定义这些路径的变量，就称为 PATH 环境变量，其作用就是告诉 Shell 待执行命令的可执行文件可能存放的位置，也就是说，Shell 会在 PATH 变量包含的多个路径中逐个查找，直到找到为止（如果找不到，Shell 会提供用户“找不到此命令”）</code></pre>
<p>自己创建的变量不具有全局性，作用范围有限，默认情况下不能被其他用户使用，因此，可通过export命令（如：export WORKDIR）将其提升为全局变量，这样其他用户也可以使用了！</p>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第3章节：管道符、重定向与环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title>linux虚拟机外网网络访问设置指南</title>
    <url>/2021/02/07/linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%96%E7%BD%91%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>要达到的效果就是在Linux虚拟机中可以上网：ping <a href="http://www.baidu.com/">http://www.baidu.com</a></p>
<p>VMware中安装完 redhat7 后， 默认初始配置如下：</p>
<a id="more"></a>

<h1 id="1-VMware-网络配置"><a href="#1-VMware-网络配置" class="headerlink" title="1.VMware 网络配置"></a>1.VMware 网络配置</h1><p>（编辑 –&gt; 虚拟网络编辑器）查看</p>
<p>默认配置为： (这些配置都不需要发生变更， 看看就好)</p>
<pre><code>子网IP：192.168.154.0

子网掩码 : 255.255.255.0

可设置的IP网段为： 192.168.154.128 ~ 254

&#123;% asset_img 1.jpg %&#125;

点开 NAT设置可以看到 GATEWAY : 192.168.154.2:</code></pre>
<img src="/2021/02/07/linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%96%E7%BD%91%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/2.jpg" class>

<p>下面介绍 redhat 本身配置m修改配置参数如下：</p>
<p>注意各个参数与第一步 VMware 中的默认配置的联系 :</p>
<pre><code>BOOTPROTO ： dhcp --&gt; static （静态IP）

ONBOOT : no --&gt; YES (开机自动连接网络)

IPADDR : 192.168.154.128 ~ 254 之间即可

NETMASK : 子网， 与 VMware 默认一致

GATEWAY : 网关， 与VMware 默认一致

DNS1 : 首选 DNS, 不配置会出现外网不通， 只能与内网互通的问题.

这里DNS要说一下的是，其他资料上有说要跟本机上网的DNS一致，还有说跟网关一致，或者改成8.8.8.8，都试过，ping www.baidu.com 都可以，不同的机器可能有不同，希望可以共同探讨。

NM_CONTROLLED : “NM_CONTROLLED=no”表示该接口将通过该配置文件进行设置，而不是通过网络管理器进行管理。“ONBOOT=yes”告诉我们，系统将在启动时开启该接口。</code></pre>
<p>编辑/etc/sysconfig/network-scipts/网卡名称：</p>
<img src="/2021/02/07/linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%96%E7%BD%91%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/3.jpg" class>

<img src="/2021/02/07/linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%96%E7%BD%91%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/4.jpg" class>

<img src="/2021/02/07/linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%96%E7%BD%91%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/5.jpg" class>

<p>重启网络服务命令： systemctl restart network；</p>
<img src="/2021/02/07/linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%96%E7%BD%91%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/6.jpg" class>
















]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>linux虚拟机外网网络访问设置指南</tag>
      </tags>
  </entry>
  <entry>
    <title>liunx就该这么学：vim编辑器与Shell命令脚本</title>
    <url>/2021/01/09/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9Avim%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8EShell%E5%91%BD%E4%BB%A4%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="1-Vim文本编辑器"><a href="#1-Vim文本编辑器" class="headerlink" title="1.Vim文本编辑器"></a>1.Vim文本编辑器</h1><p>注意：在linux系统中一切都是文件，而配置一个服务就是在修改其配置文件的参数；</p>
<p>Vim编辑器有三种模式：</p>
<pre><code>（1）命令模式：控制光标移动，可对文本进行复制、粘贴、删除和查找等操作（开机后默认进入命令模式）；
（2）输入模式：正常的文本录入（按a、i、o从命令模式进入输入模式，按Esc键退出输入模式）；
             a键和i键分别是在光标后一位和光标当前位置切换到输入模式，而o键则是在光标的下面再新建一个空行。
（3）末行模式：保存或退出文档，以及设置编辑环境（按：键进入末行模式，按Esc键退出输入模式）；</code></pre>
<a id="more"></a>
<p>命令模式中常用的命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>dd</td>
<td>删除（剪切）光标所在整行</td>
</tr>
<tr>
<td>5dd</td>
<td>删除（剪切）从光标处开始的5行</td>
</tr>
<tr>
<td>yy</td>
<td>复制光标所在整行</td>
</tr>
<tr>
<td>5yy</td>
<td>复制从光标处开始的5行</td>
</tr>
<tr>
<td>n</td>
<td>显示搜索命令定位到的下一个字符串</td>
</tr>
<tr>
<td>N</td>
<td>显示搜索命令定位到的上一个字符串</td>
</tr>
<tr>
<td>u</td>
<td>撤销上一步的操作</td>
</tr>
<tr>
<td>p</td>
<td>将之前删除（dd）或复制（yy）过的数据粘贴到光标后面</td>
</tr>
</tbody></table>
<p>末行模式中常用的命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>:w</td>
<td>保存</td>
</tr>
<tr>
<td>:q</td>
<td>退出</td>
</tr>
<tr>
<td>:q!</td>
<td>强制退出（放弃对文档的修改内容）</td>
</tr>
<tr>
<td>:wq!</td>
<td>强制保存退出</td>
</tr>
<tr>
<td>:set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>不显示行号</td>
</tr>
<tr>
<td>:命令</td>
<td>执行该命令</td>
</tr>
<tr>
<td>:整数</td>
<td>跳转到该行</td>
</tr>
<tr>
<td>:s/one/two</td>
<td>将当前光标所在行的第一个one替换成two</td>
</tr>
<tr>
<td>:s/one/two/g</td>
<td>将当前光标所在行的所有one替换成two</td>
</tr>
<tr>
<td>:%s/one/two/g</td>
<td>将全文中的所有one替换成two</td>
</tr>
<tr>
<td>?字符串</td>
<td>在文本中从下至上搜索该字符串</td>
</tr>
<tr>
<td>/字符串</td>
<td>在文本中从上至下搜索该字符串</td>
</tr>
</tbody></table>
<h1 id="2-配置主机名称"><a href="#2-配置主机名称" class="headerlink" title="2.配置主机名称"></a>2.配置主机名称</h1><p>1.使用Vim编辑器修改“/etc/hostname”中的主机名称，将原始主机名称删除后追加“想加入的主机名称”，修改完毕后记得在末行模式下输入：wq！命令保存文档；<br>2.使用hostname命令检查是否修改成功；  </p>
<p>注意：修改完毕后，有时主机名称不会立即同步到系统中，可重启虚拟机；  </p>
<h1 id="3-配置网卡信息"><a href="#3-配置网卡信息" class="headerlink" title="3.配置网卡信息"></a>3.配置网卡信息</h1><p>网卡IP地址配置的是否正确是两台服务器是否可以相互通信的前提；  </p>
<p>网卡信息配置步骤：  </p>
<pre><code>1.cd /etc/sysconfig/network-scripts （存放着网卡的配置文件)；
2.用Vim编辑器修改网卡文件ifcfg-eno16777728（每台仪器的网卡名称不一样，需要用ifconfig命令进行查询）；  

    -设备类型：TYPE=Ethernet
    -地址分配模式：BOOTPROTO=static
    -网卡名称：NAME=eno16777728
    -设备名称：DEVICE=eno1677728（不输入设备名称，在重启网卡时有报错，不太清楚原因）
    -是否启动：ONBOOT=yes
    -IP地址：IPADDR=192.168.10.10
    -子网掩码：NETMASK=255.255.255.0
    -网关地址：GATEWAY=192.168.10.1
    -DNS地址：DNS1=192.168.10.1

3.重启网络服务并测试网络是否联通：systemctl restart network     ping 192.168.10.10</code></pre>
<h1 id="4-配置Yum软件仓库"><a href="#4-配置Yum软件仓库" class="headerlink" title="4.配置Yum软件仓库"></a>4.配置Yum软件仓库</h1><p>配置YUM软件仓库的步骤如下：</p>
<pre><code>1.cd /etc/yum.repos.d/ （存放Yum软件仓库的配置文件）；
2.vim rhel7.repo的配置文件（文件名称随意，但后缀必须为.repo），在配置文件中写入下方的配置参数：
    [rhel7] （Yum软件仓库唯一标识符，避免与其他仓库冲突）
    name=rhel7 （Yum软件仓库的名称描述，易于识别仓库用处）
    baseurl=file:///media/cdrom （提供的方式包括FTP（ftp://..）、HTTP（http://..）、本地（file:///..））
    enabled=1 （设置此源是否可用；1为可用，0为禁用）
    gpgcheck=0 （设置此源是否校验文件；1为校验，0为不校验）
3.挂载光盘，并把光盘挂载信息写入到/etc/fstab文件中；
4.使用“yum install httpd -y”检查Yum软件仓库是否可用</code></pre>
<h1 id="5-编写Shell脚本"><a href="#5-编写Shell脚本" class="headerlink" title="5.编写Shell脚本"></a>5.编写Shell脚本</h1><p>Shell脚本内容可分为三部分：</p>
<pre><code>1.第一行的#！/bin/bash：用于告诉系统用哪种Shell解释器来执行该脚本；
2.第二行的#：是注释信息，用于对脚本功能和某些命令的介绍信息；
3.第三行之后的内容是可执行语句。</code></pre>
<h2 id="5-1-接受用户参数"><a href="#5-1-接受用户参数" class="headerlink" title="5.1 接受用户参数"></a>5.1 接受用户参数</h2><p>Shell脚本语言内置了用于接收参数的变量，变量之间使用空格间隔；如：$0对应当前Shell脚本名称，$#对应总共几个参数，$*对应所有位置的参数值，$？对应显示上一次命令的执行返回值，而$1、$2、$3…分别对应第N个位置的参数值。</p>
<h2 id="5-2-判断用户的参数"><a href="#5-2-判断用户的参数" class="headerlink" title="5.2 判断用户的参数"></a>5.2 判断用户的参数</h2><p>条件测试语句格式： [ 条件表达式 ]  两边各有一个空格</p>
<p>条件测试语句分为4种：文件测试语句、逻辑测试语句、整数值比较语句、字符串比较语句。</p>
<p>文件测试所用参数：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-d</td>
<td>文件是否为目录</td>
</tr>
<tr>
<td>-e</td>
<td>文件是否存在</td>
</tr>
<tr>
<td>-f</td>
<td>文件是否为一般文件</td>
</tr>
<tr>
<td>-r</td>
<td>当前用户是否有权限读取</td>
</tr>
<tr>
<td>-w</td>
<td>当前用户是否有权限写入</td>
</tr>
<tr>
<td>-x</td>
<td>当前用户是否有权限执行</td>
</tr>
</tbody></table>
<pre><code>[root@linuxprobe ~]# [ -d /etc/fstab ]
[root@linuxprobe ~]# echo $?
1（返回值如果为0，表示目录存在；为非零值，则表示目录不存在）</code></pre>
<p>逻辑语句运算符号：与（&amp;&amp;）、或（||）、非（！）；</p>
<p>&amp;&amp;：表示当前面的命令执行成功后才能执行后面的命令；<br>||：表示当前面的命令执行失败后才能执行后面的命令；<br>！：表示把条件测试中的判断结果取相反值。</p>
<p>整数比较运算符仅是对数字的操作，不能将数字与字符串、文件等内容一起操作，而且不能想当然地使用日常生活中的等号、大于号、小于号等来判断。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>是否等于</td>
</tr>
<tr>
<td>-ne</td>
<td>是否不等于</td>
</tr>
<tr>
<td>-gt</td>
<td>是否大于</td>
</tr>
<tr>
<td>-lt</td>
<td>是否小于</td>
</tr>
<tr>
<td>-le</td>
<td>是否等于或小于</td>
</tr>
<tr>
<td>-ge</td>
<td>是否大于或等于</td>
</tr>
</tbody></table>
<pre><code>[root@linuxprobe ~]# [ 10 -gt 10 ]
[root@linuxprobe ~]# echo $?
1
[root@linuxprobe ~]# [ 10 -eq 10 ]
[root@linuxprobe ~]# echo $?
0</code></pre>
<p>字符串比较语句用于判断测试字符串是否为空值，或两个字符串是否相同。</p>
<p>| 操作符 | 作用 |<br>| = | 比较字符串内容是否相同 |<br>| ！= | 比较字符串内容是否不同 |<br>| -z |  判断字符串内容是否为空 |</p>
<h2 id="5-3-流程控制语句"><a href="#5-3-流程控制语句" class="headerlink" title="5.3 流程控制语句"></a>5.3 流程控制语句</h2><p>1.if条件测试语句：可以让脚本根据实际情况自动执行相应的命令。从技术角度来讲，if语句分为单分支结构、双分支结构、多分支结构；</p>
<pre><code>（1）
if 条件测试操作
then 命令序列
fi

（2）
if 条件测试操作
then 命令序列1
else 命令序列2
fi

（2）
if 条件测试操作
then 命令序列1
elif 条件测试操作2
    then 命令序列2
else 命令序列2
fi</code></pre>
<p>2.for条件循环语句：允许脚本一次性读取多个信息，然后逐一对信息进行操作处理，当要处理的数据有范围时，使用for循环语句再适合不过了。</p>
<pre><code>for 变量名 in 取值列表
do
命令序列
done</code></pre>
<p>3.while条件循环语句：通过判断条件测试的真假来决定是否继续执行命令，若条件为真就继续执行，为假就结束循环。</p>
<pre><code>while 条件测试操作
do
    命令序列
done</code></pre>
<p>4.case条件测试语句：case语句是在多个范围内匹配数据，若匹配成功则执行相关命令并结束整个条件测试；而如果数据不在所列出的范围内，则会去执行星号（*）中所定义的默认命令。</p>
<pre><code>case 变量值 in
模式1）
    命令序列1
    ;;
模式2）
    命令序列2
    ;;
    ……
*）
    默认命令序列
esac</code></pre>
<p>5.计划任务服务程序</p>
<p>分为一次性计划任务和长期性计划任务；</p>
<p>一次性计划任务：写成“ at 时间 ”的形式，如果想要查看已设置好但还未执行的一次性计划任务，可以使用“at -l”命令；要想将其删除，可以用“atrm 任务序号”。</p>
<p>长期性计划任务：默认启用crond服务；创建、编辑计划任务的命令为“crontab -e”，查看当前计划任务的命令为“crontab -l”，删除某条计划任务的命令为“crontab -r”。口诀：“分、时、日、月、星期 命令”</p>
<p>注意：<br>（1）在crond服务的计划任务参数中，所有命令一定要用绝对路径的方式来写，如果不知道绝对路径，请用whereis命令进行查询。<br>（2）计划任务中的“分”字段必须有数值，绝对不能为空或是*号，而“日”和“星期”字段不能同时使用，否则就会发生冲突。</p>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第4章节：vim编辑器与Shell命令脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>图片加载命令</title>
    <url>/2020/12/07/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<img src="/2020/12/07/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%91%BD%E4%BB%A4/114.jpg" class>
]]></content>
  </entry>
  <entry>
    <title>用hexo和github免费创建自己的博客</title>
    <url>/2020/12/06/%E7%94%A8hexo%E5%92%8Cgithub%E5%85%8D%E8%B4%B9%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="1-安装Nodejs"><a href="#1-安装Nodejs" class="headerlink" title="1.安装Nodejs"></a>1.安装Nodejs</h2><p>官方网站: <a href="https://nodejs.org/">https://nodejs.org</a>, 安装步骤非常简单，一直next，下一步就可以了，默认安装就行。</p>
<h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h2><p>官方网站：<a href="https://git-scm.com/downloads%EF%BC%8C">https://git-scm.com/downloads，</a> 然后我们选择windows版本的下载，安装也是一直点下一步，安装官方默认的来就行，<br>tips：这个Git Bash下载下来就相当于Linux中的终端窗口了，以后我们就用这个东东来打开终端。</p>
<a id="more"></a>
<h2 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h2><p>新建一个文件夹，比如我这里建了blog；打开你的文件夹，然后在空白处点鼠标的右键，选择 ==Git Bash Here==；<br>看看 node，npm是否安装成功，没有成功的就重新安装node：<br>node -v    #查看node版本<br>npm -v    #查看npm版本<br>我们需要先来安装个cnpm提高速度，以后下载什么东西都用cnpm，在上面终端继续输入：<br>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a><br>测试cnpm-成功:<br>cnpm -v    #查看cnpm版本<br>完成之后安装hexo：<br>cnpm install -g hexo-cli    #安装hexo框架<br>验证是否安装成功：<br>hexo -v    #查看hexo版本<br>用pwd命令查看当前路径，然后新建文件夹blog1：<br>mkdir blog1    #创建blog1目录<br>cd blog1     #进入blog1目录目录<br>hexo init     #生成博客 初始化博客（用Git Bash运行）<br>hexo s    #启动本地博客服务<br><a href="http://localhost:4000/">http://localhost:4000/</a>    #本地访问地址<br>hexo n “我的第一篇文章” #创建新的文章 </p>
<h2 id="4-返回blog目录"><a href="#4-返回blog目录" class="headerlink" title="4.返回blog目录"></a>4.返回blog目录</h2><p>hexo clean #清理<br>hexo g #生成</p>
<h2 id="5-将博客部署到GitHub上"><a href="#5-将博客部署到GitHub上" class="headerlink" title="5.将博客部署到GitHub上"></a>5.将博客部署到GitHub上</h2><p>在Github创建一个新的仓库 YourGithubName.github.io<br>然后输入cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件</p>
<h2 id="6-配置-config-yml"><a href="#6-配置-config-yml" class="headerlink" title="6.配置_config.yml"></a>6.配置_config.yml</h2><pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
      type: git
     repo: https://github.com/YourGithubName/YourGithubName.github.io.git
      branch: master</code></pre>
<p>win10 记得在 hexo d 之前输入以下命令：<br>git config –global user.email “xxx”<br>git config –global user.name “xxx”<br>然后用hexo d命令将博客部署到Github仓库里<br><a href="https://yourgithubname.github.io/">https://YourGithubName.github.io/</a>  #访问这个地址可以查看博客<br>注：<br>如果在输入hexo d命令时，提示有以下报错：ERROR Deployer not found: git<br>则在hexo的文件目录内输入以下命令：npm install –save hexo-deployer-git，之后再次输入hexo d命令即可</p>
<h2 id="7-安装主题"><a href="#7-安装主题" class="headerlink" title="7.安装主题"></a>7.安装主题</h2><p>下载yilia主题到本地：git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia<br>修改hexo根目录下的 _config.yml 文件 ： theme: yilia<br>hexo c    #清理一下<br>hexo g    #生成<br>hexo d    #部署到远程Github仓库<br><a href="https://yourgithubname.github.io/">https://YourGithubName.github.io/</a>  #查看博客</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学-13：使用Bind提供域名解析服务</title>
    <url>/2021/02/13/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-13%EF%BC%9A%E4%BD%BF%E7%94%A8Bind%E6%8F%90%E4%BE%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="1-DNS域名解析服务"><a href="#1-DNS域名解析服务" class="headerlink" title="1.DNS域名解析服务"></a>1.DNS域名解析服务</h1><p>DNS：Domain Name System，域名系统。</p>
<a id="more"></a>

<p>主服务器：在特定区域内具有唯一性，负责维护该区域内的域名与IP地址之间的对应关系。</p>
<p>从服务器：从主服务器中获得域名与IP地址的对应关系并进行维护，以防主服务器宕机等情况。</p>
<p>缓存服务器：通过向其他域名解析服务器查询获得域名与IP地址的对应关系，并将经常查询的域名信息保存到服务器本地，以此来提高重复查询时的效率。</p>
<p>在执行用户发起的域名查询请求时，具有递归查询和迭代查询两种方式。所谓递归查询，是指DNS服务器在收到用户发起的请求时，必须向用户返回一个准确的查询结果。如果DNS服务器本地没有存储与之对应的信息，则该服务器需要询问其他服务器，并将返回的查询结果提交给用户。而迭代查询则是指，DNS服务器在收到用户发起的请求时，并不直接回复查询结果，而是告诉另一台DNS服务器的地址，用户再向这台DNS服务器提交请求，这样依次反复，直到返回查询结果。</p>
<h1 id="2-安装Bind服务程序"><a href="#2-安装Bind服务程序" class="headerlink" title="2.安装Bind服务程序"></a>2.安装Bind服务程序</h1><p>BIND：Berkeley Internet Name Domain，伯克利因特网名称域。</p>
<p>chroot：俗称牢笼机制。</p>
<pre><code>[root@linuxprobe ~]# yum install bind-chroot</code></pre>
<p>在bind服务程序中有下面这三个比较关键的文件：</p>
<pre><code>主配置文件（/etc/named.conf）：只有58行，而且在去除注释信息和空行之后，实际有效的参数仅有30行左右，这些参数用来定义bind服务程序的运行。

区域配置文件（/etc/named.rfc1912.zones）：用来保存域名和IP地址对应关系的所在位置。类似于图书的目录，对应着每个域和相应IP地址所在的具体位置，当需要查看或修改时，可根据这个位置找到相关文件。

数据配置文件目录（/var/named）：该目录用来保存域名和IP地址真实对应关系的数据配置文件。</code></pre>
<p>在Linux系统中，bind服务程序的名称为named。首先需要在/etc目录中找到该服务程序的主配置文件，然后把第11行和第17行的地址均修改为any，分别表示服务器上的所有IP地址均可提供DNS域名解析服务，以及允许所有人对本服务器发送DNS查询请求。这两个地方一定要修改准确。</p>
<pre><code> [root@linuxprobe ~]# vim /etc/named.conf
 1 //
 2 // named.conf
 3 //
 4 // Provided by Red Hat bind package to configure the ISC BIND named(8) DNS
 5 // server as a caching only nameserver (as a localhost DNS resolver only).
 6 //
 7 // See /usr/share/doc/bind*/sample/ for example named configuration files.
 8 //
 9 
 10 options &#123;
 11 listen-on port 53 &#123; any; &#125;;
 12 listen-on-v6 port 53 &#123; ::1; &#125;;
 13 directory &quot;/var/named&quot;;
 14 dump-file &quot;/var/named/data/cache_dump.db&quot;;
 15 statistics-file &quot;/var/named/data/named_stats.txt&quot;;
 16 memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;
 17 allow-query &#123; any; &#125;;</code></pre>
<h2 id="2-1正向解析实验"><a href="#2-1正向解析实验" class="headerlink" title="2.1正向解析实验"></a>2.1正向解析实验</h2><p>正向解析是指根据域名（主机名）查找到对应的IP地址。</p>
<p>第1步：编辑区域配置文件。该文件中默认已经有了一些无关紧要的解析参数，旨在让用户有一个参考。我们可以将下面的参数添加到区域配置文件的最下面，当然，也可以将该文件中的原有信息全部清空，而只保留自己的域名解析信息：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/named.rfc1912.zones
zone &quot;linuxprobe.com&quot; IN &#123;
type master;
file &quot;linuxprobe.com.zone&quot;;
allow-update &#123;none;&#125;;
&#125;;</code></pre>
<p>第2步：编辑数据配置文件。我们可以从/var/named目录中复制一份正向解析的模板文件（named.localhost），然后把域名和IP地址的对应数据填写数据配置文件中并保存。在复制时记得加上-a参数，这可以保留原始文件的所有者、所属组、权限属性等信息，以便让bind服务程序顺利读取文件内容：</p>
<pre><code>[root@linuxprobe ~]# cd /var/named/
[root@linuxprobe named]# ls -al named.localhost
-rw-r-----. 1 root named 152 Jun 21 2007 named.localhost
[root@linuxprobe named]# cp -a named.localhost linuxprobe.com.zone</code></pre>
<img src="/2021/02/13/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-13%EF%BC%9A%E4%BD%BF%E7%94%A8Bind%E6%8F%90%E4%BE%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1/1.png" class>

<p>在保存并退出后文件后记得重启named服务程序，让新的解析数据生效:</p>
<pre><code>[root@linuxprobe named]# vim linuxprobe.com.zone
[root@linuxprobe named]# systemctl restart named</code></pre>
<p>第3步：检验解析结果;为了检验解析结果，一定要先把Linux系统网卡中的DNS地址参数修改成本机IP地址，这样就可以使用由本机提供的DNS查询服务了。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/sysconfig/network-scripts/ifcfg-eno16777728（网卡名称）
TYPE=Ethernet
BOOTPROTO=none
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
NAME=eno16777728
UUID=f6b8c6f1-3067-47f6-984e-3d0a1f4d7c23
ONBOOT=yes
IPADDR0=192.168.10.10
GATEWAY0=192.168.10.2
PREFIX0=24
HWADDR=00:0C:29:2B:CC:85
DNS=192.168.10.10
……</code></pre>
<p>nslookup命令用于检测能否从DNS服务器中查询到域名与IP地址的解析记录，进而更准确地检验DNS服务器是否已经能够为用户提供服务。</p>
<pre><code>[root@linuxprobe ~]# systemctl restart network
[root@linuxprobe ~]# nslookup
&gt; www.linuxprobe.com
Server: 127.0.0.1
Address: 127.0.0.1#53
Name: www.linuxprobe.com
Address: 192.168.10.10
&gt; bbs.linuxprobe.com
Server: 127.0.0.1
Address: 127.0.0.1#53
Name: bbs.linuxprobe.com
Address: 192.168.10.20</code></pre>
<h2 id="2-2反向解析实验"><a href="#2-2反向解析实验" class="headerlink" title="2.2反向解析实验"></a>2.2反向解析实验</h2><p>反向解析：将用户提交的IP地址解析为对应的域名信息。</p>
<p>第1步：编辑区域配置文件。除了不要写错格式之外，还需要记住此处定义的数据配置文件名称，因为一会儿还需要在/var/named目录中建立与其对应的同名文件。反向解析是把IP地址解析成域名格式，因此在定义zone（区域）时应该要把IP地址反写，比如原来是192.168.10.0，反写后应该就是10.168.192，而且只需写出IP地址的网络位即可。把下列参数添加至正向解析参数的后面。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/named.rfc1912.zones
zone &quot;linuxprobe.com&quot; IN &#123;
type master;
file &quot;linuxprobe.com.zone&quot;;
allow-update &#123;none;&#125;;
&#125;;
zone &quot;10.168.192.in-addr.arpa&quot; IN &#123;
type master;
file &quot;192.168.10.arpa&quot;;
&#125;;</code></pre>
<p>第2步：编辑数据配置文件。首先从/var/named目录中复制一份反向解析的模板文件（named.loopback），然后把下面的参数填写到文件中。其中，IP地址仅需要写主机位！</p>
<img src="/2021/02/13/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-13%EF%BC%9A%E4%BD%BF%E7%94%A8Bind%E6%8F%90%E4%BE%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1/2.png" class>

<pre><code>[root@linuxprobe named]# cp -a named.loopback 192.168.10.arpa
[root@linuxprobe named]# vim 192.168.10.arpa</code></pre>
<img src="/2021/02/13/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-13%EF%BC%9A%E4%BD%BF%E7%94%A8Bind%E6%8F%90%E4%BE%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1/3.png" class>

<pre><code>[root@linuxprobe named]# systemctl restart named</code></pre>
<p>第3步：检验解析结果。在前面的正向解析实验中，已经把系统网卡中的DNS地址参数修改成了本机IP地址，因此可以直接使用nslookup命令来检验解析结果，仅需输入IP地址即可查询到对应的域名信息。</p>
<pre><code>[root@linuxprobe ~]# nslookup
&gt; 192.168.10.10
Server: 127.0.0.1
Address: 127.0.0.1#53
10.10.168.192.in-addr.arpa name = ns.linuxprobe.com.
10.10.168.192.in-addr.arpa name = www.linuxprobe.com.
10.10.168.192.in-addr.arpa name = mail.linuxprobe.com.
&gt; 192.168.10.20
Server: 127.0.0.1
Address: 127.0.0.1#53
20.10.168.192.in-addr.arpa name = bbs.linuxprobe.com.</code></pre>
<h1 id="3-部署从服务器"><a href="#3-部署从服务器" class="headerlink" title="3.部署从服务器"></a>3.部署从服务器</h1><p>在本实验中，主服务器与从服务器分别使用的操作系统和IP地址如下：</p>
<table>
<thead>
<tr>
<th>主机名称</th>
<th>操作系统</th>
<th>IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>主服务器</td>
<td>RHEL 7</td>
<td>192.168.10.10</td>
</tr>
<tr>
<td>从服务器</td>
<td>RHEL 7</td>
<td>192.168.10.20</td>
</tr>
</tbody></table>
<p>第1步：在<strong>主服务器</strong>的区域配置文件中允许该从服务器的更新请求，即修改allow-update {允许更新区域信息的主机地址;};参数，然后重启主服务器的DNS服务程序。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/named.rfc1912.zones
zone &quot;linuxprobe.com&quot; IN &#123;
type master;
file &quot;linuxprobe.com.zone&quot;;
allow-update &#123; 192.168.10.20; &#125;;
&#125;;
zone &quot;10.168.192.in-addr.arpa&quot; IN &#123;
type master;
file &quot;192.168.10.arpa&quot;;
allow-update &#123; 192.168.10.20; &#125;;
&#125;;
[root@linuxprobe ~]# systemctl restart named</code></pre>
<p>第2步：在从服务器终端中输入命令：yum install bind-chroot，安装bind服务程序；再根据上面步骤编辑配置文件vim /etc/named.conf；</p>
<p>第3步：安装完之后，在<strong>从服务器</strong>中填写主服务器的IP地址与要抓取的区域信息，然后重启服务。注意此时的服务类型应该是slave（从），而不再是master（主）。masters参数后面应该为主服务器的IP地址，而且file参数后面定义的是同步数据配置文件后要保存到的位置，稍后可以在该目录内看到同步的文件。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/named.rfc1912.zones
zone &quot;linuxprobe.com&quot; IN &#123;
type slave;
masters &#123; 192.168.10.10; &#125;;
file &quot;slaves/linuxprobe.com.zone&quot;;
&#125;;
zone &quot;10.168.192.in-addr.arpa&quot; IN &#123;
type slave;
masters &#123; 192.168.10.10; &#125;;
file &quot;slaves/192.168.10.arpa&quot;;
&#125;;
[root@linuxprobe ~]# systemctl restart named</code></pre>
<p>第4步：检验解析结果。当<strong>从服务器</strong>的DNS服务程序在重启后，一般就已经自动从主服务器上同步了数据配置文件，而且该文件默认会放置在区域配置文件中所定义的目录位置（/var/named/slaves）中。</p>
<p>第5步：随后在终端中输入命令：nmtui，修改从服务器的网络参数，把DNS地址参数修改成192.168.10.20，这样即可使用<strong>从服务器</strong>自身提供的DNS域名解析服务。最后就可以使用nslookup命令顺利看到解析结果了。</p>
<pre><code>[root@linuxprobe ~]# cd /var/named/slaves
[root@linuxprobe slaves]# ls 
192.168.10.arpa linuxprobe.com.zone
[root@linuxprobe slaves]# nslookup
&gt; www.linuxprobe.com
Server: 192.168.10.20
Address: 192.168.10.20#53
Name: www.linuxprobe.com
Address: 192.168.10.10
&gt; 192.168.10.10
Server: 192.168.10.20
Address: 192.168.10.20#53
10.10.168.192.in-addr.arpa name = www.linuxprobe.com.</code></pre>
<h1 id="4-安全的加密传输"><a href="#4-安全的加密传输" class="headerlink" title="4.安全的加密传输"></a>4.安全的加密传输</h1><table>
<thead>
<tr>
<th>主机名称</th>
<th>操作系统</th>
<th>IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>主服务器</td>
<td>RHEL 7</td>
<td>192.168.10.10</td>
</tr>
<tr>
<td>从服务器</td>
<td>RHEL 7</td>
<td>192.168.10.20</td>
</tr>
</tbody></table>
<p>在从服务器上配妥bind服务程序并重启后，即可看到从主服务器中获取到的数据配置文件。</p>
<pre><code>[root@linuxprobe ~]# ls -al /var/named/slaves/
total 12
drwxrwx---. 2 named named 54 Jun 7 16:02 .
drwxr-x---. 6 root named 4096 Jun 7 15:58 ..
-rw-r--r--. 1 named named 432 Jun 7 16:02 192.168.10.arpa
-rw-r--r--. 1 named named 439 Jun 7 16:02 linuxprobe.com.zone
[root@linuxprobe ~]# rm -rf /var/named/slaves/*</code></pre>
<p>第1步：在<strong>主服务器</strong>中生成密钥。dnssec-keygen命令用于生成安全的DNS服务密钥，其格式为“dnssec-keygen [参数]”，常用的参数以及作用如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>指定加密算法，包括RSAMD5（RSA）、RSASHA1、DSA、NSEC3RSASHA1、NSEC3DSA等</td>
</tr>
<tr>
<td>-b</td>
<td>密钥长度（HMAC-MD5的密钥长度在1~512位之间）</td>
</tr>
<tr>
<td>-n</td>
<td>密钥的类型（HOST表示与主机相关）</td>
</tr>
</tbody></table>
<p>使用下述命令生成一个主机名称为master-slave的128位HMAC-MD5算法的密钥文件。在执行该命令后默认会在当前目录中生成公钥和私钥文件，我们需要把私钥文件中Key参数后面的值记录下来；</p>
<pre><code>[root@linuxprobe ~]# dnssec-keygen -a HMAC-MD5 -b 128 -n HOST master-slave
Kmaster-slave.+157+46845
[root@linuxprobe ~]# ls -al Kmaster-slave.+157+46845.*
-rw-------. 1 root root 56 Jun 7 16:06 Kmaster-slave.+157+46845.key
-rw-------. 1 root root 165 Jun 7 16:06 Kmaster-slave.+157+46845.private
[root@linuxprobe ~]# cat Kmaster-slave.+157+46845.private
Private-key-format: v1.3
Algorithm: 157 (HMAC_MD5)
Key: 1XEEL3tG5DNLOw+1WHfE3Q==
Bits: AAA=
Created: 20170607080621
Publish: 20170607080621
Activate: 20170607080621</code></pre>
<p>第2步：在<strong>主服务器</strong>中创建密钥验证文件。进入bind服务程序用于保存配置文件的目录，把刚刚生成的密钥名称、加密算法和私钥加密字符串按照下面格式写入到tansfer.key传输配置文件中。为了安全起见，我们需要将文件的所属组修改成named，并将文件权限设置得要小一点，然后把该文件做一个硬链接到/etc目录中。</p>
<pre><code>[root@linuxprobe ~]# cd /var/named/chroot/etc/
[root@linuxprobe etc]# vim transfer.key
key &quot;master-slave&quot; &#123;
algorithm hmac-md5;
secret &quot;1XEEL3tG5DNLOw+1WHfE3Q==&quot;;
&#125;;
[root@linuxprobe etc]# chown root:named transfer.key
[root@linuxprobe etc]# chmod 640 transfer.key
[root@linuxprobe etc]# ln transfer.key /etc/transfer.key</code></pre>
<p>第3步：开启并加载Bind服务的密钥验证功能。首先需要在主服务器的主配置文件中加载密钥验证文件，然后进行设置，使得只允许带有master-slave密钥认证的DNS服务器同步数据配置文件：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/named.conf
  9 include &quot;/etc/transfer.key&quot;;
 10 options &#123;
 11 listen-on port 53 &#123; any; &#125;;
 12 listen-on-v6 port 53 &#123; ::1; &#125;;
 13 directory &quot;/var/named&quot;;
 14 dump-file &quot;/var/named/data/cache_dump.db&quot;;
 15 statistics-file &quot;/var/named/data/named_stats.txt&quot;;
 16 memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;
 17 allow-query &#123; any; &#125;;
 18 allow-transfer &#123; key master-slave; &#125;;
………………省略部分输出信息………………
[root@linuxprobe ~]# systemctl restart named</code></pre>
<p>至此，DNS主服务器的TSIG密钥加密传输功能就已经配置完成。此时清空DNS从服务器同步目录中所有的数据配置文件，然后再次重启bind服务程序；</p>
<pre><code>[root@linuxprobe ~]# rm -rf /var/named/slaves/*
[root@linuxprobe ~]# ls  /var/named/slaves/
[root@linuxprobe ~]# systemctl restart named</code></pre>
<p>第4步：配置<strong>从服务器</strong>，使其支持密钥验证。配置DNS从服务器和主服务器的方法大致相同，都需要在bind服务程序的配置文件目录中创建密钥认证文件，并设置相应的权限，然后把该文件做一个硬链接到/etc目录中。</p>
<pre><code>[root@linuxprobe ~]# cd /var/named/chroot/etc
[root@linuxprobe etc]# vim transfer.key
key &quot;master-slave&quot; &#123;
algorithm hmac-md5;
secret &quot;1XEEL3tG5DNLOw+1WHfE3Q==&quot;;
&#125;;
[root@linuxprobe etc]# chown root:named transfer.key
[root@linuxprobe etc]# chmod 640 transfer.key
[root@linuxprobe etc]# ln transfer.key /etc/transfer.key</code></pre>
<p>第5步：开启并加载从服务器的密钥验证功能。这一步的操作步骤也同样是在主配置文件中加载密钥认证文件，然后按照指定格式写上主服务器的IP地址和密钥名称。注意，密钥名称等参数位置不要太靠前，大约在第43行比较合适，否则bind服务程序会因为没有加载完预设参数而报错：</p>
<pre><code>[root@linuxprobe etc]# vim /etc/named.conf
  9 include &quot;/etc/transfer.key&quot;;
 10 options &#123;
 11 listen-on port 53 &#123; 127.0.0.1; &#125;;
 12 listen-on-v6 port 53 &#123; ::1; &#125;;
 13 directory &quot;/var/named&quot;;
 14 dump-file &quot;/var/named/data/cache_dump.db&quot;;
 15 statistics-file &quot;/var/named/data/named_stats.txt&quot;;
 16 memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;
 17 allow-query &#123; localhost; &#125;;
    …………
 41 session-keyfile &quot;/run/named/session.key&quot;;
 42 &#125;;
 43 server 192.168.10.10
 44 &#123;
 45 keys &#123; master-slave; &#125;;
 46 &#125;; 
 47 logging &#123;</code></pre>
<p>第6步：DNS从服务器同步域名区域数据。现在，两台服务器的bind服务程序都已经配置妥当，并匹配到了相同的密钥认证文件。接下来在从服务器上重启bind服务程序，可以发现又能顺利地同步到数据配置文件了。</p>
<pre><code>[root@linuxprobe ~]# systemctl restart named
[root@linuxprobe ~]# ls /var/named/slaves/
 192.168.10.arpa  linuxprobe.com.zone</code></pre>
<h1 id="5-分离解析技术"><a href="#5-分离解析技术" class="headerlink" title="5.分离解析技术"></a>5.分离解析技术</h1><table>
<thead>
<tr>
<th>主机名称</th>
<th>操作系统</th>
<th>IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>DNS服务器</td>
<td>RHEL 7</td>
<td>北京网络：122.71.115.10</td>
</tr>
<tr>
<td></td>
<td></td>
<td>美国网络：106.185.25.10</td>
</tr>
<tr>
<td>北京用户</td>
<td>windows 7</td>
<td>122.71.115.1</td>
</tr>
<tr>
<td>海外用户</td>
<td>windows 7</td>
<td>106.185.25.1</td>
</tr>
</tbody></table>
<p>第1步：安装bind域名解析服务，并修改bind服务程序的主配置文件，把第11行的监听端口与第17行的允许查询主机修改为any。由于配置的DNS分离解析功能与DNS根服务器配置参数有冲突，所以需要把第51~54行的根域信息删除。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/named.conf
………………省略部分输出信息………………
 44 logging &#123;
 45 channel default_debug &#123;
 46 file &quot;data/named.run&quot;;
 47 severity dynamic;
 48 &#125;;
 49 &#125;;
 50 
 51 zone &quot;.&quot; IN &#123;
 52 type hint;
 53 file &quot;named.ca&quot;;
 54 &#125;;
 55 
 56 include &quot;/etc/named.rfc1912.zones&quot;;
 57 include &quot;/etc/named.root.key&quot;;
 58
………………省略部分输出信息………………</code></pre>
<p>第2步：编辑区域配置文件。把区域配置文件中原有的数据清空，然后按照以下格式写入参数。首先使用acl参数分别定义两个变量名称（china与american），当下面需要匹配IP地址时只需写入变量名称即可，这样不仅容易阅读识别，而且也利于修改维护。这里的难点是理解view参数的作用。它的作用是通过判断用户的IP地址是中国的还是美国的，然后去分别加载不同的数据配置文件（linuxprobe.com.china或linuxprobe.com.american）。这样，当把相应的IP地址分别写入到数据配置文件后，即可实现DNS的分离解析功能。这样一来，当中国的用户访问linuxprobe.com域名时，便会按照linuxprobe.com.china数据配置文件内的IP地址找到对应的服务器。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/named.rfc1912.zones
1 acl &quot;china&quot; &#123; 122.71.115.0/24; &#125;;
2 acl &quot;american&quot; &#123; 106.185.25.0/24;&#125;;
3 view &quot;china&quot;&#123;
4 match-clients &#123; &quot;china&quot;; &#125;;
5 zone &quot;linuxprobe.com&quot; &#123;
6 type master;
7 file &quot;linuxprobe.com.china&quot;;
8 &#125;;
9 &#125;;
10 view &quot;american&quot; &#123;
11 match-clients &#123; &quot;american&quot;; &#125;;
12 zone &quot;linuxprobe.com&quot; &#123;
13 type master;
14 file &quot;linuxprobe.com.american&quot;;
15 &#125;;
16 &#125;;</code></pre>
<p>第3步：建立数据配置文件。分别通过模板文件创建出两份不同名称的区域数据文件，其名称应与上面区域配置文件中的参数相对应。</p>
<pre><code>[root@linuxprobe ~]# cd /var/named
[root@linuxprobe named]# cp -a named.localhost linuxprobe.com.china
[root@linuxprobe named]# cp -a named.localhost linuxprobe.com.american
[root@linuxprobe named]# vim linuxprobe.com.china</code></pre>
<img src="/2021/02/13/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-13%EF%BC%9A%E4%BD%BF%E7%94%A8Bind%E6%8F%90%E4%BE%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1/4.png" class>

<pre><code>[root@linuxprobe named]# vim linuxprobe.com.american</code></pre>
<img src="/2021/02/13/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-13%EF%BC%9A%E4%BD%BF%E7%94%A8Bind%E6%8F%90%E4%BE%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1/5.png" class>

<p>第4步：重新启动named服务程序，验证结果。</p>
<pre><code>[root@linuxprobe named]# systemctl restart named</code></pre>
<p>第5步：将客户端主机（Windows系统或Linux系统均可）的IP地址分别设置为122.71.115.1与106.185.25.1，将DNS地址分别设置为服务器主机的两个IP地址。这样，当尝试使用nslookup命令解析域名时就能清晰地看到解析结果，分别如下图所示。</p>
<img src="/2021/02/13/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-13%EF%BC%9A%E4%BD%BF%E7%94%A8Bind%E6%8F%90%E4%BE%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1/6.png" class>

<img src="/2021/02/13/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-13%EF%BC%9A%E4%BD%BF%E7%94%A8Bind%E6%8F%90%E4%BE%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1/7.png" class>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第13章节：使用Bind提供域名解析服务</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学-17：使用ISCSI服务部署网络存储</title>
    <url>/2021/02/20/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-17%EF%BC%9A%E4%BD%BF%E7%94%A8ISCSI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h1 id="1-ISCSI技术介绍"><a href="#1-ISCSI技术介绍" class="headerlink" title="1.ISCSI技术介绍"></a>1.ISCSI技术介绍</h1><p>为了进一步提升硬盘存储设备的读写速度和性能，人们一直在努力改进物理硬盘设备的接口协议。当前的硬盘接口类型主要有IDE、SCSI和SATA这3种。</p>
<a id="more"></a>

<pre><code>IDE是一种成熟稳定、价格便宜的并行传输接口。

SATA是一种传输速度更快、数据校验更完整的串行传输接口。

SCSI是一种用于计算机和硬盘、光驱等设备之间系统级接口的通用标准，具有系统资源占用率低、转速高、传输速度快等优点。</code></pre>
<p>iSCSI：Internet Small Computer System Interface，互联网小型计算机系统接口！</p>
<p>这是一种将SCSI接口与以太网技术相结合的新型存储技术，可以用来在网络中传输SCSI接口的命令和数据。这样，不仅克服了传统SCSI接口设备的物理局限性，实现了跨区域的存储资源共享，还可以在不停机的状态下扩展存储容量。</p>
<h1 id="2-创建RAID磁盘阵列"><a href="#2-创建RAID磁盘阵列" class="headerlink" title="2.创建RAID磁盘阵列"></a>2.创建RAID磁盘阵列</h1><p>第1步：首先在虚拟机中添加4块新硬盘，用于创建RAID 5磁盘阵列和备份盘：</p>
<img src="/2021/02/20/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-17%EF%BC%9A%E4%BD%BF%E7%94%A8ISCSI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8/1.jpg" class>

<p>第2步：启动虚拟机系统，使用mdadm命令创建RAID磁盘阵列。其中，-Cv参数为创建阵列并显示过程，/dev/md0为生成的阵列组名称，-n 3参数为创建RAID 5磁盘阵列所需的硬盘个数，-l 5参数为RAID磁盘阵列的级别，-x 1参数为磁盘阵列的备份盘个数。在命令后面要逐一写上使用的硬盘名称。</p>
<pre><code>[root@linuxprobe ~]# mdadm -Cv /dev/md0 -n 3 -l 5 -x 1 /dev/sdb /dev/sdc /dev/sdd /dev/sde
mdadm: layout defaults to left-symmetric
mdadm: layout defaults to left-symmetric
mdadm: chunk size defaults to 512K
mdadm: size set to 20954624K
mdadm: Defaulting to version 1.2 metadata
mdadm: array /dev/md0 started.</code></pre>
<p>在上述命令成功执行之后，得到一块名称为/dev/md0的新设备，大家可使用mdadm -D命令来查看设备的详细信息。另外，由于在使用远程设备时极有可能出现设备识别顺序发生变化的情况，因此，如果直接在fstab挂载配置文件中写入/dev/sdb、/dev/sdc等设备名称的话，就有可能在下一次挂载了错误的存储设备。而UUID值是设备的唯一标识符，可以用于精确地区分本地或远程设备。于是我们可以把这个值记录下来，一会儿准备填写到挂载配置文件中。</p>
<pre><code>[root@linuxprobe ~]# mdadm -D /dev/md0
/dev/md0:
        Version : 1.2
…………
**UUID : 3370f643:c10efd6a:44e91f2a:20c71f3e**
         Events : 26
    Number   Major   Minor   RaidDevice State
       0       8       16        0      active sync   /dev/sdb
       1       8       32        1      active sync   /dev/sdc
       4       8       48        2      active sync   /dev/sdd
       3       8       64        -      spare   /dev/sde</code></pre>
<h1 id="3-配置iSCSI服务端"><a href="#3-配置iSCSI服务端" class="headerlink" title="3.配置iSCSI服务端"></a>3.配置iSCSI服务端</h1><p>iSCSI技术在工作形式上分为服务端（target）与客户端（initiator）。iSCSI服务端即用于存放硬盘存储资源的服务器，它作为前面创建的RAID磁盘阵列的存储端，能够为用户提供可用的存储资源。iSCSI客户端则是用户使用的软件，用于访问远程服务端的存储资源。</p>
<p> iSCSI服务端和客户端的操作系统以及IP地址：</p>
<table>
<thead>
<tr>
<th>主机名称</th>
<th>操作系统</th>
<th>IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>iSCSI服务端</td>
<td>RHEL 7</td>
<td>192.168.10.10</td>
</tr>
<tr>
<td>iSCSI客户端</td>
<td>RHEL 7</td>
<td>192.168.10.20</td>
</tr>
</tbody></table>
<p>第1步：配置好Yum软件仓库后安装iSCSI服务端程序以及配置命令工具。通过在yum命令的后面添加-y参数，在安装过程中就不需要再进行手动确认了：</p>
<pre><code>[root@linuxprobe ~]# yum -y install targetd targetcli
Loaded plugins: langpacks, product-id, subscription-manager
………………省略部分输出信息………………
 python-setproctitle.x86_64 0:1.1.6-5.el7 
 python-urwid.x86_64 0:1.1.1-3.el7 
Complete!</code></pre>
<p>安装完成后启动iSCSI的服务端程序targetd，然后把这个服务程序加入到开机启动项中，以便下次在服务器重启后依然能够为用户提供iSCSI共享存储资源服务：</p>
<pre><code>[root@linuxprobe ~]# systemctl start targetd
[root@linuxprobe ~]# systemctl enable targetd
 ln -s &#39;/usr/lib/systemd/system/targetd.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/targetd.service&#39;</code></pre>
<p>第2步：配置iSCSI服务端共享资源。在执行targetcli命令后就能看到交互式的配置界面了。在该界面中可以使用很多Linux命令，比如利用ls查看目录参数的结构，使用cd切换到不同的目录中。/backstores/block是iSCSI服务端配置共享设备的位置。我们需要把刚刚创建的RAID 5磁盘阵列md0文件加入到配置共享设备的“资源池”中，并将该文件重新命名为disk0，这样用户就不会知道是由服务器中的哪块硬盘来提供共享存储资源，而只会看到一个名为disk0的存储设备。</p>
<pre><code>[root@linuxprobe ~]# targetcli
Warning: Could not load preferences file /root/.targetcli/prefs.bin.
targetcli shell version 2.1.fb34
Copyright 2011-2013 by Datera, Inc and others.
For help on commands, type &#39;help&#39;.
/&gt; ls
o- / ..................................................................... [...]
o- backstores .......................................................... [...]
| o- block .............................................. [Storage Objects: 0]
| o- fileio ............................................. [Storage Objects: 0]
| o- pscsi .............................................. [Storage Objects: 0]
| o- ramdisk ............................................ [Storage Objects: 0]
o- iscsi ........................................................ [Targets: 0]
o- loopback ..................................................... [Targets: 0
/&gt; cd /backstores/block
/backstores/block&gt; create disk0 /dev/md0
Created block storage object disk0 using /dev/md0.
/backstores/block&gt; cd /
/&gt; ls
o- / ..................................................................... [...]
  o- backstores .......................................................... [...]
  | o- block .............................................. [Storage Objects: 1]
  | | o- disk0 ..................... [/dev/md0 (40.0GiB) write-thru deactivated]
  | o- fileio ............................................. [Storage Objects: 0]
  | o- pscsi .............................................. [Storage Objects: 0]
  | o- ramdisk ............................................ [Storage Objects: 0]
  o- iscsi ........................................................ [Targets: 0]
  o- loopback ..................................................... [Targets: 0]</code></pre>
<p>第3步：创建iSCSI target名称及配置共享资源。iSCSI target名称是由系统自动生成的，这是一串用于描述共享资源的唯一字符串。稍后用户在扫描iSCSI服务端时即可看到这个字符串，因此我们不需要记住它。系统在生成这个target名称后，还会在/iscsi参数目录中创建一个与其字符串同名的新“目录”用来存放共享资源。我们需要把前面加入到iSCSI共享资源池中的硬盘设备添加到这个新目录中，这样用户在登录iSCSI服务端后，即可默认使用这硬盘设备提供的共享存储资源了。</p>
<pre><code>/&gt; cd iscsi
/iscsi&gt; 
/iscsi&gt; create
Created target iqn.2003-01.org.linux-iscsi.linuxprobe.x8664:sn.d497c356ad80.
Created TPG 1.
/iscsi&gt; cd iqn.2003-01.org.linux-iscsi.linuxprobe.x8664:sn.d497c356ad80/
/iscsi/iqn.20....d497c356ad80&gt; ls
o- iqn.2003-01.org.linux-iscsi.linuxprobe.x8664:sn.d497c356ad80 ...... [TPGs: 1]
  o- tpg1 ............................................... [no-gen-acls, no-auth]
    o- acls .......................................................... [ACLs: 0]
    o- luns .......................................................... [LUNs: 0]
    o- portals .................................................... [Portals: 0]
/iscsi/iqn.20....d497c356ad80&gt; cd tpg1/luns
/iscsi/iqn.20...d80/tpg1/luns&gt; create /backstores/block/disk0 
Created LUN 0.</code></pre>
<p>第4步：设置访问控制列表（ACL）。iSCSI协议是通过客户端名称进行验证的，也就是说，用户在访问存储共享资源时不需要输入密码，只要iSCSI客户端的名称与服务端中设置的访问控制列表中某一名称条目一致即可，因此需要在iSCSI服务端的配置文件中写入一串能够验证用户信息的名称。acls参数目录用于存放能够访问iSCSI服务端共享存储资源的客户端名称。刘遄老师推荐在刚刚系统生成的iSCSI target后面追加上类似于:client的参数，这样既能保证客户端的名称具有唯一性，又非常便于管理和阅读：</p>
<pre><code>/iscsi/iqn.20...d80/tpg1/luns&gt; cd ..
/iscsi/iqn.20...c356ad80/tpg1&gt; cd acls 
/iscsi/iqn.20...d80/tpg1/acls&gt; create iqn.2003-01.org.linux-iscsi.linuxprobe.x8664:sn.d497c356ad80:client
Created Node ACL for iqn.2003-01.org.linux-iscsi.linuxprobe.x8664:sn.d497c356ad80:client
Created mapped LUN 0</code></pre>
<p>第5步：设置iSCSI服务端的监听IP地址和端口号。即在portals参数目录中写上服务器的IP地址。接下来将由系统自动开启服务器192.168.10.10的3260端口将向外提供iSCSI共享存储资源服务：</p>
<pre><code>/iscsi/iqn.20...d80/tpg1/acls&gt; cd ..
/iscsi/iqn.20...c356ad80/tpg1&gt; cd portals 
/iscsi/iqn.20.../tpg1/portals&gt; create 192.168.10.10
Using default IP port 3260
Created network portal 192.168.10.10:3260.</code></pre>
<p>第6步：配置妥当后检查配置信息，重启iSCSI服务端程序并配置防火墙策略。在参数文件配置妥当后，可以浏览刚刚配置的信息，确保与下面的信息基本一致。在确认信息无误后输入exit命令来退出配置。注意，千万不要习惯性地按Ctrl + C组合键结束进程，这样不会保存配置文件，我们的工作也就白费了。最后重启iSCSI服务端程序，再设置firewalld防火墙策略，使其放行3260/tcp端口号的流量。</p>
<pre><code>/iscsi/iqn.20.../tpg1/portals&gt; ls /
o- / ........................... [...]
  o- backstores................. [...]
  | o- block ................... [Storage Objects: 1]
  | | o- disk0 ................. [/dev/md0 (40.0GiB) write-thru activated]
  | o- fileio .................. [Storage Objects: 0]
  | o- pscsi ................... [Storage Objects: 0]
  | o- ramdisk ................. [Storage Objects: 0]
  o- iscsi ..................... [Targets: 1]
  | o- iqn.2003-01.org.linux-iscsi.linuxprobe.x8664:sn.d497c356ad80 .... [TPGs: 1]
  |   o- tpg1 .................. [no-gen-acls, no-auth]
  |     o- acls ........................................................ [ACLs: 1]
  |     | o- iqn.2003-01.org.linux-iscsi.linuxprobe.x8664:sn.d497c356ad80:client [Mapped LUNs: 1]
  |     |   o- mapped_lun0 ............................................. [lun0 block/disk0 (rw)]  
    o- luns .................... [LUNs: 1]
  |     | o- lun0 .............. [block/disk0 (/dev/md0)]
  |     o- portals ............. [Portals: 1]
  |       o- 192.168.10.10:3260  [OK]
  o- loopback .................. [Targets: 0]
/&gt; exit
Global pref auto_save_on_exit=true
Last 10 configs saved in /etc/target/backup.
Configuration saved to /etc/target/saveconfig.json
[root@linuxprobe ~]# systemctl restart targetd
[root@linuxprobe ~]# firewall-cmd --permanent --add-port=3260/tcp 
success 
[root@linuxprobe ~]# firewall-cmd --reload 
success</code></pre>
<p>但在配置这部分时，遇到一个问题：在targetcli界面输入“exit”时，并没有显示配置已保存，反而提示有报错：’Implict and Explict’ is not in list；网上搜索查询得知是由于系统内核版本（kernel-3.10.0-123.el7.x86_64）太低导致，需要升级kernel内核：在升级内核时，也比较麻烦，一台虚拟机系统在终端中输入命令：yum update kernel，即成功升级版本（kernel 3.10.0-1160.15.2.el7.x86_64）；而另一台虚拟机则使用此种方式不成功，查询资料，采用另一种方式：</p>
<p>1.直接运行yum update kernel，显示报错error:kernel conflicts kmod等等……；</p>
<p>2.输入：yum clean all，可能有些效果，但无法彻底解决；</p>
<p>3.上面报错：kernel conflicts kmod，可能是由于系统中安装有多个kmod版本导致；</p>
<p>4.输入：rpm -qa kmod，查询系统中安装的kmod数量，然后使用 rpm -e kmod-version，卸载低版本，之后重新输入；yum update kernel，升级内核！</p>
<p>5.升级完成后，输入：awk -F&#39; ‘$1==”menuentry “ {print $2}’ /etc/grub2.cfg ，查看下内核的默认启动顺序；</p>
<p>6.默认启动的顺序是从0开始，新内核是从头插入，所以需要选择0，输入命令：grub2-set-default 0</p>
<p>7.重启系统，开机后输入：uname -r，查看系统版本号！</p>
<h1 id="4-配置linux客户端"><a href="#4-配置linux客户端" class="headerlink" title="4.配置linux客户端"></a>4.配置linux客户端</h1><p>第1步：在RHEL 7系统中，已经默认安装了iSCSI客户端服务程序initiator。如果您的系统没有安装的话，可以使用Yum软件仓库手动安装。</p>
<pre><code>[root@linuxprobe ~]# yum install iscsi-initiator-utils 
Loaded plugins: langpacks, product-id, subscription-manager 
Package iscsi-initiator-utils-6.2.0.873-21.el7.x86_64 already installed and latest version 
Nothing to do</code></pre>
<p>第2步：编辑iSCSI客户端中的initiator名称文件，把服务端的访问控制列表名称填写进来，然后重启客户端iscsid服务程序并将其加入到开机启动项中：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/iscsi/initiatorname.iscsi
InitiatorName=iqn.2003-01.org.linux-iscsi.linuxprobe.x8664:sn.d497c356ad80:client
[root@linuxprobe ~]# systemctl restart iscsid
[root@linuxprobe ~]# systemctl enable iscsid
 ln -s &#39;/usr/lib/systemd/system/iscsid.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/iscsid.service&#39;</code></pre>
<p>第3步：iSCSI客户端访问并使用共享存储资源的步骤很简单，只需要记住刘遄老师的一个小口诀“先发现，再登录，最后挂载并使用”。iscsiadm是用于管理、查询、插入、更新或删除iSCSI数据库配置文件的命令行工具，用户需要先使用这个工具扫描发现远程iSCSI服务端，然后查看找到的服务端上有哪些可用的共享存储资源。其中，-m discovery参数的目的是扫描并发现可用的存储资源，-t st参数为执行扫描操作的类型，-p 192.168.10.10参数为iSCSI服务端的IP地址：</p>
<pre><code>[root@linuxprobe ~]# iscsiadm -m discovery -t st -p 192.168.10.10
192.168.10.10:3260,1 iqn.2003-01.org.linux-iscsi.linuxprobe.x8664:sn.d497c356ad80</code></pre>
<p>第4步：在使用iscsiadm命令发现了远程服务器上可用的存储资源后，接下来准备登录iSCSI服务端。其中，-m node参数为将客户端所在主机作为一台节点服务器，-T  iqn.2003-01. org.linux-iscsi.linuxprobe.x8664:sn.d497c356ad80参数为要使用的存储资源（大家可以直接复制前面命令中扫描发现的结果，以免录入错误），-p 192.168.10.10参数依然为对方iSCSI服务端的IP地址。最后使用–login或-l参数进行登录验证。</p>
<pre><code>[root@linuxprobe ~]# iscsiadm -m node -T iqn.2003-01.org.linux-iscsi.linuxprobe.x8664:sn.d497c356ad80 -p 192.168.10.10 --login
Logging in to [iface: default, target: iqn.2003-01.org.linux-iscsi.linuxprobe.x8664:sn.d497c356ad80, portal: 192.168.10.10,3260] (multiple)
Login to [iface: default, target: iqn.2003-01.org.linux-iscsi.linuxprobe.x8664:sn.d497c356ad80, portal: 192.168.10.10,3260] successful.</code></pre>
<p>第5步：在iSCSI客户端成功登录之后，会在客户端主机上多出一块名为/dev/sdb的设备文件。</p>
<pre><code>[root@linuxprobe ~]# file /dev/sdb 
/dev/sdb: block special</code></pre>
<p>第6步：格式化、挂载硬盘；</p>
<pre><code>[root@linuxprobe ~]# mkfs.xfs /dev/sdb
[root@linuxprobe ~]# mkdir /iscsi
[root@linuxprobe ~]# mount /dev/sdb /iscsi
[root@linuxprobe ~]# df -h</code></pre>
<p>需要提醒大家的是，由于udev服务是按照系统识别硬盘设备的顺序来命名硬盘设备的，当客户端主机同时使用多个远程存储资源时，如果下一次识别远程设备的顺序发生了变化，则客户端挂载目录中的文件也将随之混乱。为了防止发生这样的问题，我们应该在/etc/fstab配置文件中使用设备的UUID唯一标识符进行挂载，这样，不论远程设备资源的识别顺序再怎么变化，系统也能正确找到设备所对应的目录。</p>
<p>blkid命令用于查看设备的名称、文件系统及UUID。可以使用管道符（详见第3章）进行过滤，只显示与/dev/sdb设备相关的信息：</p>
<pre><code>[root@linuxprobe ~]# blkid | grep /dev/sdb
/dev/sdb: UUID=&quot;eb9cbf2f-fce8-413a-b770-8b0f243e8ad6&quot; TYPE=&quot;xfs&quot; </code></pre>
<p>由于/dev/sdb是一块网络存储设备，而iSCSI协议是基于TCP/IP网络传输数据的，因此必须在/etc/fstab配置文件中添加上_netdev参数，表示当系统联网后再进行挂载操作，以免系统开机时间过长或开机失败：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/fstab
/dev/mapper/rhel-swap swap swap defaults 0 0
/dev/cdrom /media/cdrom iso9660 defaults 0 0 
**UUID=eb9cbf2f-fce8-413a-b770-8b0f243e8ad6 /iscsi xfs defaults,_netdev 0 0**</code></pre>
<p>如果我们不再需要使用iSCSI共享设备资源了，可以用iscsiadm命令的-u参数将其设备卸载：</p>
<pre><code>[root@linuxprobe ~]# iscsiadm -m node -T iqn.2003-01.org.linux-iscsi.linuxprobe.x8664:sn.d497c356ad80 -u

Logging out of session [sid: 7, target : iqn.2003-01.org.linux-iscsi.linuxprobe.x8664:sn.d497c356ad80, portal: 192.168.10.10,3260]

Logout of [sid: 7, target: iqn.2003-01.org.linux-iscsi.linuxprobe.x8664:sn.d497c356ad80,portal:192.168.10.10,3260] successful.</code></pre>
<h1 id="5-配置windows客户端"><a href="#5-配置windows客户端" class="headerlink" title="5.配置windows客户端"></a>5.配置windows客户端</h1><p>使用Windows系统的客户端也可以正常访问iSCSI服务器上的共享存储资源，而且操作原理及步骤与Linux系统的客户端基本相同。在进行下面的实验之前，请先关闭Linux系统客户端，以免这两台客户端主机同时使用iSCSI共享存储资源而产生潜在问题。</p>
<p>iSCSI服务器和客户端的操作系统以及IP地址：</p>
<table>
<thead>
<tr>
<th>主机名称</th>
<th>操作系统</th>
<th>IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>iSCSI服务端</td>
<td>RHEL 7</td>
<td>192.168.10.10</td>
</tr>
<tr>
<td>windows客户端</td>
<td>windows 7</td>
<td>192.168.10.30</td>
</tr>
</tbody></table>
<p>第1步：运行iSCSI发起程序。在Windows 7/10操作系统中已经默认安装了iSCSI客户端程序，我们只需在控制面板中找到“系统和安全”标签，然后单击“管理工具”，进入到“管理工具”页面后即可看到“iSCSI发起程序”图标。双击该图标。在第一次运行iSCSI发起程序时，系统会提示“Microsoft iSCSI服务端未运行”，单击“是”按钮即可自动启动并运行iSCSI发起程序：</p>
<img src="/2021/02/20/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-17%EF%BC%9A%E4%BD%BF%E7%94%A8ISCSI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8/2.png" class>

<img src="/2021/02/20/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-17%EF%BC%9A%E4%BD%BF%E7%94%A8ISCSI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8/3.png" class>

<p>第2步：扫描发现iSCSI服务端上可用的存储资源。不论是Windows系统还是Linux系统，要想使用iSCSI共享存储资源都必须先进行扫描发现操作。运行iSCSI发起程序后在“目标”选项卡的“目标”文本框中写入iSCSI服务端的IP地址，然后单击“快速连接”按钮:</p>
<img src="/2021/02/20/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-17%EF%BC%9A%E4%BD%BF%E7%94%A8ISCSI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8/4.png" class>

<p>在弹出的“快速连接”提示框中可看到共享的硬盘存储资源，单击“完成”按钮即可:</p>
<img src="/2021/02/20/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-17%EF%BC%9A%E4%BD%BF%E7%94%A8ISCSI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8/5.png" class>

<p>回到“目标”选项卡页面，可以看到共享存储资源的名称已经出现.</p>
<p>第3步：准备连接iSCSI服务端的共享存储资源。由于在iSCSI服务端程序上设置了ACL，使得只有客户端名称与ACL策略中的名称保持一致时才能使用远程存储资源，因此需要在“配置”选项卡中单击“更改”按钮，把iSCSI发起程序的名称修改为服务端:</p>
<img src="/2021/02/20/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-17%EF%BC%9A%E4%BD%BF%E7%94%A8ISCSI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8/6.png" class>

<img src="/2021/02/20/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-17%EF%BC%9A%E4%BD%BF%E7%94%A8ISCSI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8/7.png" class>

<p>在确认客户端发起程序的名称修改正确后即可返回到“目标”选项卡页面中，然后单击“连接”按钮进行连接请求，成功连接到远程共享存储资源的页面:</p>
<img src="/2021/02/20/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-17%EF%BC%9A%E4%BD%BF%E7%94%A8ISCSI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8/8.png" class>

<p>第4步：访问iSCSI远程共享存储资源。右键单击桌面上的“计算机”图标，打开计算机管理程序:</p>
<img src="/2021/02/20/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-17%EF%BC%9A%E4%BD%BF%E7%94%A8ISCSI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8/9.png" class>

<p>开始对磁盘进行初始化操作:</p>
<img src="/2021/02/20/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-17%EF%BC%9A%E4%BD%BF%E7%94%A8ISCSI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8/10.png" class>

<img src="/2021/02/20/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-17%EF%BC%9A%E4%BD%BF%E7%94%A8ISCSI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8/11.png" class>

<img src="/2021/02/20/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-17%EF%BC%9A%E4%BD%BF%E7%94%A8ISCSI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8/12.png" class>

<img src="/2021/02/20/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-17%EF%BC%9A%E4%BD%BF%E7%94%A8ISCSI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8/13.png" class>

<img src="/2021/02/20/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-17%EF%BC%9A%E4%BD%BF%E7%94%A8ISCSI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8/14.png" class>

<img src="/2021/02/20/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-17%EF%BC%9A%E4%BD%BF%E7%94%A8ISCSI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8/15.png" class>

<img src="/2021/02/20/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-17%EF%BC%9A%E4%BD%BF%E7%94%A8ISCSI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8/16.png" class>

<img src="/2021/02/20/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-17%EF%BC%9A%E4%BD%BF%E7%94%A8ISCSI%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8/17.png" class>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第17章节：使用ISCSI服务部署网络存储</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学-18：使用MariaDB数据库管理系统</title>
    <url>/2021/02/24/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-18%EF%BC%9A%E4%BD%BF%E7%94%A8MariaDB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="1-数据库管理系统"><a href="#1-数据库管理系统" class="headerlink" title="1.数据库管理系统"></a>1.数据库管理系统</h1><p>数据库是指按照某些特定结构来存储数据资料的数据仓库。</p>
<a id="more"></a>

<p>数据库管理系统是一种能够对数据库中存放的数据进行建立、修改、删除、查找、维护等操作的软件程序。它通过把计算机中具体的物理数据转换成适合用户理解的抽象逻辑数据，有效地降低数据库管理的技术门槛。</p>
<h1 id="2-初始化MariaDB服务"><a href="#2-初始化MariaDB服务" class="headerlink" title="2.初始化MariaDB服务"></a>2.初始化MariaDB服务</h1><pre><code>[root@linuxprobe ~]# yum install mariadb mariadb-server
Complete!
[root@linuxprobe ~]# systemctl start mariadb 
[root@linuxprobe ~]# systemctl enable mariadb 
ln -s &#39;/usr/lib/systemd/system/mariadb.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/mariadb.service&#39;</code></pre>
<p>在确认MariaDB数据库软件程序安装完毕并成功启动后请不要立即使用。为了确保数据库的安全性和正常运转，需要先对数据库程序进行初始化操作。这个初始化操作涉及下面5个步骤：</p>
<p>1.设置root管理员在数据库中的密码值（注意，该密码并非root管理员在系统中的密码，这里的密码值2.默认应该为空，可直接按回车键）。<br>3.设置root管理员在数据库中的专有密码。<br>4.随后删除匿名账户，并使用root管理员从远程登录数据库，以确保数据库上运行的业务的安全性。<br>5.删除默认的测试数据库，取消测试数据库的一系列访问权限。<br>6.刷新授权列表，让初始化的设定立即生效。</p>
<pre><code>[root@linuxprobe ~]# mysql_secure_installation 
/usr/bin/mysql_secure_installation: line 379: find_mysql_client: command not found
NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB
      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!
In order to log into MariaDB to secure it, we&#39;ll need the current
password for the root user.  If you&#39;ve just installed MariaDB, and
you haven&#39;t set the root password yet, the password will be blank,
so you should just press enter here.
Enter current password for root (enter for none):  当前数据库密码为空，直接按回车键
OK, successfully used password, moving on...
Setting the root password ensures that nobody can log into the MariaDB
root user without the proper authorisation.
Set root password? [Y/n] y
New password:输入要为root管理员设置的数据库密码
Re-enter new password:再次输入密码
Password updated successfully!
Reloading privilege tables..
 ... Success!
By default, a MariaDB installation has an anonymous user, allowing anyone
to log into MariaDB without having to have a user account created for
them.  This is intended only for testing, and to make the installation
go a bit smoother.  You should remove them before moving into a
production environment.
Remove anonymous users? [Y/n] y（删除匿名账户）
... Success!
Normally, root should only be allowed to connect from &#39;localhost&#39;.  This
ensures that someone cannot guess at the root password from the network.
Disallow root login remotely? [Y/n] y（禁止root管理员从远程登录）
 ... Success!
By default, MariaDB comes with a database named &#39;test&#39; that anyone can
access.  This is also intended only for testing, and should be removed
before moving into a production environment.
Remove test database and access to it? [Y/n] y（删除test数据库并取消对它的访问权限）
 - Dropping test database...
 ... Success!
 - Removing privileges on test database...
 ... Success!
Reloading the privilege tables will ensure that all changes made so far
will take effect immediately.
Reload privilege tables now? [Y/n] y（刷新授权表，让初始化后的设定立即生效）
 ... Success!
Cleaning up...
All done!  If you&#39;ve completed all of the above steps, your MariaDB
installation should now be secure.
Thanks for using MariaDB!</code></pre>
<p>在很多生产环境中都需要使用站库分离的技术（即网站和数据库不在同一个服务器上），如果需要让root管理员远程访问数据库，可在上面的初始化操作中设置策略，以允许root管理员从远程访问。然后还需要设置防火墙，使其放行对数据库服务程序的访问请求，数据库服务程序默认会占用3306端口，在防火墙策略中服务名称统一叫作mysql：</p>
<pre><code>[root@linuxprobe ~]# firewall-cmd --permanent --add-service=mysql
success
[root@linuxprobe ~]# firewall-cmd --reload
success</code></pre>
<p>现在我们将首次登录MariaDB数据库。其中，-u参数用来指定以root管理员的身份登录，而-p参数用来验证该用户在数据库中的密码值。</p>
<pre><code>[root@linuxprobe ~]# mysql -u root -p
Enter password: 此处输入root管理员在数据库中的密码
Welcome to the MariaDB monitor. Commands end with ; or \g.
Your MariaDB connection id is 5
Server version: 5.5.35-MariaDB MariaDB Server
Copyright (c) 2000, 2013, Oracle, Monty Program Ab and others.
Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.
MariaDB [(none)]&gt;</code></pre>
<p>在登录MariaDB数据库后执行数据库命令时，都需要在命令后面用分号（;）结尾，这也是与Linux命令最显著的区别；</p>
<pre><code>MariaDB [(none)]&gt; SHOW databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
+--------------------+
3 rows in set (0.01 sec)</code></pre>
<p>接下来使用数据库命令将root管理员在数据库管理系统中的密码值修改为linuxprobe。这样退出后再尝试登录，如果还坚持输入原先的密码，则将提示访问失败。</p>
<pre><code>MariaDB [(none)]&gt; SET password = PASSWORD(&#39;linuxprobe&#39;);
Query OK, 0 rows affected (0.00 sec)
MariaDB [(none)]&gt; exit
Bye
[root@linuxprobe ~]# mysql -u root -p
Enter password:此处输入root管理员在数据库中的新密码
ERROR 1045 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: YES)</code></pre>
<h1 id="3-管理用户以及授权"><a href="#3-管理用户以及授权" class="headerlink" title="3.管理用户以及授权"></a>3.管理用户以及授权</h1><p>为了保障数据库系统的安全性，以及让其他用户协同管理数据库，我们可以在MariaDB数据库管理系统中为他们创建多个专用的数据库管理账户，然后再分配合理的权限，以满足他们的工作需求。为此，可使用root管理员登录数据库管理系统，然后按照“CREATE USER 用户名@主机名 IDENTIFIED BY ‘密码’; ”的格式创建数据库管理账户。再次提醒大家，一定不要忘记每条数据库命令后面的分号（;）。</p>
<pre><code>MariaDB [(none)]&gt; CREATE USER luke@localhost IDENTIFIED BY &#39;linuxprobe&#39;;
Query OK, 0 rows affected (0.00 sec)</code></pre>
<p>创建的账户信息可以使用select命令语句来查询。下面命令查询的是账户luke的主机名称、账户名称以及经过加密的密码值信息：</p>
<pre><code>MariaDB [(none)]&gt; use mysql
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A
Database changed
MariaDB [mysql]&gt; SELECT HOST,USER,PASSWORD FROM user WHERE USER=&quot;luke&quot;;
+-----------+------+-------------------------------------------+
| host      | user | password                                  |
+-----------+------+-------------------------------------------+
| localhost | luke | *55D9962586BE75F4B7D421E6655973DB07D6869F |
+-----------+------+-------------------------------------------+</code></pre>
<p>不过，用户luke仅仅是一个普通账户，没有数据库的任何操作权限。不信的话，可以切换到luke账户来查询数据库管理系统中当前都有哪些数据库。可以发现，该账户甚至没法查看完整的数据库列表（刚才使用root账户时可以查看到3个数据库列表）：</p>
<pre><code>MariaDB [mysql]&gt; exit
Bye
[root@linuxprobe ~]# mysql -u luke -p
Enter password: 此处输入luke账户的数据库密码
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 6
Server version: 5.5.35-MariaDB MariaDB Server
Copyright (c) 2000, 2013, Oracle, Monty Program Ab and others.
Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.
MariaDB [(none)]&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
+--------------------+
1 row in set (0.03 sec)</code></pre>
<p>GRANT命令的常见格式以及解释:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>GRANT 权限 ON 数据库.表单名称 TO 用户名@主机名</td>
<td>对某个特定数据库中的特定表单给予授权</td>
</tr>
<tr>
<td>GRANT 权限 ON 数据库.* TO 用户名@主机名</td>
<td>对某个特定数据库中的所有表单给予授权</td>
</tr>
<tr>
<td>GRANT 权限 ON <em>.</em> TO 用户名@主机名</td>
<td>对所有数据库及所有表单给予授权</td>
</tr>
<tr>
<td>GRANT 权限1,权限2 ON 数据库.* TO 用户名@主机名</td>
<td>对某个数据库中的所有表单给予多个授权</td>
</tr>
<tr>
<td>GRANT ALL PRIVILEGES ON <em>.</em> TO 用户名@主机名</td>
<td>对所有数据库及所有表单给予全部授权（需谨慎操作）</td>
</tr>
</tbody></table>
<p>账户的授权工作肯定是需要数据库管理员来执行的。下面以root管理员的身份登录到数据库管理系统中，针对mysql数据库中的user表单向账户luke授予查询、更新、删除以及插入等权限。</p>
<pre><code>[root@linuxprobe ~]# mysql -u root -p
Enter password:此处输入root管理员在数据库中的密码
MariaDB [(none)]&gt; use mysql;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A
Database changed
MariaDB [mysql]&gt; GRANT SELECT,UPDATE,DELETE,INSERT ON mysql.user TO luke@localhost;
Query OK, 0 rows affected (0.00 sec)
在执行完上述授权操作之后，我们再查看一下账户luke的权限：

MariaDB [(none)]&gt;  SHOW GRANTS FOR luke@localhost;
+-------------------------------------------------------------------------------------------------------------+
| Grants for luke@localhost |
+-------------------------------------------------------------------------------------------------------------+
| GRANT USAGE ON *.* TO &#39;luke&#39;@&#39;localhost&#39; IDENTIFIED BY PASSWORD &#39;*55D9962586BE75F4B7D421E6655973DB07D6869F&#39; |
| GRANT SELECT, INSERT, UPDATE, DELETE ON `mysql`.`user` TO &#39;luke&#39;@&#39;localhost&#39; |
+-------------------------------------------------------------------------------------------------------------+
2 rows in set (0.00 sec)</code></pre>
<p>上面输出信息中显示账户luke已经拥有了针对mysql数据库中user表单的一系列权限了。这时我们再切换到账户luke，此时就能够看到mysql数据库了，而且还能看到表单user（其余表单会因无权限而被继续隐藏）：</p>
<pre><code>[root@linuxprobe ~]# mysql -u luke -p
Enter password:此处输入luke用户在数据库中的密码
MariaDB [(none)]&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
+--------------------+
2 rows in set (0.01 sec)
MariaDB [(none)]&gt; use mysql
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A
Database changed
MariaDB [mysql]&gt; SHOW TABLES;
+-----------------+
| Tables_in_mysql |
+-----------------+
| user            |
+-----------------+
1 row in set (0.01 sec)
MariaDB [mysql]&gt; exit
Bye</code></pre>
<p>当前，先切换回root账户，移除刚才的授权。</p>
<pre><code>[root@linuxprobe ~]# mysql -u root -p
Enter password:此处输入root管理员在数据库中的密码
MariaDB [(none)]&gt; use mysql;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A
Database changed
MariaDB [(none)]&gt; REVOKE SELECT,UPDATE,DELETE,INSERT ON mysql.user FROM luke@localhost;
Query OK, 0 rows affected (0.00 sec)</code></pre>
<p>可以看到，除了移除授权的命令（revoke）与授权命令（grant）不同之外，其余部分都是一致的。这不仅好记而且也容易理解。执行移除授权命令后，再来查看账户luke的信息：</p>
<pre><code>MariaDB [(none)]&gt; SHOW GRANTS FOR luke@localhost;
+-------------------------------------------------------------------------------------------------------------+
| Grants for luke@localhost |
+-------------------------------------------------------------------------------------------------------------+
| GRANT USAGE ON *.* TO &#39;luke&#39;@&#39;localhost&#39; IDENTIFIED BY PASSWORD &#39;*55D9962586BE75F4B7D421E6655973DB07D6869F&#39; |
+-------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)</code></pre>
<h1 id="4-创建数据库与表单"><a href="#4-创建数据库与表单" class="headerlink" title="4.创建数据库与表单"></a>4.创建数据库与表单</h1><p>在MariaDB数据库管理系统中，一个数据库可以存放多个数据表，数据表单是数据库中最重要最核心的内容。</p>
<p>用于创建数据库的命令以及作用:</p>
<table>
<thead>
<tr>
<th>用法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>CREATE database 数据库名称。</td>
<td>创建新的数据库</td>
</tr>
<tr>
<td>DESCRIBE 表单名称;</td>
<td>描述表单</td>
</tr>
<tr>
<td>UPDATE 表单名称 SET attribute=新值 WHERE attribute &gt; 原始值;</td>
<td>更新表单中的数据</td>
</tr>
<tr>
<td>USE 数据库名称;</td>
<td>指定使用的数据库</td>
</tr>
<tr>
<td>SHOW databases;</td>
<td>显示当前已有的数据库</td>
</tr>
<tr>
<td>SHOW tables;</td>
<td>显示当前数据库中的表单</td>
</tr>
<tr>
<td>SELECT * FROM 表单名称;</td>
<td>从表单中选中某个记录值</td>
</tr>
<tr>
<td>DELETE FROM 表单名 WHERE attribute=值;</td>
<td>从表单中删除某个记录值</td>
</tr>
</tbody></table>
<p>现在尝试创建一个名为linuxprobe的数据库，然后再查看数据库列表，此时就能看到它了：</p>
<pre><code>MariaDB [(none)]&gt; CREATE DATABASE linuxprobe;
Query OK, 1 row affected (0.00 sec)
MariaDB [(none)]&gt; SHOW databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| linuxprobe         |
| mysql              |
| performance_schema |
+--------------------+
4 rows in set (0.04 sec)</code></pre>
<p>要想创建数据表单，需要先切换到某个指定的数据库中。比如在新建的linuxprobe数据库中创建表单mybook，然后进行表单的初始化，即定义存储数据内容的结构。我们分别定义3个字段项，其中，长度为15个字符的字符型字段name用来存放图书名称，整型字段price和pages分别存储图书的价格和页数。当执行完下述命令之后，就可以看到表单的结构信息了：</p>
<pre><code>MariaDB [(none)]&gt; use linuxprobe;
Database changed
MariaDB [linuxprobe]&gt; CREATE TABLE mybook (name char(15),price int,pages int);
Query OK, 0 rows affected (0.16 sec)
MariaDB [linuxprobe]&gt; DESCRIBE mybook;
+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| name  | char(15) | YES  |     | NULL    |       |
| price | int(11)  | YES  |     | NULL    |       |
| pages | int(11)  | YES  |     | NULL    |       |
+-------+----------+------+-----+---------+-------+
3 rows in set (0.02 sec)</code></pre>
<h1 id="5-管理表单及数据"><a href="#5-管理表单及数据" class="headerlink" title="5.管理表单及数据"></a>5.管理表单及数据</h1><p>下面我们使用该命令插入一条图书信息，其中书名为linuxprobe，价格和页数分别是60元和518页。在命令执行后也就意味着图书信息已经成功写入到数据表单中，然后就可以查询表单中的内容了。我们在使用select命令查询表单内容时，需要加上想要查询的字段；如果想查看表单中的所有内容，则可以使用星号（*）通配符来显示：</p>
<pre><code>MariaDB [linuxprobe]&gt; INSERT INTO mybook(name,price,pages) VALUES(&#39;linuxprobe&#39;,&#39;60&#39;, &#39;518&#39;);
Query OK, 1 row affected (0.00 sec)
MariaDB [linuxprobe]&gt; select * from mybook;
+------------+-------+-------+
| name       | price | pages |
+------------+-------+-------+
| linuxprobe |    60 |   518 |
+------------+-------+-------+
1 rows in set (0.01 sec)</code></pre>
<p>对数据库运维人员来讲，需要做好四门功课—增、删、改、查。这意味着创建数据表单并在其中插入内容仅仅是第一步，还需要掌握数据表单内容的修改方法。例如，我们可以使用update命令将刚才插入的linuxprobe图书信息的价格修改为55元，然后在使用select命令查看该图书的名称和定价信息。注意，因为这里只查看图书的名称和定价，而不涉及页码，所以无须再用星号通配符来显示所有内容。</p>
<pre><code>MariaDB [linuxprobe]&gt; UPDATE mybook SET price=55 ;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
MariaDB [linuxprobe]&gt; SELECT name,price FROM mybook;
+------------+-------+
| name       | price |
+------------+-------+
| linuxprobe |    55 |
+------------+-------+
1 row in set (0.00 sec)</code></pre>
<p>我们还可以使用delete命令删除某个数据表单中的内容。下面我们使用delete命令删除数据表单mybook中的所有内容，然后再查看该表单中的内容，可以发现该表单内容为空了。</p>
<pre><code>MariaDB [linuxprobe]&gt; DELETE FROM mybook;
Query OK, 1 row affected (0.01 sec)
MariaDB [linuxprobe]&gt; SELECT * FROM mybook;
Empty set (0.00 sec)</code></pre>
<p>一般来讲，数据表单中会存放成千上万条数据信息。比如我们刚刚创建的用于保存图书信息的mybook表单，随着时间的推移，里面的图书信息也会越来越多。在这样的情况下，如果我们只想查看其价格大于某个数值的图书时，又该如何定义查询语句呢？</p>
<p>下面先使用insert插入命令依次插入4条图书信息：</p>
<pre><code>MariaDB [linuxprobe]&gt; INSERT INTO mybook(name,price,pages) VALUES(&#39;linuxprobe1&#39;,&#39;30&#39;,&#39;518&#39;);
Query OK, 1 row affected (0.05 sec)
MariaDB [linuxprobe]&gt; INSERT INTO mybook(name,price,pages) VALUES(&#39;linuxprobe2&#39;,&#39;50&#39;,&#39;518&#39;);
Query OK, 1 row affected (0.05 sec)
MariaDB [linuxprobe]&gt; INSERT INTO mybook(name,price,pages) VALUES(&#39;linuxprobe3&#39;,&#39;80&#39;,&#39;518&#39;);
Query OK, 1 row affected (0.01 sec)
MariaDB [linuxprobe]&gt; INSERT INTO mybook(name,price,pages) VALUES(&#39;linuxprobe4&#39;,&#39;100&#39;,&#39;518&#39;);
Query OK, 1 row affected (0.00 sec)</code></pre>
<p>要想让查询结果更加精准，就需要结合使用select与where命令了。其中，where命令是在数据库中进行匹配查询的条件命令。通过设置查询条件，就可以仅查找出符合该条件的数据。</p>
<p> where命令中使用的参数以及作用：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>相等</td>
</tr>
<tr>
<td>&lt;&gt;或!=</td>
<td>不相等</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于或等于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于或等于</td>
</tr>
<tr>
<td>BETWEEN</td>
<td>在某个范围内</td>
</tr>
<tr>
<td>LIKE</td>
<td>搜索一个例子</td>
</tr>
<tr>
<td>IN</td>
<td>在列中搜索多个值</td>
</tr>
</tbody></table>
<p>现在进入动手环节。分别在mybook表单中查找出价格大于75元或价格不等于80元的图书，其对应的命令如下所示。在熟悉了这两个查询条件之后，大家可以自行尝试精确查找图书名为linuxprobe2的图书信息。</p>
<pre><code>MariaDB [linuxprobe]&gt; SELECT * FROM mybook WHERE price&gt;75;
+-------------+-------+-------+
| name        | price | pages |
+-------------+-------+-------+
| linuxprobe3 |    80 |   518 |
| linuxprobe4 |   100 |   518 |
+-------------+-------+-------+
2 rows in set (0.06 sec)
MariaDB [linuxprobe]&gt; SELECT * FROM mybook WHERE price!=80;
+-------------+-------+-------+
| name | price | pages        |
+-------------+-------+-------+
| linuxprobe1  | 30  | 518    |
| linuxprobe2  | 50  | 518    |
| linuxprobe4  | 100 | 518    |
+-------------+-------+-------+
3 rows in set (0.01 sec)
MariaDB [mysql]&gt; exit
Bye</code></pre>
<h1 id="6-数据库的备份及恢复"><a href="#6-数据库的备份及恢复" class="headerlink" title="6.数据库的备份及恢复"></a>6.数据库的备份及恢复</h1><p>mysqldump命令用于备份数据库数据，格式为“mysqldump [参数] [数据库名称]”。其中参数与mysql命令大致相同，-u参数用于定义登录数据库的账户名称，-p参数代表密码提示符。下面将linuxprobe数据库中的内容导出成一个文件，并保存到root管理员的家目录中：</p>
<pre><code>[root@linuxprobe ~]# mysqldump -u root -p linuxprobe &gt; /root/linuxprobeDB.dump
Enter password:此处输入root管理员在数据库中的密码</code></pre>
<p>然后进入MariaDB数据库管理系统，彻底删除linuxprobe数据库，这样mybook数据表单也将被彻底删除。然后重新建立linuxprobe数据库：</p>
<pre><code>MariaDB [(none)]&gt; DROP DATABASE linuxprobe;
Query OK, 1 row affected (0.04 sec)
MariaDB [(none)]&gt; SHOW databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
+--------------------+
3 rows in set (0.02 sec)
MariaDB [(none)]&gt; CREATE DATABASE linuxprobe;
Query OK, 1 row affected (0.00 sec)</code></pre>
<p>接下来是见证数据恢复效果的时刻！使用输入重定向符把刚刚备份的数据库文件导入到mysql命令中，然后执行该命令。接下来登录到MariaDB数据库，就又能看到linuxprobe数据库以及mybook数据表单了。数据库恢复成功！</p>
<pre><code>[root@linuxprobe ~]# mysql -u root -p linuxprobe &lt; /root/linuxprobeDB.dump 
Enter password: 此处输入root管理员在数据库中的密码值
[root@linuxprobe ~]# mysql -u root -p
Enter password: 此处输入root管理员在数据库中的密码值
MariaDB [(none)]&gt; use linuxprobe;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A
Database changed
MariaDB [linuxprobe]&gt; SHOW tables;
+----------------------+
| Tables_in_linuxprobe |
+----------------------+
| mybook               |
+----------------------+
1 row in set (0.05 sec)
MariaDB [linuxprobe]&gt; DESCRIBE mybook;
+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| name  | char(15) | YES  |     | NULL    |       |
| price | int(11)  | YES  |     | NULL    |       |
| pages | int(11)  | YES  |     | NULL    |       |
+-------+----------+------+-----+---------+-------+
3 rows in set (0.02 sec)</code></pre>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第17章节：使用ISCSI服务部署网络存储</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：使用Apache服务部署静态网站</title>
    <url>/2021/02/07/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8Apache%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="1-网站服务程序"><a href="#1-网站服务程序" class="headerlink" title="1.网站服务程序"></a>1.网站服务程序</h1><a id="more"></a>

<p>第1步：把光盘设备中的系统镜像挂载到/media/cdrom目录。</p>
<pre><code>[root@linuxprobe ~]# mkdir -p /media/cdrom
[root@linuxprobe ~]# mount /dev/cdrom /media/cdrom
mount: /dev/sr0 is write-protected, mounting read-only</code></pre>
<p>第2步：使用Vim文本编辑器创建Yum仓库的配置文件。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/yum.repos.d/rhel7.repo
[rhel7]
name=rhel7
baseurl=file:///media/cdrom
enabled=1
gpgcheck=0</code></pre>
<p>第3步：动手安装Apache服务程序。注意，使用yum命令进行安装时，跟在命令后面的Apache服务的软件包名称为httpd。如果直接执行yum install apache命令，则系统会报错。</p>
<pre><code>[root@linuxprobe ~]# yum install httpd
Loaded plugins: langpacks, product-id, subscription-manager
………………省略部分输出信息………………
Complete!</code></pre>
<p>第4步：启用httpd服务程序并将其加入到开机启动项中，使其能够随系统开机而运行，从而持续为用户提供Web服务：</p>
<pre><code>[root@linuxprobe ~]# systemctl start httpd
[root@linuxprobe ~]# systemctl enable httpd
ln -s &#39;/usr/lib/systemd/system/httpd.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/httpd.service&#39;

[root@linuxprobe ~]# firefox</code></pre>
<h1 id="2-配置服务文件参数"><a href="#2-配置服务文件参数" class="headerlink" title="2.配置服务文件参数"></a>2.配置服务文件参数</h1><table>
<thead>
<tr>
<th>作用</th>
<th>文件名称</th>
</tr>
</thead>
<tbody><tr>
<td>服务目录</td>
<td>/etc/httpd</td>
</tr>
<tr>
<td>主配置文件</td>
<td>/etc/httpd/conf/httpd.conf</td>
</tr>
<tr>
<td>网站数据目录</td>
<td>/var/www/html</td>
</tr>
<tr>
<td>访问日志</td>
<td>/var/log/httpd/access_log</td>
</tr>
<tr>
<td>错误日志</td>
<td>/var/log/httpd/error_log</td>
</tr>
</tbody></table>
<p>在httpd服务程序的主配置文件中，存在三种类型的信息：注释行信息、全局配置、区域配置；</p>
<p> 配置httpd服务程序时最常用的参数以及用途描述：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ServerRoot</td>
<td>服务目录</td>
</tr>
<tr>
<td>ServerAdmin</td>
<td>管理员邮箱</td>
</tr>
<tr>
<td>User</td>
<td>运行服务的用户</td>
</tr>
<tr>
<td>Group</td>
<td>运行服务的用户组</td>
</tr>
<tr>
<td>ServerName</td>
<td>网站服务器的域名</td>
</tr>
<tr>
<td>DocumentRoot</td>
<td>网站数据目录</td>
</tr>
<tr>
<td>Listen</td>
<td>监听的IP地址与端口号</td>
</tr>
<tr>
<td>DirectoryIndex</td>
<td>默认的索引页页面</td>
</tr>
<tr>
<td>ErrorLog</td>
<td>错误日志文件</td>
</tr>
<tr>
<td>CustomLog</td>
<td>访问日志文件</td>
</tr>
<tr>
<td>Timeout</td>
<td>网页超时时间，默认为300秒</td>
</tr>
</tbody></table>
<p>在默认情况下，网站数据是保存在/var/www/html目录中，打开httpd服务程序的主配置文件，将约第119行用于定义网站数据保存路径的参数DocumentRoot修改为/home/wwwroot，同时还需要将约第124行用于定义目录权限的参数Directory后面的路径也修改为/home/wwwroot。配置文件修改完毕后即可保存并退出。</p>
<h1 id="3-SELinux安全子系统"><a href="#3-SELinux安全子系统" class="headerlink" title="3.SELinux安全子系统"></a>3.SELinux安全子系统</h1><p>“SELinux域”和“SELinux安全上下文”称为是Linux系统中的双保险</p>
<p>SELinux服务有三种配置模式，具体如下：</p>
<pre><code>enforcing：强制启用安全策略模式，将拦截服务的不合法请求。

permissive：遇到服务越权访问时，只发出警告而不强制拦截。

disabled：对于越权的行为不警告也不拦截。</code></pre>
<p>SELinux服务主配置文件目录：/etc/selinux/config；</p>
<p>getenforce：获取当前SELinux服务的运行模式； setenforce[0|1]：修改SELinux当前的运行模式（0为禁用，1为启用）；修改是暂时的，系统重启后失效。</p>
<p>查看网站数据保存目录的SELinux安全上下文值：</p>
<pre><code>[root@linuxprobe ~]# setenforce 1
[root@linuxprobe ~]# ls -Zd /var/www/html
drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 /var/www/html
[root@linuxprobe ~]# ls -Zd /home/wwwroot
drwxrwxrwx. root root unconfined_u:object_r:home_root_t:s0 /home/wwwroot</code></pre>
<p>在文件上设置的SELinux安全上下文是由用户段、角色段以及类型段等多个信息项共同组成的。其中，用户段system_u代表系统进程的身份，角色段object_r代表文件目录的角色，类型段httpd_sys_content_t代表网站服务的系统文件。</p>
<h2 id="3-1-semanage命令"><a href="#3-1-semanage命令" class="headerlink" title="3.1 semanage命令"></a>3.1 semanage命令</h2><p>emanage命令用于管理SELinux的策略，格式为“semanage [选项] [文件]”，经常用到的几个参数及其功能如下所示：</p>
<pre><code>    -l参数用于查询；    -a参数用于添加；    -m参数用于修改；    -d参数用于删除。</code></pre>
<p>可以向新的网站数据目录中新添加一条SELinux安全上下文，让这个目录以及里面的所有文件能够被httpd服务程序所访问到：</p>
<pre><code>[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/*</code></pre>
<p>注意，执行上述设置之后，还无法立即访问网站，还需要使用restorecon命令将设置好的SELinux安全上下文立即生效。在使用restorecon命令时，可以加上-Rv参数对指定的目录进行递归操作，以及显示SELinux安全上下文的修改过程。最后，再次刷新页面，就可以正常看到网页内容了：</p>
<pre><code>[root@linuxprobe ~]# restorecon -Rv /home/wwwroot/
restorecon reset /home/wwwroot context unconfined_u:object_r:home_root_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0</code></pre>
<p>再添加systemctl enable httpd命令，将所需服务添加到开机启动项中。</p>
<h1 id="4-个人用户主页功能"><a href="#4-个人用户主页功能" class="headerlink" title="4.个人用户主页功能"></a>4.个人用户主页功能</h1><p>第1步：在httpd服务程序中，默认没有开启个人用户主页功能。为此，我们需要编辑下面的配置文件，然后在第17行的UserDir disabled参数前面加上井号（#），表示让httpd服务程序开启个人用户主页功能；同时再把第24行的UserDir public_html参数前面的井号（#）去掉（UserDir参数表示网站数据在用户家目录中的保存目录名称，即public_html目录）。最后，在修改完毕后记得保存。</p>
<pre><code> 15 # permissions).
 16 #
 17 # UserDir disabled
 18 
 19 #
 20 # To enable requests to /~user/ to serve the user&#39;s public_html
 21 # directory, remove the &quot;UserDir disabled&quot; line above, and uncomment
 22 # the following line instead:
 23 # 
 24   UserDir public_html
 25 &lt;/IfModule&gt;
 …… …… …… ……</code></pre>
<p>第2步：在用户家目录中建立用于保存网站数据的目录及首页面文件。另外，还需要把家目录的权限修改为755，保证其他人也有权限读取里面的内容。</p>
<pre><code>[root@linuxprobe home]# su - linuxprobe
Last login: Fri May 22 13:17:37 CST 2017 on :0
[linuxprobe@linuxprobe ~]$ mkdir public_html
[linuxprobe@linuxprobe ~]$ echo &quot;This is linuxprobe&#39;s website&quot; &gt; public_html/index.html
[linuxprobe@linuxprobe ~]$ chmod -Rf 755 /home/linuxprobe</code></pre>
<p>第3步：使用getsebool命令查询并过滤出所有与HTTP协议相关的安全策略。其中，off为禁止状态，on为允许状态。</p>
<pre><code>[root@linuxprobe ~]# getsebool -a | grep http
httpd_anon_write --&gt; off
httpd_builtin_scripting --&gt; on
……
**httpd_enable_homedirs --&gt; off**
……</code></pre>
<p>第4步：用setsebool命令来修改SELinux策略中规则的布尔值，在setsebool命令后面加上-P参数，让修改后的SELinux策略规则永久生效且立即生效，并重新启动httpd服务程序：</p>
<pre><code>[root@linuxprobe ~]# setsebool -P httpd_enable_homedirs=on
[root@linuxprobe ~]# systemctl restart httpd</code></pre>
<p>第5步：在浏览器的地址栏中输入网址，其格式为“网址/<del>用户名”（其中的波浪号是必需的，而且网址、波浪号、用户名之间没有空格）如：127.0.0.1/</del>linuxprobe，就可以看到用户的个人网站了。</p>
<h2 id="4-1在网页中添加口令功能"><a href="#4-1在网页中添加口令功能" class="headerlink" title="4.1在网页中添加口令功能"></a>4.1在网页中添加口令功能</h2><p>第1步：先使用htpasswd命令生成密码数据库。-c参数表示第一次生成；后面再分别添加密码数据库的存放文件，以及验证要用到的用户名称（该用户不必是系统中已有的本地账户）。</p>
<pre><code>[root@linuxprobe ~]# htpasswd -c /etc/httpd/passwd linuxprobe
New password:此处输入用于网页验证的密码
Re-type new password:再输入一遍进行确认
Adding password for user linuxprobe</code></pre>
<p>第2步：编辑个人用户主页功能的配置文件。把第31～35行的参数信息修改成下列内容，其中井号（#）开头的内容为刘遄老师添加的注释信息，可将其忽略。随后保存并退出配置文件，重启httpd服务程序即可生效。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/httpd/conf.d/userdir.conf
31 &lt;Directory &quot;/home/*/public_html&quot;&gt;
32 AllowOverride all
#刚刚生成出来的密码验证文件保存路径
33 authuserfile &quot;/etc/httpd/passwd&quot;
#当用户尝试访问个人用户网站时的提示信息
34 authname &quot;My privately website&quot;
35 authtype basic
#用户进行账户密码登录时需要验证的用户名称
36 require user linuxprobe
37 &lt;/Directory&gt;
[root@linuxprobe ~]# systemctl restart httpd</code></pre>
<p>此后，当用户再想访问某个用户的个人网站时，就必须要输入账户和密码才能正常访问了。另外，验证时使用的账户和密码是用htpasswd命令生成的专门用于网站登录的口令密码，而不是系统中的用户密码，请不要搞错了。</p>
<h2 id="4-3虚拟网站主机功能"><a href="#4-3虚拟网站主机功能" class="headerlink" title="4.3虚拟网站主机功能"></a>4.3虚拟网站主机功能</h2><p>利用虚拟主机功能，可以把一台处于运行状态的物理服务器分割成多个“虚拟的服务器”。但是，该技术无法实现目前云主机技术的硬件资源隔离，让这些虚拟的服务器共同使用物理服务器的硬件资源，供应商只能限制硬盘的使用空间大小。</p>
<p>Apache的虚拟主机功能是服务器基于用户请求的不同IP地址、主机域名或端口号，实现提供多个网站同时为外部提供访问服务的技术，用户请求的资源不同，最终获取到的网页内容也各不相同。</p>
<h3 id="4-3-1基于IP地址"><a href="#4-3-1基于IP地址" class="headerlink" title="4.3.1基于IP地址"></a>4.3.1基于IP地址</h3><p>第1步：使用nmtui命令，创建三个IP地址，如：192.168.10.10、192.168.10.20、192.168.10.30；</p>
<img src="/2021/02/07/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8Apache%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/1.png" class>

<p>第2步：分别在/home/wwwroot中创建用于保存不同网站数据的3个目录，并向其中分别写入网站的首页文件。每个首页文件中应有明确区分不同网站内容的信息，方便我们稍后能更直观地检查效果。</p>
<img src="/2021/02/07/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8Apache%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/2.png" class>

<pre><code>[root@linuxprobe ~]# mkdir -p /home/wwwroot/10
[root@linuxprobe ~]# mkdir -p /home/wwwroot/20
[root@linuxprobe ~]# mkdir -p /home/wwwroot/30
[root@linuxprobe ~]# echo &quot;IP:192.168.10.10&quot; &gt; /home/wwwroot/10/index.html
[root@linuxprobe ~]# echo &quot;IP:192.168.10.20&quot; &gt; /home/wwwroot/20/index.html
[root@linuxprobe ~]# echo &quot;IP:192.168.10.30&quot; &gt; /home/wwwroot/30/index.html</code></pre>
<p>第3步：在httpd服务的配置文件中大约113行处开始，分别追加写入三个基于IP地址的虚拟主机网站参数，然后保存并退出。记得需要重启httpd服务，这些配置才生效。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/httpd/conf/httpd.conf
………………省略部分输出信息………………
113 &lt;VirtualHost 192.168.10.10&gt;
114 DocumentRoot /home/wwwroot/10
115 ServerName www.linuxprobe.com
116 &lt;Directory /home/wwwroot/10 &gt;
117 AllowOverride None
118 Require all granted
119 &lt;/Directory&gt;
120 &lt;/VirtualHost&gt;
121 &lt;VirtualHost 192.168.10.20&gt;
122 DocumentRoot /home/wwwroot/20
123 ServerName bbs.linuxprobe.com
124 &lt;Directory /home/wwwroot/20 &gt;
125 AllowOverride None
126 Require all granted
127 &lt;/Directory&gt;
128 &lt;/VirtualHost&gt;
129 &lt;VirtualHost 192.168.10.30&gt;
130 DocumentRoot /home/wwwroot/30
131 ServerName tech.linuxprobe.com
132 &lt;Directory /home/wwwroot/30 &gt;
133 AllowOverride None
134 Require all granted
135 &lt;/Directory&gt;
136 &lt;/VirtualHost&gt;
………………省略部分输出信息………………
[root@linuxprobe ~]# systemctl restart httpd</code></pre>
<p>第3步：手动把新的网站数据目录的SELinux安全上下文设置正确，并使用restorecon命令让新设置的SELinux安全上下文立即生效;</p>
<pre><code>[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/10
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/10/*
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/20
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/20/*
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/30
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/30/*
[root@linuxprobe ~]# restorecon -Rv /home/wwwroot</code></pre>
<img src="/2021/02/07/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8Apache%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/3.png" class>

<h3 id="4-3-2基于主机域名"><a href="#4-3-2基于主机域名" class="headerlink" title="4.3.2基于主机域名"></a>4.3.2基于主机域名</h3><p>当服务器无法为每个网站都分配一个独立IP地址的时候，可以尝试让Apache自动识别用户请求的域名，从而根据不同的域名请求来传输不同的内容。在这种情况下的配置更加简单，只需要保证位于生产环境中的服务器上有一个可用的IP地址（这里以192.168.10.10为例）就可以了。</p>
<p>/etc/hosts是Linux系统中用于强制把某个主机域名解析到指定IP地址的配置文件。</p>
<p>第1步：手工定义IP地址与域名之间对应关系的配置文件，保存并退出后会立即生效。可以通过分别ping这些域名来验证域名是否已经成功解析为IP地址。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/hosts
127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4
::1 localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.10.10 www.linuxprobe.com bbs.linuxprobe.com tech.linuxprobe.com
[root@linuxprobe ~]# ping -c 4 www.linuxprobe.com
PING www.linuxprobe.com (192.168.10.10) 56(84) bytes of data.
64 bytes from www.linuxprobe.com (192.168.10.10): icmp_seq=1 ttl=64 time=0.070 ms</code></pre>
<p>第2步：分别在/home/wwwroot中创建用于保存不同网站数据的三个目录，并向其中分别写入网站的首页文件。每个首页文件中应有明确区分不同网站内容的信息，方便我们稍后能更直观地检查效果。</p>
<pre><code>[root@linuxprobe ~]# mkdir -p /home/wwwroot/www
[root@linuxprobe ~]# mkdir -p /home/wwwroot/bbs
[root@linuxprobe ~]# mkdir -p /home/wwwroot/tech
[root@linuxprobe ~]# echo &quot;WWW.linuxprobe.com&quot; &gt; /home/wwwroot/www/index.html
[root@linuxprobe ~]# echo &quot;BBS.linuxprobe.com&quot; &gt; /home/wwwroot/bbs/index.html
[root@linuxprobe ~]# echo &quot;TECH.linuxprobe.com&quot; &gt; /home/wwwroot/tech/index.html</code></pre>
<p>第3步：在httpd服务的配置文件中大约113行处开始，分别追加写入三个基于主机名的虚拟主机网站参数，然后保存并退出。记得需要重启httpd服务，这些配置才生效。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/httpd/conf/httpd.conf
………………省略部分输出信息………………
113 &lt;VirtualHost 192.168.10.10&gt;
114 DocumentRoot &quot;/home/wwwroot/www&quot;
115 ServerName &quot;www.linuxprobe.com&quot;
116 &lt;Directory &quot;/home/wwwroot/www&quot;&gt;
117 AllowOverride None
118 Require all granted
119 &lt;/directory&gt; 
120 &lt;/VirtualHost&gt;
121 &lt;VirtualHost 192.168.10.10&gt;
122 DocumentRoot &quot;/home/wwwroot/bbs&quot;
123 ServerName &quot;bbs.linuxprobe.com&quot;
124 &lt;Directory &quot;/home/wwwroot/bbs&quot;&gt;
125 AllowOverride None
126 Require all granted
127 &lt;/Directory&gt;
128 &lt;/VirtualHost&gt;
129 &lt;VirtualHost 192.168.10.10&gt;
130 DocumentRoot &quot;/home/wwwroot/tech&quot;
131 ServerName &quot;tech.linuxprobe.com&quot;
132 &lt;Directory &quot;/home/wwwroot/tech&quot;&gt;
133 AllowOverride None
134 Require all granted
135 &lt;/directory&gt;
136 &lt;/VirtualHost&gt;</code></pre>
<p>第4步：因为当前的网站数据目录还是在/home/wwwroot目录中，因此还是必须要正确设置网站数据目录文件的SELinux安全上下文，使其与网站服务功能相吻合。最后记得用restorecon命令让新配置的SELinux安全上下文立即生效，这样就可以立即访问到虚拟主机网站了。</p>
<pre><code>[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/www
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/www/*
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/bbs
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/bbs/*
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/tech
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/tech/*
[root@linuxprobe ~]# restorecon -Rv /home/wwwroot</code></pre>
<img src="/2021/02/07/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8Apache%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/4.png" class>

<h3 id="4-3-3基于端口号"><a href="#4-3-3基于端口号" class="headerlink" title="4.3.3基于端口号"></a>4.3.3基于端口号</h3><p>基于端口号的虚拟主机功能可以让用户通过指定的端口号来访问服务器上的网站资源。一般来说，使用80、443、8080等端口号来提供网站访问服务是比较合理的，如果使用其他端口号则会受到SELinux服务的限制。</p>
<p>在接下来的实验中，我们不但要考虑到目录上应用的SELinux安全上下文的限制，还需要考虑SELinux域对httpd服务程序的管控。</p>
<p>第1步：分别在/home/wwwroot中创建用于保存不同网站数据的两个目录，并向其中分别写入网站的首页文件。每个首页文件中应有明确区分不同网站内容的信息，方便我们稍后能更直观地检查效果。</p>
<pre><code>[root@linuxprobe ~]# mkdir -p /home/wwwroot/6111
[root@linuxprobe ~]# mkdir -p /home/wwwroot/6222
[root@linuxprobe ~]# echo &quot;port:6111&quot; &gt; /home/wwwroot/6111/index.html
[root@linuxprobe ~]# echo &quot;port:6222&quot; &gt; /home/wwwroot/6222/index.html</code></pre>
<p>第2步：在httpd服务配置文件的第43行和第44行分别添加用于监听6111和6222端口的参数。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/httpd/conf/httpd.conf 
………………省略部分输出信息……………… 
 33 #
 34 # Listen: Allows you to bind Apache to specific IP addresses and/or
 35 # ports, instead of the default. See also the &lt;VirtualHost&gt;
 36 # directive.
 37 #
 38 # Change this to Listen on specific IP addresses as shown below to 
 39 # prevent Apache from glomming onto all bound IP addresses.
 40 #
 41 #Listen 12.34.56.78:80
 42 Listen 80
 43 Listen 6111
 44 Listen 6222
………………省略部分输出信息……………… </code></pre>
<p>第3步：在httpd服务的配置文件中大约113行处开始，分别追加写入两个基于端口号的虚拟主机网站参数，然后保存并退出。记得需要重启httpd服务，这些配置才生效。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/httpd/conf/httpd.conf
………………省略部分输出信息……………… 
113 &lt;VirtualHost 192.168.10.10:6111&gt;
114 DocumentRoot &quot;/home/wwwroot/6111&quot;
115 ServerName www.linuxprobe.com
116 &lt;Directory &quot;/home/wwwroot/6111&quot;&gt;
117 AllowOverride None
118 Require all granted
119 &lt;/Directory&gt; 
120 &lt;/VirtualHost&gt;
121 &lt;VirtualHost 192.168.10.10:6222&gt;
122 DocumentRoot &quot;/home/wwwroot/6222&quot;
123 ServerName bbs.linuxprobe.com
124 &lt;Directory &quot;/home/wwwroot/6222&quot;&gt;
125 AllowOverride None
126 Require all granted
127 &lt;/Directory&gt;
128 &lt;/VirtualHost&gt;
………………省略部分输出信息………………</code></pre>
<p>第4步：因为我们把网站数据目录存放在/home/wwwroot目录中，因此还是必须要正确设置网站数据目录文件的SELinux安全上下文，使其与网站服务功能相吻合。最后记得用restorecon命令让新配置的SELinux安全上下文立即生效。</p>
<pre><code>[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/6111
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/6111/*
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/6222
[root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/6222/*
[root@linuxprobe ~]# restorecon -Rv /home/wwwroot/</code></pre>
<p>第5步：用semanage命令查询并过滤出所有与HTTP协议相关且SELinux服务允许的端口列表。</p>
<pre><code>[root@linuxprobe ~]# semanage port -l | grep http
http_cache_port_t tcp 8080, 8118, 8123, 10001-10010
http_cache_port_t udp 3130
http_port_t tcp 80, 81, 443, 488, 8008, 8009, 8443, 9000
pegasus_http_port_t tcp 5988
pegasus_https_port_t tcp 5989</code></pre>
<p>第6步：SELinux允许的与HTTP协议相关的端口号中默认没有包含6111和6222，因此需要将这两个端口号手动添加进去。该操作会立即生效，而且在系统重启过后依然有效。设置好后再重启httpd服务程序</p>
<pre><code>[root@linuxprobe ~]# semanage port -a -t http_port_t -p tcp 6111
[root@linuxprobe ~]# semanage port -a -t http_port_t -p tcp 6222
[root@linuxprobe ~]# semanage port -l| grep http
http_cache_port_t tcp 8080, 8118, 8123, 10001-10010
http_cache_port_t udp 3130
http_port_t tcp  6222, 6111, 80, 81, 443, 488, 8008, 8009, 8443, 9000
pegasus_http_port_t tcp 5988
pegasus_https_port_t tcp 5989
[root@linuxprobe ~]# systemctl restart httpd</code></pre>
<img src="/2021/02/07/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8Apache%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/5.png" class>

<h1 id="5-Apache的访问控制"><a href="#5-Apache的访问控制" class="headerlink" title="5.Apache的访问控制"></a>5.Apache的访问控制</h1><p>Apache通过Allow指令允许某个主机访问服务器上的网站资源，通过Deny指令实现禁止访问。在允许或禁止访问网站资源时，还会用到Order指令，这个指令用来定义Allow或Deny指令起作用的顺序，其匹配原则是按照顺序进行匹配，若匹配成功则执行后面的默认指令。比如“Order Allow, Deny”表示先将源主机与允许规则进行匹配，若匹配成功则允许访问请求，反之则拒绝访问请求。</p>
<p>第1步：先在服务器上的网站数据目录中新建一个子目录，并在这个子目录中创建一个包含Successful单词的首页文件；</p>
<pre><code>[root@linuxprobe ~]# mkdir /var/www/html/server
[root@linuxprobe ~]# echo &quot;Successful&quot; &gt; /var/www/html/server/index.html</code></pre>
<p>第2步：打开httpd服务的配置文件，在第129行后面添加下述规则来限制源主机的访问。这段规则的含义是允许使用Firefox浏览器的主机访问服务器上的首页文件，除此之外的所有请求都将被拒绝。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/httpd/conf/httpd.conf
………………省略部分输出信息………………
129 &lt;Directory &quot;/var/www/html/server&quot;&gt;
130 SetEnvIf User-Agent &quot;Firefox&quot; ff=1
131 Order allow,deny
132 Allow from env=ff
133 &lt;/Directory&gt;
………………省略部分输出信息………………
[root@linuxprobe ~]# systemctl restart httpd
[root@linuxprobe ~]# firefox</code></pre>
<img src="/2021/02/07/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8Apache%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/6.png" class>

<p>除了匹配源主机的浏览器特征之外，还可以通过匹配源主机的IP地址进行访问控制。例如，我们只允许IP地址为192.168.10.20的主机访问网站资源，那么就可以在httpd服务配置文件的第129行后面添加下述规则。这样在重启httpd服务程序后再用本机（即服务器，其IP地址为192.168.10.10）来访问网站的首页面时就会提示访问被拒绝了。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/httpd/conf/httpd.conf
………………省略部分输出信息………………
129 &lt;Directory &quot;/var/www/html/server&quot;&gt;
130 Order allow,deny 
131 Allow from 192.168.10.20
132 &lt;/Directory&gt;
………………省略部分输出信息………………
[root@linuxprobe ~]# systemctl restart httpd
[root@linuxprobe ~]# firefox</code></pre>
<img src="/2021/02/07/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8Apache%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/7.jpg" class>




























]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第10章节：使用Apache服务部署静态网站</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学：使用Vsftpd服务传输文件</title>
    <url>/2021/02/09/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8Vsftpd%E6%9C%8D%E5%8A%A1%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="1-文件传输协议"><a href="#1-文件传输协议" class="headerlink" title="1.文件传输协议"></a>1.文件传输协议</h1><p>FTP是一种在互联网中进行文件传输的协议，基于客户端/服务器模式，默认使用20、21号端口，其中端口20（数据端口）用于进行数据传输，端口21（命令端口）用于接受客户端发出的相关FTP命令与参数。</p>
<a id="more"></a>

<p>FTP服务器是按照FTP协议在互联网上提供文件存储和访问服务的主机，FTP客户端则是向服务器发送连接请求，以建立数据传输链路的主机。FTP协议有下面两种工作模式。</p>
<pre><code>主动模式：FTP服务器主动向客户端发起连接请求。

被动模式：FTP服务器等待客户端发起连接请求（FTP的默认工作模式）。</code></pre>
<p>在配置妥当Yum软件仓库之后，就可以安装vsftpd服务程序了。</p>
<pre><code>[root@linuxprobe ~]# yum install vsftpd</code></pre>
<p>iptables防火墙管理工具默认禁止了FTP传输协议的端口号，因此在正式配置vsftpd服务程序之前，为了避免这些默认的防火墙策略“捣乱”，还需要清空iptables防火墙的默认策略，并把当前已经被清理的防火墙策略状态保存下来：</p>
<pre><code>[root@linuxprobe ~]# iptables -F
[root@linuxprobe ~]# service iptables save</code></pre>
<p>vsftpd服务程序主配置文件中常用的参数以及作用：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>listen=[YES</td>
<td>NO]</td>
</tr>
<tr>
<td>listen_address=IP地址</td>
<td>设置要监听的IP地址</td>
</tr>
<tr>
<td>listen_port=21</td>
<td>设置FTP服务的监听端口</td>
</tr>
<tr>
<td>download_enable＝[YES</td>
<td>NO]</td>
</tr>
<tr>
<td>userlist_enable=[YES</td>
<td>NO]</td>
</tr>
<tr>
<td>userlist_deny=[YES</td>
<td>NO]</td>
</tr>
<tr>
<td>max_clients=0</td>
<td>最大客户端连接数，0为不限制</td>
</tr>
<tr>
<td>max_per_ip=0</td>
<td>同一IP地址的最大连接数，0为不限制</td>
</tr>
<tr>
<td>anonymous_enable=[YES</td>
<td>NO]</td>
</tr>
<tr>
<td>anon_upload_enable=[YES</td>
<td>NO]</td>
</tr>
<tr>
<td>anon_umask=022</td>
<td>匿名用户上传文件的umask值</td>
</tr>
<tr>
<td>anon_root=/var/ftp</td>
<td>匿名用户的FTP根目录</td>
</tr>
<tr>
<td>anon_mkdir_write_enable=[YES</td>
<td>NO]</td>
</tr>
<tr>
<td>anon_other_write_enable=[YES</td>
<td>NO]</td>
</tr>
<tr>
<td>anon_max_rate=0</td>
<td>匿名用户的最大传输速率（字节/秒），0为不限制</td>
</tr>
<tr>
<td>local_enable=[YES</td>
<td>NO]</td>
</tr>
<tr>
<td>local_umask=022</td>
<td>本地用户上传文件的umask值</td>
</tr>
<tr>
<td>local_root=/var/ftp</td>
<td>本地用户的FTP根目录</td>
</tr>
<tr>
<td>chroot_local_user=[YES</td>
<td>NO]</td>
</tr>
<tr>
<td>local_max_rate=0</td>
<td>本地用户最大传输速率（字节/秒），0为不限制</td>
</tr>
</tbody></table>
<h1 id="2-Vsftpd服务程序"><a href="#2-Vsftpd服务程序" class="headerlink" title="2.Vsftpd服务程序"></a>2.Vsftpd服务程序</h1><p>vsftpd作为更加安全的文件传输的服务程序，允许用户以三种认证模式登录到FTP服务器上。</p>
<pre><code>匿名开放模式：是一种最不安全的认证模式，任何人都可以无需密码验证而直接登录到FTP服务器。

本地用户模式：是通过Linux系统本地的账户密码信息进行认证的模式，相较于匿名开放模式更安全，而且配置起来也很简单。但是如果被黑客破解了账户的信息，就可以畅通无阻地登录FTP服务器，从而完全控制整台服务器。

虚拟用户模式：是这三种模式中最安全的一种认证模式，它需要为FTP服务单独建立用户数据库文件，虚拟出用来进行口令验证的账户信息，而这些账户信息在服务器系统中实际上是不存在的，仅供FTP服务程序进行认证使用。

[root@linuxprobe ~]# yum install ftp</code></pre>
<h2 id="2-1匿名访问模式"><a href="#2-1匿名访问模式" class="headerlink" title="2.1匿名访问模式"></a>2.1匿名访问模式</h2><p>vsftpd服务程序默认开启了匿名开放模式，我们需要做的就是开放匿名用户的上传、下载文件的权限，以及让匿名用户创建、删除、更名文件的权限。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>anonymous_enable=YES</td>
<td>允许匿名访问模式</td>
</tr>
<tr>
<td>anon_umask=022</td>
<td>匿名用户上传文件的umask值</td>
</tr>
<tr>
<td>anon_upload_enable=YES</td>
<td>允许匿名用户上传文件</td>
</tr>
<tr>
<td>anon_mkdir_write_enable=YES</td>
<td>允许匿名用户创建目录</td>
</tr>
<tr>
<td>anon_other_write_enable=YES</td>
<td>允许匿名用户修改目录名称或删除目录</td>
</tr>
</tbody></table>
<p>在<strong>服务器</strong>中修改vsftpd.conf的配置文件：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/vsftpd/vsftpd.conf
1 anonymous_enable=YES
2 anon_umask=022
3 anon_upload_enable=YES
4 anon_mkdir_write_enable=YES
5 anon_other_write_enable=YES
6 local_enable=YES
7 write_enable=YES
……</code></pre>
<p>在vsftpd服务程序的主配置文件中正确填写参数，然后保存并退出。</p>
<p>在vsftpd服务程序的匿名开放认证模式下，默认访问的是/var/ftp目录。查看该目录的权限得知，只有root管理员才有写入权限，修改目录的所有者身份改为系统账户ftp：</p>
<pre><code>[root@linuxprobe ~]# ls -ld /var/ftp/pub
drwxr-xr-x. 3 root root 16 Jul 13 14:38 /var/ftp/pub
[root@linuxprobe ~]# chown -Rf ftp /var/ftp/pub
[root@linuxprobe ~]# ls -ld /var/ftp/pub
drwxr-xr-x. 3 ftp root 16 Jul 13 14:38 /var/ftp/pub</code></pre>
<p>再使用getsebool命令查看与FTP相关的SELinux域策略：</p>
<pre><code>[root@linuxprobe ~]# getsebool -a | grep ftp
ftp_home_dir --&gt; off
ftpd_anon_write --&gt; off
ftpd_connect_all_unreserved --&gt; off
ftpd_connect_db --&gt; off
ftpd_full_access --&gt; off
ftpd_use_cifs --&gt; off
ftpd_use_fusefs --&gt; off
ftpd_use_nfs --&gt; off
……</code></pre>
<p>修改该策略规则，并且在设置时使用-P参数让修改过的策略永久生效，确保在服务器重启后依然能够顺利写入文件：</p>
<pre><code>[root@linuxprobe ~]# setsebool -P ftpd_full_access=on</code></pre>
<p>再重启vsftpd服务程序并加入启动项，让新的配置参数生效。</p>
<pre><code>[root@linuxprobe ~]# systemctl restart vsftpd
[root@linuxprobe ~]# systemctl enable vsftpd</code></pre>
<p>现在就可以在<strong>客户端</strong>执行ftp命令连接到远程的FTP服务器了。在vsftpd服务程序的匿名开放认证模式下，其账户统一为anonymous，密码为空。可以切换到该目录下的pub目录中，然后尝试创建一个新的目录文件，以检验是否拥有写入权限：</p>
<pre><code>[root@linuxprobe ~]# ftp 192.168.10.10
Connected to 192.168.10.10 (192.168.10.10).
220 (vsFTPd 3.0.2)
Name (192.168.10.10:root): anonymous
331 Please specify the password.
Password:此处敲击回车即可
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&gt; cd pub
250 Directory successfully changed.
ftp&gt; mkdir files
257 &quot;/pub/files&quot; created
ftp&gt; rename files database
350 Ready for RNTO.
250 Rename successful.
ftp&gt; rmdir database
250 Remove directory operation successful.
ftp&gt; exit
221 Goodbye.</code></pre>
<h2 id="2-2本地用户模式"><a href="#2-2本地用户模式" class="headerlink" title="2.2本地用户模式"></a>2.2本地用户模式</h2><p>本地用户模式的权限参数以及作用如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>anonymous_enable=NO</td>
<td>禁止匿名访问模式</td>
</tr>
<tr>
<td>local_enable=YES</td>
<td>允许本地用户模式</td>
</tr>
<tr>
<td>write_enable=YES</td>
<td>设置可写权限</td>
</tr>
<tr>
<td>local_umask=022</td>
<td>本地用户模式创建文件的umask值</td>
</tr>
<tr>
<td>userlist_deny=YES</td>
<td>启用“禁止用户名单”，名单文件为ftpusers和user_list</td>
</tr>
<tr>
<td>userlist_enable=YES</td>
<td>开启用户作用名单文件功能</td>
</tr>
</tbody></table>
<p>在vsftpd服务程序的主配置文件中正确填写参数，然后保存并退出：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/vsftpd/vsftpd.conf
anonymous_enable=NO
local_enable=YES
write_enable=YES
local_umask=022
dirmessage_enable=YES
xferlog_enable=YES
connect_from_port_20=YES
xferlog_std_format=YES
listen=NO
listen_ipv6=YES
pam_service_name=vsftpd
userlist_enable=YES
tcp_wrappers=YES</code></pre>
<p>重启vsftpd服务程序并加入启动项，让新的配置参数生效：</p>
<pre><code>[root@linuxprobe ~]# systemctl restart vsftpd
[root@linuxprobe ~]# systemctl enable vsftpd
 ln -s &#39;/usr/lib/systemd/system/vsftpd.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/vsftpd.service</code></pre>
<p>vsftpd服务程序为了保证服务器的安全性而默认禁止了root管理员和大多数系统用户的登录行为，这样可以有效地避免黑客通过FTP服务对root管理员密码进行暴力破解。如果您确认在生产环境中使用root管理员不会对系统安全产生影响，只需按照上面的提示删除掉root用户名即可。</p>
<pre><code>[root@linuxprobe ~]# cat /etc/vsftpd/user_list 
1 # vsftpd userlist
2 # If userlist_deny=NO, only allow users in this file
3 # If userlist_deny=YES (default), never allow users in this file, and
4 # do not even prompt for a password.
5 # Note that the default vsftpd pam config also checks /etc/vsftpd/ftpusers
6 # for users that are denied.
7 root
8 bin
9 daemon
10 adm
11 lp
12 sync
13 shutdown
14 halt
15 mail
16 news
17 uucp
18 operator
19 games
20 nobody
[root@linuxprobe ~]# cat /etc/vsftpd/ftpusers 
# Users that are not allowed to login via ftp
1 root
2 bin
3 daemon
4 adm
5 lp
6 sync
7 shutdown
8 halt
9 mail
10 news
11 uucp
12 operator
13 games
14 nobody</code></pre>
<p>也可以选择ftpusers和user_list文件中没有的一个普通用户尝试登录FTP服务器：</p>
<pre><code>[root@linuxprobe ~]# ftp 192.168.10.10 
Connected to 192.168.10.10 (192.168.10.10).
220 (vsFTPd 3.0.2)
Name (192.168.10.10:root): linuxprobe
331 Please specify the password.
Password:此处输入该用户的密码
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&gt; mkdir files
550 Create directory operation failed.</code></pre>
<p>在采用本地用户模式登录FTP服务器后，默认访问的是该用户的家目录，也就是说，访问的是/home/linuxprobe目录。而且该目录的默认所有者、所属组都是该用户自己，因此不存在写入权限不足的情况。但是当前的操作仍然被拒绝，是因为我们刚才将虚拟机系统还原到最初的状态了。为此，需要再次开启SELinux域中对FTP服务的允许策略：</p>
<pre><code>[root@linuxprobe ~]# getsebool -a | grep ftp
ftp_home_dir --&gt; off
ftpd_anon_write --&gt; off
ftpd_connect_all_unreserved --&gt; off
ftpd_connect_db --&gt; off
ftpd_full_access --&gt; off
……
[root@linuxprobe ~]# setsebool -P ftpd_full_access=on</code></pre>
<p>配置妥当后再使用本地用户尝试登录下FTP服务器，分别执行文件的创建、重命名及删除等命令。操作均成功！</p>
<pre><code>[root@linuxprobe ~]# ftp 192.168.10.10
Connected to 192.168.10.10 (192.168.10.10).
220 (vsFTPd 3.0.2)
Name (192.168.10.10:root): linuxprobe
331 Please specify the password.
Password:此处输入该用户的密码
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&gt; mkdir files
257 &quot;/home/linuxprobe/files&quot; created
ftp&gt; rename files database
350 Ready for RNTO.
250 Rename successful.
ftp&gt; rmdir database
250 Remove directory operation successful.
ftp&gt; exit
221 Goodbye.</code></pre>
<h2 id="2-3虚拟用户模式"><a href="#2-3虚拟用户模式" class="headerlink" title="2.3虚拟用户模式"></a>2.3虚拟用户模式</h2><p>第1步：在<strong>服务器</strong>中创建用于进行FTP认证的用户数据库文件，其中奇数行为账户名，偶数行为密码。例如，我们分别创建出zhangsan和lisi两个用户，密码均为redhat：</p>
<pre><code>[root@linuxprobe ~]# cd /etc/vsftpd/
[root@linuxprobe vsftpd]# vim vuser.list
zhangsan
redhat
lisi
redhat</code></pre>
<p>第2步：明文信息既不安全，也不符合让vsftpd服务程序直接加载的格式，因此需要使用db_load命令用哈希（hash）算法将原始的明文信息文件转换成数据库文件，并且降低数据库文件的权限（避免其他人看到数据库文件的内容），然后再把原始的明文信息文件删除。</p>
<pre><code>[root@linuxprobe vsftpd]# db_load -T -t hash -f vuser.list vuser.db
[root@linuxprobe vsftpd]# file vuser.db
vuser.db: Berkeley DB (Hash, version 9, native byte-order)
[root@linuxprobe vsftpd]# chmod 600 vuser.db
[root@linuxprobe vsftpd]# rm -f vuser.list</code></pre>
<p>第3步：创建vsftpd服务程序用于存储文件的根目录以及虚拟用户映射的系统本地用户。FTP服务用于存储文件的根目录指的是，当虚拟用户登录后所访问的默认位置。</p>
<p>为了方便管理FTP服务器上的数据，可以把这个系统本地用户的家目录设置为/var目录（该目录用来存放经常发生改变的数据）。并且为了安全起见，我们将这个系统本地用户设置为不允许登录FTP服务器，这不会影响虚拟用户登录，而且还可以避免黑客通过这个系统本地用户进行登录。</p>
<pre><code>[root@linuxprobe ~]# useradd -d /var/ftproot -s /sbin/nologin virtual
[root@linuxprobe ~]# ls -ld /var/ftproot/
drwx------. 3 virtual virtual 74 Jul 14 17:50 /var/ftproot/
[root@linuxprobe ~]# chmod -Rf 755 /var/ftproot/</code></pre>
<p>第4步：建立用于支持虚拟用户的PAM文件；新建一个用于虚拟用户认证的PAM文件vsftpd.vu，其中PAM文件内的“db=”参数为使用db_load命令生成的账户密码数据库文件的路径，但不用写数据库文件的后缀：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/pam.d/vsftpd.vu
auth       required     pam_userdb.so db=/etc/vsftpd/vuser
account    required     pam_userdb.so db=/etc/vsftpd/vuser</code></pre>
<p>第5步：在vsftpd服务程序的主配置文件中通过pam_service_name参数将PAM认证文件的名称修改为vsftpd.vu：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>anonymous_enable=NO</td>
<td>禁止匿名开放模式</td>
</tr>
<tr>
<td>local_enable=YES</td>
<td>允许本地用户模式</td>
</tr>
<tr>
<td>guest_enable=YES</td>
<td>开启虚拟用户模式</td>
</tr>
<tr>
<td>guest_username=virtual</td>
<td>指定虚拟用户账户</td>
</tr>
<tr>
<td>pam_service_name=vsftpd.vu</td>
<td>指定PAM文件</td>
</tr>
<tr>
<td>allow_writeable_chroot=YES</td>
<td>允许对禁锢的FTP根目录执行写入操作，而且不拒绝用户的登录请求</td>
</tr>
</tbody></table>
<pre><code>[root@linuxprobe ~]# vim /etc/vsftpd/vsftpd.conf
1 anonymous_enable=NO
2 local_enable=YES
3 guest_enable=YES
4 guest_username=virtual
5 allow_writeable_chroot=YES
6 write_enable=YES
7 local_umask=022
8 dirmessage_enable=YES
9 xferlog_enable=YES
10 connect_from_port_20=YES
11 xferlog_std_format=YES
12 listen=NO
13 listen_ipv6=YES
14 pam_service_name=vsftpd.vu
15 userlist_enable=YES
16 tcp_wrappers=YES</code></pre>
<p>第6步：为虚拟用户设置不同的权限。虽然账户zhangsan和lisi都是用于vsftpd服务程序认证的虚拟账户，但是我们依然想对这两人进行区别对待。比如，允许张三上传、创建、修改、查看、删除文件，只允许李四查看文件。这可以通过vsftpd服务程序来实现。只需新建一个目录，在里面分别创建两个以zhangsan和lisi命名的文件，其中在名为zhangsan的文件中写入允许的相关权限（使用匿名用户的参数）</p>
<pre><code>[root@linuxprobe ~]# mkdir /etc/vsftpd/vusers_dir/
[root@linuxprobe ~]# cd /etc/vsftpd/vusers_dir/
[root@linuxprobe vusers_dir]# touch lisi
[root@linuxprobe vusers_dir]# vim zhangsan
anon_upload_enable=YES
anon_mkdir_write_enable=YES
anon_other_write_enable=YES</code></pre>
<p>第7步：再次修改vsftpd主配置文件，通过添加user_config_dir参数来定义这两个虚拟用户不同权限的配置文件所存放的路径。为了让修改后的参数立即生效，需要重启vsftpd服务程序并将该服务添加到开机启动项中：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/vsftpd/vsftpd.conf
anonymous_enable=NO
local_enable=YES
guest_enable=YES
guest_username=virtual
allow_writeable_chroot=YES
write_enable=YES
local_umask=022
dirmessage_enable=YES
xferlog_enable=YES
connect_from_port_20=YES
xferlog_std_format=YES
listen=NO
listen_ipv6=YES
pam_service_name=vsftpd.vu
userlist_enable=YES
tcp_wrappers=YES
user_config_dir=/etc/vsftpd/vusers_dir
[root@linuxprobe ~]# systemctl restart vsftpd
[root@linuxprobe ~]# systemctl enable vsftpd
 ln -s &#39;/usr/lib/systemd/system/vsftpd.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/vsftpd.service</code></pre>
<p>第8步：设置SELinux域允许策略，然后使用虚拟用户模式登录FTP服务器。</p>
<pre><code>[root@linuxprobe ~]# getsebool -a | grep ftp
ftp_home_dir –&gt; off
ftpd_anon_write –&gt; off
ftpd_connect_all_unreserved –&gt; off
ftpd_connect_db –&gt; off
ftpd_full_access –&gt; off
……
[root@linuxprobe ~]# setsebool -P ftpd_full_access=on</code></pre>
<p>第9步：然后在<strong>客户端</strong>上重新安装FTP服务器；然后用虚拟用户模式成功登录FTP服务器，还可以分别使用账户zhangsan和lisi来检验他们的权限。</p>
<pre><code>[root@linuxprobe ~]# ftp 192.168.10.10
Connected to 192.168.10.10 (192.168.10.10).
220 (vsFTPd 3.0.2)
Name (192.168.10.10:root): lisi
331 Please specify the password.
Password:此处输入虚拟用户的密码
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&gt; mkdir files
550 Permission denied.
ftp&gt; exit
221 Goodbye.
[root@linuxprobe ~]# ftp 192.168.10.10
Connected to 192.168.10.10 (192.168.10.10).
220 (vsFTPd 3.0.2)
Name (192.168.10.10:root): zhangsan
331 Please specify the password.
Password:此处输入虚拟用户的密码
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&gt; mkdir files
257 &quot;/files&quot; created
ftp&gt; rename files database
350 Ready for RNTO.
250 Rename successful.
ftp&gt; rmdir database
250 Remove directory operation successful.
ftp&gt; exit
221 Goodbye.</code></pre>
<h1 id="3-TFTP简单文件传输协议"><a href="#3-TFTP简单文件传输协议" class="headerlink" title="3.TFTP简单文件传输协议"></a>3.TFTP简单文件传输协议</h1><p>简单文件传输协议（Trivial File Transfer Protocol，TFTP）是一种基于UDP协议在客户端和服务器之间进行简单文件传输的协议。顾名思义，它提供不复杂、开销不大的文件传输服务（可将其当作FTP协议的简化版本）。</p>
<p>第1步：在服务器上安装tftp-server、tftp和xinetd：</p>
<pre><code>[root@linuxprobe ~]# yum install tftp-server tftp xinetd</code></pre>
<p>第2步：TFTP服务是使用xinetd服务程序来管理的。xinetd服务可以用来管理多种轻量级的网络服务，而且具有强大的日志功能。简单来说，在安装TFTP软件包后，还需要在xinetd服务程序中将其开启，把默认的禁用（disable）参数修改为no：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/xinetd.d/tftp
service tftp
&#123;
        socket_type             = dgram
        protocol                = udp
        wait                    = yes
        user                    = root
        server                  = /usr/sbin/in.tftpd
        server_args             = -s /var/lib/tftpboot
        disable                 = no
        per_source              = 11
        cps                     = 100 2
        flags                   = IPv4
&#125;</code></pre>
<p>第3步：重启xinetd服务并将它添加到系统的开机启动项中，以确保TFTP服务在系统重启后依然处于运行状态：</p>
<pre><code>[root@linuxprobe ~]# systemctl restart xinetd
[root@linuxprobe ~]# systemctl enable xinetd</code></pre>
<p>第4步：考虑到有些系统的防火墙默认没有允许UDP协议的69端口，因此需要手动将该端口号加入到防火墙的允许策略中（看电脑实际情况而定）：</p>
<pre><code>[root@linuxprobe ~]# firewall-cmd --permanent --add-port=69/udp
success
[root@linuxprobe ~]# firewall-cmd --reload 
success</code></pre>
<p>第5步：TFTP的根目录为/var/lib/tftpboot，可以在改目录中放置或新建自己想要传输的数据文件，如：</p>
<p>[root@linuxprobe ~]# echo “i love linux” &gt; /var/lib/tftpboot/readme.txt</p>
<p>第6步：在客户端上按照以上步骤重新安装tftp；安装完成后，我们可以使用刚安装好的tftp命令尝试访问服务器端目录中的文件，亲身体验TFTP服务的文件传输过程。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>?</td>
<td>帮助信息</td>
</tr>
<tr>
<td>put</td>
<td>上传文件</td>
</tr>
<tr>
<td>get</td>
<td>下载文件</td>
</tr>
<tr>
<td>verbose</td>
<td>显示详细的处理信息</td>
</tr>
<tr>
<td>status</td>
<td>显示当前的状态信息</td>
</tr>
<tr>
<td>binary</td>
<td>使用二进制进行传输</td>
</tr>
<tr>
<td>ascii</td>
<td>使用ASCII码进行传输</td>
</tr>
<tr>
<td>timeout</td>
<td>设置重传的超时时间</td>
</tr>
<tr>
<td>quit</td>
<td>退出</td>
</tr>
</tbody></table>
<pre><code>[root@linuxprobe ~]# tftp 192.168.10.10
tftp&gt; get readme.txt
tftp&gt; quit
[root@linuxprobe ~]# ls
anaconda-ks.cfg Documents initial-setup-ks.cfg Pictures readme.txt Videos
Desktop Downloads Music Public Templates
[root@linuxprobe ~]# cat readme.txt 
i love linux</code></pre>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第11章节：使用Vsftpd服务传输文件</tag>
      </tags>
  </entry>
  <entry>
    <title>liunx就该这么学-16：使用Squid部署代理缓存服务</title>
    <url>/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="1-代理缓存服务"><a href="#1-代理缓存服务" class="headerlink" title="1.代理缓存服务"></a>1.代理缓存服务</h1><a id="more"></a>

<p>Squid是Linux系统中最为流行的一款高性能代理服务软件，通常用作Web网站的前置缓存服务，能够代替用户向网站服务器请求页面数据并进行缓存。简单来说，Squid服务程序会按照收到的用户请求向网站源服务器请求页面、图片等所需的数据，并将服务器返回的数据存储在运行Squid服务程序的服务器上。当有用户再请求相同的数据时，则可以直接将存储服务器本地的数据交付给用户，这样不仅减少了用户的等待时间，还缓解了网站服务器的负载压力。</p>
<p>在使用Squid服务程序为用户提供缓存代理服务时，具有正向代理模式和反向代理模式之分。</p>
<p>所谓正向代理模式，是指让用户通过Squid服务程序获取网站页面等资源，以及基于访问控制列表（ACL）功能对用户访问网站行为进行限制，在具体的服务方式上又分为标准代理模式与透明代理模式。标准正向代理模式是把网站数据缓存到服务器本地，提高数据资源被再次访问时的效率，但是用户在上网时必须在浏览器等软件中填写代理服务器的IP地址与端口号信息，否则默认不使用代理服务。而透明正向代理模式的作用与标准正向代理模式基本相同，区别是用户不需要手动指定代理服务器的IP地址与端口号，所以这种代理服务对于用户来讲是相对透明的。</p>
<p>Squid服务程序提供正向代理服务：</p>
<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/1.png" class>

<p>反向代理模式是指让多台节点主机反向缓存网站数据，从而加快用户访问速度。因为一般来讲，网站中会普遍加载大量的文字、图片等静态资源，而且它们相对来说都是比较稳定的数据信息，当用户发起网站页面中这些静态资源的访问请求时，我们可以使用Squid服务程序提供的反向代理模式来进行响应。而且，如果反向代理服务器中恰巧已经有了用户要访问的静态资源，则直接将缓存的这些静态资源发送给用户，这不仅可以加快用户的网站访问速度，还在一定程度上降低了网站服务器的负载压力。</p>
<p>Squid服务程序提供的反向代理模式:</p>
<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/2.png" class>

<h1 id="2-配置Squid服务程序"><a href="#2-配置Squid服务程序" class="headerlink" title="2.配置Squid服务程序"></a>2.配置Squid服务程序</h1><p>Squid服务程序的配置步骤虽然十分简单，但依然需要为大家交代一下实验所需的设备以及相应的设置。首先需要准备两台虚拟机，一台用作Squid服务器，另外一台用作Squid客户端；为了能够相互通信，需要将这两台虚拟机<strong>都设置为仅主机模式（Hostonly）</strong>，然后关闭其中一台虚拟机的电源，在添加一块新的网卡为<strong>桥接模式</strong>后开启电源：</p>
<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/3.png" class>

<p>需要注意的是，这块新添加的网卡设备必须选择为桥接模式，否则这两台虚拟机都无法访问外网。</p>
<p>设置好桥接模式后，虚拟机还不能连接外网，还需要到虚拟机的编辑-虚拟网络编辑器，对VMnet0的桥接网卡进行指定：</p>
<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/4.png" class>

<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/5.png" class>

<p>之后回到linux系统，在终端中输入命令：nm-connection-editor，新建网卡：</p>
<pre><code>[root@linuxprobe ~]#nm-connection-editor</code></pre>
<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/6.png" class>

<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/7.png" class>

<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/8.png" class>

<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/9.png" class>

<p>设置完成后，保存退出，之后重新启动网卡；也可以ping下网站，看是否能够成功：</p>
<pre><code>[root@linuxprobe ~]#systemctl restart network
[root@linuxprobe ~]#ping -c 4 www.baidu.com</code></pre>
<p>当前Squid服务器和客户端的操作系统和IP地址信息：</p>
<table>
<thead>
<tr>
<th>主机名称</th>
<th>操作系统</th>
<th>IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>Squid服务器</td>
<td>RHEL 7</td>
<td>外网卡：桥接DHCP模式</td>
</tr>
<tr>
<td></td>
<td></td>
<td>内网卡：192.168.10.10</td>
</tr>
<tr>
<td>Squid客户端</td>
<td>Windows 7/RHEL 7</td>
<td>192.168.10.20</td>
</tr>
</tbody></table>
<p>这样一来，我们就有了一台既能访问内网，又能访问外网的Squid服务器了；但当前的Squid服务器只能和外网或虚拟机间进行通讯，无法和宿主机进行连接；如果Squid服务器需要和宿主机间通过主机模式（host only）进行通讯的话，还需要在宿主机的VMnet1网络适配器进行以下设置：</p>
<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/10.png" class>

<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/11.png" class>

<p>至此，Squid服务器既能访问外网和内网，又能和宿主机进行通讯。</p>
<p>但有一个问题，Squid服务器目前有两个网卡，一个网卡连接外网，一个网卡连接内网；但/etc/sysconfig/network-scripts目录内只有内网网卡的配置文件，并没有生成外网网卡的配置文件；自己手动新建配置文件的话，重启网卡后反而无法连接外网，会报错，不太清楚原因所在，难道使用DHCP的外网网卡不需要配置文件？</p>
<p>当配置好Yum软件仓库并挂载好设备镜像后，就可以安装Squid服务程序了:</p>
<pre><code>[root@linuxprobe ~]# yum install squid</code></pre>
<p>Squid服务程序的配置文件也是存放在/etc/squid/squid.conf;常用的Squid服务程序配置参数以及作用:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>http_port 3128</td>
<td>监听的端口号</td>
</tr>
<tr>
<td>cache_mem 64M</td>
<td>内存缓冲区的大小</td>
</tr>
<tr>
<td>cache_dir ufs /var/spool/squid 2000 16 256</td>
<td>硬盘缓冲区的大小</td>
</tr>
<tr>
<td>cache_effective_user squid</td>
<td>设置缓存的有效用户</td>
</tr>
<tr>
<td>cache_effective_group squid</td>
<td>设置缓存的有效用户组</td>
</tr>
<tr>
<td>dns_nameservers</td>
<td>IP地址    一般不设置，而是用服务器默认的DNS地址</td>
</tr>
<tr>
<td>cache_access_log /var/log/squid/access.log</td>
<td>访问日志文件的保存路径</td>
</tr>
<tr>
<td>cache_log /var/log/squid/cache.log</td>
<td>缓存日志文件的保存路径</td>
</tr>
<tr>
<td>visible_hostname linuxprobe.com</td>
<td>设置Squid服务器的名称</td>
</tr>
</tbody></table>
<h1 id="3-正向代理"><a href="#3-正向代理" class="headerlink" title="3.正向代理"></a>3.正向代理</h1><h2 id="3-1标准正向代理"><a href="#3-1标准正向代理" class="headerlink" title="3.1标准正向代理"></a>3.1标准正向代理</h2><pre><code>[root@linuxprobe ~]# systemctl restart squid
[root@linuxprobe ~]# systemctl enable squid
ln -s &#39;/usr/lib/systemd/system/squid.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/squid.service&#39;</code></pre>
<p>接下来在Squid客户端进行操作，首先是windows7系统：</p>
<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/12.png" class>

<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/13.png" class>

<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/14.png" class>

<p>其次是RHEL 7系统,打开火狐浏览器:</p>
<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/15.png" class>

<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/16.png" class>

<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/17.png" class>

<p>需要注意的是，虽然在浏览器中已经设置好代理服务器，但目前在客户端系统上还不能连接外网；此时需要回到Squid服务器中，输入以下命令，清空防火墙：</p>
<pre><code>[root@linuxprobe ~]# iptables -F
[root@linuxprobe ~]# service iptables save</code></pre>
<p>至此，Squid客户端系统可以连接外网！</p>
<p>Squid服务程序默认使用3128、3401与4827等端口号，因此可以把默认使用的端口号修改为其他值，以便起到一定的保护作用：</p>
<pre><code>[root@linuxprobe ~]# vim /etc/squid/squid.conf
………………省略部分输出信息………………
http_port 10000
………………省略部分输出信息………………
[root@linuxprobe ~]# systemctl restart squid 
[root@linuxprobe ~]# systemctl enable squid 
 ln -s &#39;/usr/lib/systemd/system/squid.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/squid.service&#39;</code></pre>
<p>尽管现在重启Squid服务程序后系统没有报错，但是用户还不能使用代理服务。SElinux安全子系统认为Squid服务程序使用3128端口号是理所当然的，因此在默认策略规则中也是允许的，但是现在Squid服务程序却尝试使用新的10000端口号，而该端口原本并不属于Squid服务程序应该使用的系统资源，因此还需要手动把新的端口号添加到Squid服务程序在SElinux域的允许列表中。</p>
<pre><code>[root@linuxprobe ~]# semanage port -l | grep squid_port_t
squid_port_t                   tcp      3128, 3401, 4827
squid_port_t                   udp      3401, 4827
[root@linuxprobe ~]# semanage port -a -t squid_port_t -p tcp 10000
[root@linuxprobe ~]# semanage port -l | grep squid_port_t
squid_port_t                   tcp      10000, 3128, 3401, 4827
squid_port_t                   udp      3401, 4827</code></pre>
<h2 id="3-2ACL访问控制"><a href="#3-2ACL访问控制" class="headerlink" title="3.2ACL访问控制"></a>3.2ACL访问控制</h2><p>Squid服务程序的ACL是由多个策略规则组成的，它可以根据指定的策略规则来允许或限制访问请求，而且策略规则的匹配顺序与防火墙策略规则一样都是由上至下；在一旦形成匹配之后，则立即执行相应操作并结束匹配过程。为了避免ACL将所有流量全部禁止或全部放行，起不到预期的访问控制效果，运维人员通常会在ACL的最下面写上deny all或者allow all语句，以避免安全隐患。</p>
<p>实验1：只允许IP地址为192.168.10.20的客户端使用服务器上的Squid服务程序提供的代理服务，禁止其余所有的主机代理请求。</p>
<p>下面的配置文件依然是Squid服务程序的配置文件，但是需要留心配置参数的填写位置。如果写的太靠前，则有些Squid服务程序自身的语句都没有加载完，也会导致策略无效。当然也不用太靠后，大约在26~32行的位置就可以，而且采用分行填写的方式也便于日后的修改。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/squid/squid.conf
 23 acl Safe_ports port 591 # filemaker
 24 acl Safe_ports port 777 # multiling http
 25 acl CONNECT method CONNECT
 26 acl client src 192.168.10.20
 27 #
 28 # Recommended minimum Access Permission configuration:
 29 #
 30 # Deny requests to certain unsafe ports
 31 http_access allow client
 32 http_access deny all
 33 http_access deny !Safe_ports
 34
[root@linuxprobe ~]# systemctl restart squid</code></pre>
<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/18.jpg" class>

<p>实验2：禁止所有客户端访问网址中包含linux关键词的网站。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/squid/squid.conf
 24 acl Safe_ports port 777 # multiling http
 25 acl CONNECT method CONNECT
 26 acl deny_keyword url_regex -i linux
 27 #
 28 # Recommended minimum Access Permission configuration:
 29 #
 30 # Deny requests to certain unsafe ports
 31 http_access deny deny_keyword
 33 http_access deny !Safe_ports
 34
[root@linuxprobe ~]# systemctl restart squid</code></pre>
<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/19.jpg" class>

<p>实验3：禁止所有客户端访问某个特定的网站。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/squid/squid.conf
 24 acl Safe_ports port 777 # multiling http
 25 acl CONNECT method CONNECT
 26 acl deny_url url_regex http://www.linuxcool.com
 27 #
 28 # Recommended minimum Access Permission configuration:
 29 #
 30 # Deny requests to certain unsafe ports
 31 http_access deny deny_url
 33 http_access deny !Safe_ports
 34
[root@linuxprobe ~]# systemctl restart squid</code></pre>
<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/20.png" class>

<p>实验4：禁止员工在企业网内部下载带有某些后缀的文件。</p>
<p>[root@linuxprobe ~]# vim /etc/squid/squid.conf<br>     24 acl Safe_ports port 777 # multiling http<br>     25 acl CONNECT method CONNECT<br>     26 acl badfile urlpath_regex -i .mp3$ .rar$<br>     27 #<br>     28 # Recommended minimum Access Permission configuration:<br>     29 #<br>     30 # Deny requests to certain unsafe ports<br>     31 http_access deny badfile<br>     33 http_access deny !Safe_ports<br>     34<br>    [root@linuxprobe ~]# systemctl restart squid</p>
<h2 id="3-3透明正向代理"><a href="#3-3透明正向代理" class="headerlink" title="3.3透明正向代理"></a>3.3透明正向代理</h2><p>透明”二字指的是让用户在没有感知的情况下使用代理服务，这样的好处是一方面不需要用户手动配置代理服务器的信息，进而降低了代理服务的使用门槛；另一方面也可以更隐秘地监督员工的上网行为。</p>
<p>在透明代理模式中，用户无须在浏览器或其他软件中配置代理服务器地址、端口号等信息，而是由DHCP服务器将网络配置信息分配给客户端主机。这样只要用户打开浏览器便会自动使用代理服务了。如果大家此时并没有配置DHCP服务器，可以手动配置客户端主机的网卡参数。</p>
<img src="/2021/02/17/liunx%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-16%EF%BC%9A%E4%BD%BF%E7%94%A8Squid%E9%83%A8%E7%BD%B2%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1/21.png" class>

<p>有些时候会因为Windows系统的缓存原因导致依然能看到网页内容，这时可以换个网站尝试一下访问效果。</p>
<p>既然要让用户在无需过多配置系统的情况下就能使用代理服务，作为运维人员就必须提前将网络配置信息与数据转发功能配置好。前面已经配置好的网络参数，要使用SNAT技术完成数据的转发，让客户端主机将数据交给Squid代理服务器，再由后者转发到外网中。简单来说，就是让Squid服务器作为一个中间人，实现内网客户端主机与外部网络之间的数据传输。</p>
<p>要想让内网中的客户端主机能够访问外网，客户端主机首先要能获取到DNS地址解析服务的数据，这样才能在互联网中找到对应网站的IP地址。下面通过iptables命令实现DNS地址解析服务53端口的数据转发功能，并且允许Squid服务器转发IPv4数据包。sysctl -p命令的作用是让转发参数立即生效：</p>
<pre><code>[root@linuxprobe ~]# iptables -F
[root@linuxprobe ~]# iptables -t nat -A POSTROUTING -p udp --dport 53 -o eno33554968 -j MASQUERADE
[root@linuxprobe ~]# echo &quot;net.ipv4.ip_forward=1&quot; &gt;&gt; /etc/sysctl.conf
[root@linuxprobe ~]# sysctl -p 
net.ipv4.ip_forward = 1</code></pre>
<p>现在回到客户端主机，再次ping某个外网地址。此时可以发现，虽然不能连通网站，但是此时已经能够获取到外网DNS服务的域名解析数据。这个步骤非常重要，为接下来的SNAT技术打下了扎实的基础。</p>
<pre><code>C:\Users\linuxprobe&gt;ping www.linuxprobe.com
正在 Ping www.linuxprobe.com [116.31.127.233] 具有 32 字节的数据:
请求超时。
请求超时。
请求超时。
请求超时。
116.31.127.233 的 Ping 统计信息:
    数据包: 已发送 = 4，已接收 = 0，丢失 = 4 (100% 丢失)，</code></pre>
<p>Squid服务程序透明代理模式的配置过程就十分简单了，只需要在主配置文件中服务器端口号后面追加上transparent单词（意思为“透明的”），然后把第62行的井号（#）注释符删除，设置缓存的保存路径就可以了。保存主配置文件并退出后再使用squid -k parse命令检查主配置文件是否有错误，以及使用squid -z命令对Squid服务程序的透明代理技术进行初始化。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/squid/squid.conf
………………省略部分输出信息………………
58 # Squid normally listens to port 3128
59 http_port 3128 transparent
60
61 # Uncomment and adjust the following to add a disk cache directory.
62 cache_dir ufs /var/spool/squid 100 16 256
63 
………………省略部分输出信息………………
[root@linuxprobe ~]# squid -k parse
2017/04/13 06:40:44| Startup: Initializing Authentication Schemes ...
2017/04/13 06:40:44| Startup: Initialized Authentication Scheme &#39;basic&#39;
………………省略部分输出信息………………
[root@linuxprobe ~]# squid -z
2017/04/13 06:41:26 kid1| Creating missing swap directories
2017/04/13 06:41:26 kid1| /var/spool/squid exists
………………省略部分输出信息………………
[root@linuxprobe ~]# systemctl restart squid</code></pre>
<p>在配置妥当并重启Squid服务程序且系统没有提示报错信息后，接下来就可以完成SNAT数据转发功能了。它的原理其实很简单，就是使用iptables防火墙管理命令把所有客户端主机对网站80端口的请求转发至Squid服务器本地的3128端口上。SNAT数据转发功能的具体配置参数如下：</p>
<pre><code>[root@linuxprobe ~]# iptables -t nat -A PREROUTING  -p tcp -m tcp --dport 80 -j REDIRECT --to-ports 3128
[root@linuxprobe ~]# iptables -t nat -A POSTROUTING -s 192.168.10.0/24 -o eno33554968 -j SNAT --to 您的桥接网卡IP地址
[root@linuxprobe ~]# service iptables save
iptables: Saving firewall rules to /etc/sysconfig/iptables:[ OK ]</code></pre>
<p>这时客户端主机再刷新一下浏览器，就又能访问网络了。</p>
<h1 id="4-反向代理"><a href="#4-反向代理" class="headerlink" title="4.反向代理"></a>4.反向代理</h1><p>反向代理是Squid服务程序的一种重要模式，其原理是把一部分原本向网站源服务器发起的用户请求交给Squid服务器缓存节点来处理。</p>
<p>当前许多网站都默认禁止了反向代理功能。开启了CDN（内容分发网络）服务的网站也可以避免这种窃取行为。</p>
<p>使用Squid服务程序来配置反向代理服务非常简单。首先找到一个网站源服务器的IP地址，然后编辑Squid服务程序的主配置文件，把端口号3128修改为网站源服务器的地址和端口号，此时正向解析服务会被暂停（它不能与反向代理服务同时使用）。然后按照下面的参数形式写入需要反向代理的网站源服务器的IP地址信息，保存退出后重启Squid服务程序。</p>
<pre><code>[root@linuxprobe ~]# vim /etc/squid/squid.conf
………………省略部分输出信息………………
57 
58 # Squid normally listens to port 3128
59 http_port 您的桥接网卡IP地址:80 vhost
60 cache_peer 网站源服务器IP地址 parent 80 0 originserver
61 
………………省略部分输出信息………………
[root@linuxprobe ~]# systemctl restart squid</code></pre>
]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第16章节：使用Squid部署代理缓存服务</tag>
      </tags>
  </entry>
  <entry>
    <title>linux就该这么学-20：使用LNMP架构部署动态网站环境</title>
    <url>/2021/02/27/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-20%EF%BC%9A%E4%BD%BF%E7%94%A8LNMP%E6%9E%B6%E6%9E%84%E9%83%A8%E7%BD%B2%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="1-源码包程序"><a href="#1-源码包程序" class="headerlink" title="1. 源码包程序"></a>1. 源码包程序</h1><p>使用源码包来安装服务程序具有两个优势。</p>
<a id="more"></a>

<pre><code>源码包的可移植性非常好，几乎可以在任何Linux系统中安装使用，而RPM软件包是针对特定系统和架构编写的指令集，必须严格地符合执行环境才能顺利安装（即只会去“生硬地”安装服务程序）。

使用源码包安装服务程序时会有一个编译过程，因此可以更好地适应安装主机的系统环境，运行效率和优化程度都会强于使用RPM软件包安装的服务程序。也就是说，可以将采用源码包安装服务程序的方式看作是针对系统的“量体裁衣”。</code></pre>
<p>一般来讲，在安装软件时，如果能通过Yum软件仓库来安装，就用Yum方式；反之则去寻找合适的RPM软件包来安装；如果是在没有资源可用，那就只能使用源码包来安装了。</p>
<p>使用源码包安装服务程序的过程看似复杂，其实在归纳汇总后只需要4～5个步骤即可完成安装：</p>
<p>第1步：下载及解压源码包文件。为了方便在网络中传输，源码包文件通常会在归档后使用gzip或bzip2等格式进行压缩，因此一般会具有.tar.gz与.tar.bz2的后缀。要想使用源码包安装服务程序，必须先把里面的内容解压出来，然后再切换到源码包文件的目录中：</p>
<pre><code>[root@linuxprobe ~]# tar xzvf FileName.tar.gz

[root@linuxprobe ~]# cd FileDirectory</code></pre>
<p>第2步：编译源码包代码。在正式使用源码包安装服务程序之前，还需要使用编译脚本针对当前系统进行一系列的评估工作，包括对源码包文件、软件之间及函数库之间的依赖关系、编译器、汇编器及连接器进行检查。我们还可以根据需要来追加–prefix参数，以指定稍后源码包程序的安装路径，从而对服务程序的安装过程更加可控。当编译工作结束后，如果系统环境符合安装要求，一般会自动在当前目录下生成一个Makefile安装文件。</p>
<pre><code>[root@linuxprobe ~]# ./configure --prefix=/usr/local/program</code></pre>
<p>第3步：生成二进制安装程序。刚刚生成的Makefile文件中会保存有关系统环境、软件依赖关系和安装规则等内容，接下来便可以使用make命令来根据Makefile文件内容提供的合适规则编译生成出真正可供用户安装服务程序的二进制可执行文件了。</p>
<pre><code>[root@linuxprobe ~]# make</code></pre>
<p>第4步：运行二进制的服务程序安装包。由于不需要再检查系统环境，也不需要再编译代码，因此运行二进制的服务程序安装包应该是速度最快的步骤。如果在源码包编译阶段使用了–prefix参数，那么此时服务程序就会被安装到那个目录，如果没有自行使用参数定义目录的话，一般会被默认安装到/usr/local/bin目录中。</p>
<pre><code>[root@linuxprobe ~]# make install</code></pre>
<p>第5步：清理源码包临时文件。由于在安装服务程序的过程中进行了代码编译的工作，因此在安装后目录中会遗留下很多临时垃圾文件，本着尽量不要浪费磁盘存储空间的原则，可以使用make clean命令对临时文件进行彻底的清理工作。</p>
<pre><code>[root@linuxprobe ~]# make clean</code></pre>
<h1 id="2-LNMP动态网站架构"><a href="#2-LNMP动态网站架构" class="headerlink" title="2. LNMP动态网站架构"></a>2. LNMP动态网站架构</h1><p>LNMP动态网站部署架构是一套由Linux + Nginx + MySQL + PHP组成的动态网站系统解决方案。</p>
<p>第1步：在使用源码包安装服务程序之前，首先要让安装主机具备编译程序源码的环境，他需要具备C语言、C++语言、Perl语言的编译器，以及各种常见的编译支持函数库程序。因此请先配置妥当Yum软件仓库，然后把下面列出的这些软件包都统统安装上：</p>
<pre><code>[root@linuxprobe ~]# yum install -y apr* autoconf automake bison bzip2 bzip2* compat* cpp curl curl-devel fontconfig fontconfig-devel freetype freetype* freetype-devel gcc gcc-c++ gd gettext gettext-devel glibc kernel kernel-headers keyutils keyutils-libs-devel krb5-devel libcom_err-devel libpng libpng-devel libjpeg* libsepol-devel libselinux-devel libstdc++-devel libtool* libgomp libxml2 libxml2-devel libXpm* libtiff libtiff* make mpfr ncurses* ntp openssl openssl-devel patch pcre-devel perl php-common php-gd policycoreutils telnet t1lib t1lib* nasm nasm* wget zlib-devel
………………省略部分安装过程………………
Complete!</code></pre>
<p>第2步：刘遄老师已经把安装LNMP动态网站部署架构所需的16个软件源码包和1个用于检查效果的论坛网站系统软件包上传到与本书配套的站点服务器上。大家可以在Windows系统中下载后通过ssh服务传送到打算部署LNMP动态网站架构的Linux服务器中，也可以直接在Linux服务器中使用wget命令下载这些源码包文件。根据第6章讲解的FHS协议，建议把要安装的软件包存放在/usr/local/src目录中：</p>
<pre><code>[root@linuxprobe ~]# cd /usr/local/src
[root@linuxprobe src] # wget https://www.linuxprobe.com/Software/cmake-2.8.11.2.tar.gz
[root@linuxprobe src] # wget https://www.linuxprobe.com/Software/Discuz_X3.2_SC_GBK.zip
[root@linuxprobe src] # wget https://www.linuxprobe.com/Software/freetype-2.5.3.tar.gz
[root@linuxprobe src] # wget https://www.linuxprobe.com/Software/jpegsrc.v9a.tar.gz
[root@linuxprobe src] # wget https://www.linuxprobe.com/Software/libgd-2.1.0.tar.gz
[root@linuxprobe src] # wget https://www.linuxprobe.com/Software/libmcrypt-2.5.8.tar.gz
[root@linuxprobe src] # wget https://www.linuxprobe.com/Software/libpng-1.6.12.tar.gz
[root@linuxprobe src] # wget https://www.linuxprobe.com/Software/libvpx-v1.3.0.tar.bz2
[root@linuxprobe src] # wget https://www.linuxprobe.com/Software/mysql-5.6.19.tar.gz
[root@linuxprobe src] # wget https://www.linuxprobe.com/Software/nginx-1.6.0.tar.gz
[root@linuxprobe src] # wget https://www.linuxprobe.com/Software/openssl-1.0.1h.tar.gz
[root@linuxprobe src] # wget https://www.linuxprobe.com/Software/php-5.5.14.tar.gz
[root@linuxprobe src] # wget https://www.linuxprobe.com/Software/pcre-8.35.tar.gz
[root@linuxprobe src] # wget https://www.linuxprobe.com/Software/t1lib-5.1.2.tar.gz
[root@linuxprobe src] # wget https://www.linuxprobe.com/Software/tiff-4.0.3.tar.gz
[root@linuxprobe src] # wget https://www.linuxprobe.com/Software/yasm-1.2.0.tar.gz
[root@linuxprobe src] # wget https://www.linuxprobe.com/Software/zlib-1.2.8.tar.gz
[root@linuxprobe src]# ls
zlib-1.2.8.tar.gz       libmcrypt-2.5.8.tar.gz  pcre-8.35.tar.gz
cmake-2.8.11.2.tar.gz   libpng-1.6.12.tar.gz    php-5.5.14.tar.gz
Discuz_X3.2_SC_GBK.zip  libvpx-v1.3.0.tar.bz2   t1lib-5.1.2.tar.gz
freetype-2.5.3.tar.gz   mysql-5.6.19.tar.gz     tiff-4.0.3.tar.gz
jpegsrc.v9a.tar.gz      nginx-1.6.0.tar.gz      yasm-1.2.0.tar.gz
libgd-2.1.0.tar.gz      openssl-1.0.1h.tar.gz</code></pre>
<p>第3步：CMake是Linux系统中一款常用的编译工具。要想通过源码包安装服务程序，就一定要严格遵守上面总结的安装步骤—下载及解压源码包文件、编译源码包代码、生成二进制安装程序、运行二进制的服务程序安装包。接下来在解压、编译各个软件包源码程序时，都会生成大量的输出信息，下文中将其省略，请读者以实际操作为准。</p>
<pre><code>[root@linuxprobe src]# tar xzvf cmake-2.8.11.2.tar.gz
[root@linuxprobe src]# cd cmake-2.8.11.2/
[root@linuxprobe cmake-2.8.11.2]# ./configure
[root@linuxprobe cmake-2.8.11.2]# make 
[root@linuxprobe cmake-2.8.11.2]# make install</code></pre>
<h2 id="2-1-配置Mysql服务"><a href="#2-1-配置Mysql服务" class="headerlink" title="2.1 配置Mysql服务"></a>2.1 配置Mysql服务</h2><p>第1步：在使用Yum软件仓库安装服务程序时，系统会自动根据RPM软件包中的指令集完整软件配置等工作。但是一旦选择使用源码包的方式来安装，这一切就需要自己来完成了。针对MySQL数据库来讲，我们需要在系统中创建一个名为mysql的用户，专门用于负责运行MySQL数据库。请记得要把这类账户的Bash终端设置成nologin解释器，避免黑客通过该用户登录到服务器中，从而提高系统安全性。</p>
<pre><code>[root@linuxprobe cmake-2.8.11.2]# cd ..
[root@linuxprobe src]# useradd mysql -s /sbin/nologin</code></pre>
<p>第2步：创建一个用于保存MySQL数据库程序和数据库文件的目录，并把该目录的所有者和所属组身份修改为mysql。其中，/usr/local/mysql是用于保存MySQL数据库服务程序的目录，/usr/local/mysql/var则是用于保存真实数据库文件的目录。</p>
<pre><code>[root@linuxprobe src]# mkdir -p /usr/local/mysql/var
[root@linuxprobe src]# chown -Rf mysql:mysql /usr/local/mysql</code></pre>
<p>第3步：接下来解压、编译、安装MySQL数据库服务程序。在编译数据库时使用的是cmake命令，其中，-DCMAKE_INSTALL_PREFIX参数用于定义数据库服务程序的保存目录，-DMYSQL_DATADIR参数用于定义真实数据库文件的目录，-DSYSCONFDIR则是定义MySQL数据库配置文件的保存目录。由于MySQL数据库服务程序比较大，因此编译的过程比较漫长，在此期间可以稍微休息一下。</p>
<pre><code>[root@linuxprobe src]# tar xzvf mysql-5.6.19.tar.gz
[root@linuxprobe src]# cd mysql-5.6.19/
[root@linuxprobe mysql-5.6.19]# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/usr/local/mysql/var -DSYSCONFDIR=/etc
[root@linuxprobe mysql-5.6.19]# make
[root@linuxprobe mysql-5.6.19]# make install</code></pre>
<p>第4步：为了让MySQL数据库程序正常运转起来，需要先删除/etc目录中的默认配置文件，然后在MySQL数据库程序的保存目录scripts内找到一个名为mysql_install_db的脚本程序，执行这个脚本程序并使用–user参数指定MySQL服务的对应账号名称（在前面步骤已经创建），使用–basedir参数指定MySQL服务程序的保存目录，使用–datadir参数指定MySQL真实数据库的文件保存目录，这样即可生成系统数据库文件，也会生成出新的MySQL服务配置文件。</p>
<pre><code>[root@linuxprobe mysql-5.6.19]# rm -rf /etc/my.cnf
[root@linuxprobe mysql-5.6.19]# cd /usr/local/mysql
[root@linuxprobe mysql]# ./scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/var</code></pre>
<p>第5步：把系统新生成的MySQL数据库配置文件链接到/etc目录中，然后把程序目录中的开机程序文件复制到/etc/rc.d/init.d目录中，以便通过service命令来管理MySQL数据库服务程序。记得把数据库脚本文件的权限修改成755以便于让用户有执行该脚本的权限：</p>
<pre><code>[root@linuxprobe mysql]# ln -s my.cnf /etc/my.cnf 
[root@linuxprobe mysql]# cp ./support-files/mysql.server /etc/rc.d/init.d/mysqld
[root@linuxprobe mysql]# chmod 755 /etc/rc.d/init.d/mysqld</code></pre>
<p>第6步：编辑刚复制的MySQL数据库脚本文件，把第46、47行的basedir与datadir参数分别修改为MySQL数据库程序的保存目录和真实数据库的文件内容。</p>
<pre><code>[root@linuxprobe mysql]# vim /etc/rc.d/init.d/mysqld 
………………省略部分输出信息………………
 39 #
 40 # If you want to affect other MySQL variables, you should make your changes
 41 # in the /etc/my.cnf, ~/.my.cnf or other MySQL configuration files.
 42 
 43 # If you change base dir, you must also change datadir. These may get
 44 # overwritten by settings in the MySQL configuration files.
 45 
 46 basedir=/usr/local/mysql
 47 datadir=/usr/local/mysql/var
 48 
………………省略部分输出信息………………</code></pre>
<p>第7步：配置好脚本文件后便可以用service命令启动mysqld数据库服务了。mysqld是MySQL数据库程序的服务名称，注意不要写错。顺带再使用chkconfig命令把mysqld服务程序加入到开机启动项中。</p>
<pre><code>[root@Linuxprobe mysql]# service mysqld start
Starting MySQL. SUCCESS! 
[root@linuxprobe mysql]# chkconfig mysqld on</code></pre>
<p>启动mysql服务时，报错：The server quit without updating PID file！报错原因是由于：进程里可能已经存在mysql进程；<br>解决方法：用命令“ps -ef | grep mysqld”查看是否有mysqld进程，如果有使用“kill -9  进程号”杀死，然后重新启动mysqld！</p>
<p>第8步：MySQL数据库程序自带了许多命令，但是Bash终端的PATH变量并不会包含这些命令所存放的目录，因此我们也无法顺利地对MySQL数据库进行初始化，也就不能使用MySQL数据库自带的命令了。想要把命令所保存的目录永久性地定义到PATH变量中，需要编辑/etc/profile文件并写入追加的命令目录，这样当物理设备在下一次重启时就会永久生效了。如果不想通过重启设备的方式来生效，也可以使用source命令加载一下/ect/profile文件，此时新的PATH变量也可以立即生效了。</p>
<pre><code>[root@linuxprobe mysql]# vim /etc/profile
………………省略部分输出信息………………
 64 
 65 for i in /etc/profile.d/*.sh ; do
 66 if [ -r &quot;$i&quot; ]; then
 67 if [ &quot;$&#123;-#*i&#125;&quot; != &quot;$-&quot; ]; then
 68 . &quot;$i&quot;
 69 else
 70 . &quot;$i&quot; &gt;/dev/null
 71 fi
 72 fi
 73 done
 74 export PATH=$PATH:/usr/local/mysql/bin
 75 unset i
 76 unset -f pathmunge
[root@linuxprobe mysql]# source /etc/profile</code></pre>
<p>第9步：MySQL数据库服务程序还会调用到一些程序文件和函数库文件。由于当前是通过源码包方式安装MySQL数据库，因此现在也必须以手动方式把这些文件链接过来。</p>
<pre><code>[root@linuxprobe mysql]# mkdir /var/lib/mysql
[root@linuxprobe mysql]# ln -s /usr/local/mysql/lib/mysql /usr/lib/mysql
[root@linuxprobe mysql]# ln -s /tmp/mysql.sock /var/lib/mysql/mysql.sock
[root@linuxprobe mysql]# ln -s /usr/local/mysql/include/mysql /usr/include/mysql</code></pre>
<p>第10步：现在，MySQL数据库服务程序已经启动，调用的各个函数文件已经就位，PATH环境变量中也加入了MySQL数据库命令的所在目录。接下来准备对MySQL数据库进行初始化，这个初始化的配置过程与MariaDB数据库是一样的，只是最后变成了Thanks for using MySQL!</p>
<pre><code>[root@linuxprobe mysql]# mysql_secure_installation 
NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MySQL
      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!
In order to log into MySQL to secure it, we&#39;ll need the current
password for the root user.  If you&#39;ve just installed MySQL, and
you haven&#39;t set the root password yet, the password will be blank,
so you should just press enter here.
Enter current password for root (enter for none): 此处只需按下回车键
OK, successfully used password, moving on...
Setting the root password ensures that nobody can log into the MySQL
root user without the proper authorisation.
Set root password? [Y/n] y （要为root管理员设置数据库的密码）
New password: 输入要为root管理员设置的数据库密码
Re-enter new password: 再输入一次密码
Password updated successfully!
Reloading privilege tables..
 ... Success!
By default, a MySQL installation has an anonymous user, allowing anyone
to log into MySQL without having to have a user account created for
them.  This is intended only for testing, and to make the installation
go a bit smoother.  You should remove them before moving into a
production environment.
Remove anonymous users? [Y/n] y （删除匿名账户）
 ... Success!
Normally, root should only be allowed to connect from &#39;localhost&#39;.  This
ensures that someone cannot guess at the root password from the network.
Disallow root login remotely? [Y/n] y （禁止root管理员从远程登录）
 ... Success!
By default, MySQL comes with a database named &#39;test&#39; that anyone can
access.  This is also intended only for testing, and should be removed
before moving into a production environment.
Remove test database and access to it? [Y/n] y （删除test数据库并取消对其的访问权限）
 - Dropping test database...
 ... Success!
 - Removing privileges on test database...
 ... Success!
Reloading the privilege tables will ensure that all changes made so far
will take effect immediately.
Reload privilege tables now? [Y/n] y （刷新授权表，让初始化后的设定立即生效）
 ... Success!
All done!  If you&#39;ve completed all of the above steps, your MySQL
installation should now be secure.
Thanks for using MySQL!
Cleaning up...</code></pre>
<h2 id="2-2-配置Ngnix服务"><a href="#2-2-配置Ngnix服务" class="headerlink" title="2.2 配置Ngnix服务"></a>2.2 配置Ngnix服务</h2><p>第1步：在正式安装Nginx服务程序之前，我们还需要为其解决相关的软件依赖关系，例如用于提供Perl语言兼容的正则表达式库的软件包pcre，就是Nginx服务程序用于实现伪静态功能必不可少的依赖包。下面来解压、编译、生成、安装Nginx服务程序的源码文件：</p>
<pre><code>[root@linuxprobe ~]# cd /usr/local/src
[root@linuxprobe src]# tar xzvf pcre-8.35.tar.gz 
[root@linuxprobe src]# cd pcre-8.35
[root@linuxprobe pcre-8.35]# ./configure --prefix=/usr/local/pcre
[root@linuxprobe pcre-8.35]# make
[root@linuxprobe pcre-8.35]# make install </code></pre>
<p>第2步：openssl软件包是用于提供网站加密证书服务的程序文件，在安装该程序时需要自定义服务程序的安装目录，以便于稍后调用它们的时候更可控。</p>
<pre><code>[root@linuxprobe pcre-8.35]# cd /usr/local/src
[root@linuxprobe src]# tar xzvf openssl-1.0.1h.tar.gz
[root@linuxprobe src]# cd openssl-1.0.1h
[root@linuxprobe openssl-1.0.1h]# ./config --prefix=/usr/local/openssl
[root@linuxprobe openssl-1.0.1h]# make
[root@linuxprobe openssl-1.0.1h]# make install </code></pre>
<p>第3步：openssl软件包安装后默认会在/usr/local/openssl/bin目录中提供很多的可用命令，我们需要像前面的操作那样，将这个目录添加到PATH环境变量中，并写入到配置文件中，最后执行source命令以便让新的PATH环境变量内容可以立即生效：</p>
<pre><code>[root@linuxprobe pcre-8.35]# vim /etc/profile
………………省略部分输出信息………………
 64 
 65 for i in /etc/profile.d/*.sh ; do
 66 if [ -r &quot;$i&quot; ]; then
 67 if [ &quot;$&#123;-#*i&#125;&quot; != &quot;$-&quot; ]; then
 68 . &quot;$i&quot;
 69 else
 70 . &quot;$i&quot; &gt;/dev/null
 71 fi
 72 fi
 73 done
 74 export PATH=$PATH:/usr/local/mysql/bin:/usr/local/openssl/bin
 75 unset i
 76 unset -f pathmunge
[root@linuxprobe pcre-8.35]# source /etc/profile</code></pre>
<p>第4步：zlib软件包是用于提供压缩功能的函数库文件。其实Nginx服务程序调用的这些服务程序无需深入了解，只要大致了解其作用就已经足够了：</p>
<pre><code>[root@linuxprobe pcre-8.35]# cd /usr/local/src
[root@linuxprobe src]# tar xzvf zlib-1.2.8.tar.gz 
[root@linuxprobe src]# cd zlib-1.2.8
[root@linuxprobe zlib-1.2.8]# ./configure --prefix=/usr/local/zlib
[root@linuxprobe zlib-1.2.8]# make
[root@linuxprobe zlib-1.2.8]# make install</code></pre>
<p>第5步：在安装部署好具有依赖关系的软件包之后，创建一个用于执行Nginx服务程序的账户。账户名称可以自定义，但一定别忘记，因为在后续需要调用：</p>
<pre><code>[root@linuxprobe zlib-1.2.8]# cd ..
[root@linuxprobe src]# useradd www -s /sbin/nologin</code></pre>
<p>第6步：在使用命令编译Nginx服务程序时，需要设置特别多的参数，其中，–prefix参数用于定义服务程序稍后安装到的位置，–user与–group参数用于指定执行Nginx服务程序的用户名和用户组。在使用参数调用openssl、zlib、pcre软件包时，请写出软件源码包的解压路径，而不是程序的安装路径：</p>
<pre><code>[root@linuxprobe src]# tar xzvf nginx-1.6.0.tar.gz 
[root@linuxprobe src]# cd nginx-1.6.0/
[root@linuxprobe nginx-1.6.0]# ./configure --prefix=/usr/local/nginx --without-http_memcached_module --user=www --group=www --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-openssl=/usr/local/src/openssl-1.0.1h --with-zlib=/usr/local/src/zlib-1.2.8 --with-pcre=/usr/local/src/pcre-8.35
[root@linuxprobe nginx-1.6.0]# make
[root@linuxprobe nginx-1.6.0]# make install</code></pre>
<p>第7步：要想启动Nginx服务程序以及将其加入到开机启动项中，也需要有脚本文件。可惜的是，在安装完Nginx软件包之后默认并没有为用户提供脚本文件，因此刘遄老师给各位读者准备了一份可用的启动脚本文件，大家只需在/etc/rc.d/init.d目录中创建脚本文件并直接复制下面的脚本内容即可（相信各位读者在掌握了第4章的内容之后，应该可以顺利看懂这个脚本文件）。</p>
<pre><code>[root@linuxprobe nginx-1.6.0]# vim /etc/rc.d/init.d/nginx
#!/bin/bash
# nginx - this script starts and stops the nginx daemon
# chkconfig: - 85 15
# description: Nginx is an HTTP(S) server, HTTP(S) reverse \
# proxy and IMAP/POP3 proxy server
# processname: nginx
# config: /etc/nginx/nginx.conf
# config: /usr/local/nginx/conf/nginx.conf
# pidfile: /usr/local/nginx/logs/nginx.pid
# Source function library.
. /etc/rc.d/init.d/functions
# Source networking configuration.
. /etc/sysconfig/network
# Check that networking is up.
[ &quot;$NETWORKING&quot; = &quot;no&quot; ] &amp;&amp; exit 0
nginx=&quot;/usr/local/nginx/sbin/nginx&quot;
prog=$(basename $nginx)
NGINX_CONF_FILE=&quot;/usr/local/nginx/conf/nginx.conf&quot;
[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginx
lockfile=/var/lock/subsys/nginx
make_dirs() &#123;
# make required directories
user=`$nginx -V 2&gt;&amp;1 | grep &quot;configure arguments:&quot; | sed &#39;s/[^*]*--user=\([^ ]*\).*/\1/g&#39; -`
        if [ -z &quot;`grep $user /etc/passwd`&quot; ]; then
                useradd -M -s /bin/nologin $user
        fi
options=`$nginx -V 2&gt;&amp;1 | grep &#39;configure arguments:&#39;`
for opt in $options; do
        if [ `echo $opt | grep &#39;.*-temp-path&#39;` ]; then
                value=`echo $opt | cut -d &quot;=&quot; -f 2`
                if [ ! -d &quot;$value&quot; ]; then
                        # echo &quot;creating&quot; $value
                        mkdir -p $value &amp;&amp; chown -R $user $value
                fi
        fi
done
&#125;
start() &#123;
[ -x $nginx ] || exit 5
[ -f $NGINX_CONF_FILE ] || exit 6
make_dirs
echo -n $&quot;Starting $prog: &quot;
daemon $nginx -c $NGINX_CONF_FILE
retval=$?
echo
[ $retval -eq 0 ] &amp;&amp; touch $lockfile
return $retval
&#125;
stop() &#123;
echo -n $&quot;Stopping $prog: &quot;
killproc $prog -QUIT
retval=$?
echo
[ $retval -eq 0 ] &amp;&amp; rm -f $lockfile
return $retval
&#125;
restart() &#123;
#configtest || return $?
stop
sleep 1
start
&#125;
reload() &#123;
#configtest || return $?
echo -n $&quot;Reloading $prog: &quot;
killproc $nginx -HUP
RETVAL=$?
echo
&#125;
force_reload() &#123;
restart
&#125;
configtest() &#123;
$nginx -t -c $NGINX_CONF_FILE
&#125;
rh_status() &#123;
status $prog
&#125;
rh_status_q() &#123;
rh_status &gt;/dev/null 2&gt;&amp;1
&#125;
case &quot;$1&quot; in
start)
        rh_status_q &amp;&amp; exit 0
        $1
        ;;
stop)
        rh_status_q || exit 0
        $1
        ;;
restart|configtest)
$1
;;
reload)
        rh_status_q || exit 7
        $1
        ;;
force-reload)
        force_reload
        ;;
status)
        rh_status
        ;;
condrestart|try-restart)
        rh_status_q || exit 0
        ;;
*)
echo $&quot;Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;&quot;
exit 2
esac</code></pre>
<p>第8步：保存脚本文件后记得为其赋予755权限，以便能够执行这个脚本。然后以绝对路径的方式执行这个脚本，通过restart参数重启Nginx服务程序，最后再使用chkconfig命令将Nginx服务程序添加至开机启动项中。大功告成！</p>
<pre><code>[root@linuxprobe nginx-1.6.0]# chmod 755 /etc/rc.d/init.d/nginx
[root@linuxprobe nginx-1.6.0]# /etc/rc.d/init.d/nginx restart
Restarting nginx (via systemctl):                          [  OK  ]
[root@linuxprobe nginx-1.6.0]# chkconfig nginx on</code></pre>
<p>Nginx服务程序在启动后就可以在浏览器中输入服务器的IP地址来查看到默认网页了。相较于Apache服务程序的红色默认页面，Nginx服务程序的默认页面显得更加简洁。</p>
<h2 id="2-3-配置php服务"><a href="#2-3-配置php服务" class="headerlink" title="2.3 配置php服务"></a>2.3 配置php服务</h2><p>PHP（Hypertxt Preprocessor，超文本预处理器）是一种通用的开源脚本语言，发明于1995年，它吸取了C语言、Java语言及Perl语言的很多优点，具有开源、免费、快捷、跨平台性强、效率高等优良特性，是目前Web开发领域最常用的语言之一。本书的配套站点就是基于PHP语言编写的。</p>
<p>使用源码包的方式编译安装PHP语言环境其实并不复杂，难点在于解决PHP的程序包和其他软件的依赖关系。为此需要先安装部署将近十个用于搭建网站页面的软件程序包，然后才能正式安装PHP程序。</p>
<p>第1步：yasm源码包是一款常见的开源汇编器，其解压、编译、安装过程中生成的输出信息均已省略：</p>
<pre><code>[root@linuxprobe nginx-1.6.0]# cd ..
[root@linuxprobe src]# tar zxvf yasm-1.2.0.tar.gz
[root@linuxprobe src]# cd yasm-1.2.0
[root@linuxprobe yasm-1.2.0]# ./configure
[root@linuxprobe yasm-1.2.0]# make
[root@linuxprobe yasm-1.2.0]# make install</code></pre>
<p>第2步：libmcrypt源码包是用于加密算法的扩展库程序，其解压、编译、安装过程中生成的输出信息均已省略：</p>
<pre><code>[root@linuxprobe yasm-1.2.0]# cd ..
[root@linuxprobe src]# tar zxvf libmcrypt-2.5.8.tar.gz
[root@linuxprobe src]# cd libmcrypt-2.5.8
[root@linuxprobe libmcrypt-2.5.8]# ./configure
[root@linuxprobe libmcrypt-2.5.8]# make
[root@linuxprobe libmcrypt-2.5.8]# make install</code></pre>
<p>第3步：libvpx源码包是用于提供视频编码器的服务程序，其解压、编译、安装过程中生成的输出信息均已省略。相信会有很多粗心的读者顺手使用了tar命令的xzvf参数，但如果仔细观察就会发现libvpx源码包的后缀是.tar.bz2，即表示使用bzip2格式进行的压缩，因此正确的解压参数应该是xjvf：</p>
<pre><code>[root@linuxprobe libmcrypt-2.5.8]# cd ..
[root@linuxprobe src]# tar xjvf libvpx-v1.3.0.tar.bz2
[root@linuxprobe src]# cd libvpx-v1.3.0
[root@linuxprobe libvpx-v1.3.0]# ./configure --prefix=/usr/local/libvpx --enable-shared --enable-vp9
[root@linuxprobe libvpx-v1.3.0]# make
[root@linuxprobe libvpx-v1.3.0]# make install</code></pre>
<p>第4步：tiff源码包是用于提供标签图像文件格式的服务程序，其解压、编译、安装过程中生成的输出信息均已省略：</p>
<pre><code>[root@linuxprobe libvpx-v1.3.0]# cd ..
[root@linuxprobe src]# tar zxvf tiff-4.0.3.tar.gz
[root@linuxprobe src]# cd tiff-4.0.3
[root@linuxprobe tiff-4.0.3]# ./configure --prefix=/usr/local/tiff --enable-shared
[root@linuxprobe tiff-4.0.3]# make
[root@linuxprobe tiff-4.0.3]# make install</code></pre>
<p>第5步：libpng源码包是用于提供png图片格式支持函数库的服务程序，其解压、编译、安装过程中生成的输出信息均已省略：</p>
<pre><code>[root@linuxprobe tiff-4.0.3]# cd ..
[root@linuxprobe src]# tar zxvf libpng-1.6.12.tar.gz
[root@linuxprobe src]# cd libpng-1.6.12
[root@linuxprobe libpng-1.6.12]# ./configure --prefix=/usr/local/libpng --enable-shared
[root@linuxprobe libpng-1.6.12]# make
[root@linuxprobe libpng-1.6.12]# make install</code></pre>
<p>第6步：freetype源码包是用于提供字体支持引擎的服务程序，其解压、编译、安装过程中生成的输出信息均已省略：</p>
<pre><code>[root@linuxprobe libpng-1.6.12]# cd ..
[root@linuxprobe src]# tar zxvf freetype-2.5.3.tar.gz
[root@linuxprobe src]# cd freetype-2.5.3
[root@linuxprobe freetype-2.5.3]# ./configure --prefix=/usr/local/freetype --enable-shared
[root@linuxprobe freetype-2.5.3]# make
[root@linuxprobe freetype-2.5.3]# make install</code></pre>
<p>第7步：jpeg源码包是用于提供jpeg图片格式支持函数库的服务程序，其解压、编译、安装过程中生成的输出信息均已省略：</p>
<pre><code>[root@linuxprobe freetype-2.5.3]# cd ..
[root@linuxprobe src]# tar zxvf jpegsrc.v9a.tar.gz
[root@linuxprobe src]# cd jpeg-9a
[root@linuxprobe jpeg-9a]# ./configure --prefix=/usr/local/jpeg --enable-shared
[root@linuxprobe jpeg-9a]# make
[root@linuxprobe jpeg-9a]# make install</code></pre>
<p>第8步：libgd源码包是用于提供图形处理的服务程序，其解压、编译、安装过程中生成的输出信息均已省略。在编译libgd源码包时，请记得写入的是jpeg、libpng、freetype、tiff、libvpx等服务程序在系统中的安装路径，即在上面安装过程中使用–prefix参数指定的目录路径：</p>
<pre><code>[root@linuxprobe jpeg-9a]# cd ..
[root@linuxprobe src]# tar zxvf libgd-2.1.0.tar.gz
[root@linuxprobe src]# cd libgd-2.1.0
[root@linuxprobe libgd-2.1.0]# ./configure --prefix=/usr/local/libgd --enable-shared --with-jpeg=/usr/local/jpeg --with-png=/usr/local/libpng --with-freetype=/usr/local/freetype --with-fontconfig=/usr/local/freetype --with-xpm=/usr/ --with-tiff=/usr/local/tiff --with-vpx=/usr/local/libvpx
[root@linuxprobe libgd-2.1.0]# make
[root@linuxprobe libgd-2.1.0]# make install</code></pre>
<p>第9步：t1lib源码包是用于提供图片生成函数库的服务程序，其解压、编译、安装过程中生成的输出信息均已省略。安装后把/usr/lib64目录中的函数文件链接到/usr/lib目录中，以便系统能够顺利调取到函数文件：</p>
<pre><code>[root@linuxprobe cd libgd-2.1.0]# cd ..
[root@linuxprobe src]# tar zxvf t1lib-5.1.2.tar.gz
[root@linuxprobe src]# cd t1lib-5.1.2
[root@linuxprobe t1lib-5.1.2]# ./configure --prefix=/usr/local/t1lib --enable-shared
[root@linuxprobe t1lib-5.1.2]# make
[root@linuxprobe t1lib-5.1.2]# make install
[root@linuxprobe t1lib-5.1.2]# ln -s /usr/lib64/libltdl.so /usr/lib/libltdl.so 
[root@linuxprobe t1lib-5.1.2]# cp -frp /usr/lib64/libXpm.so* /usr/lib/</code></pre>
<p>第10步：此时终于把编译php服务源码包的相关软件包都已经安装部署妥当了。在开始编译php源码包之前，先定义一个名为LD_LIBRARY_PATH的全局环境变量，该环境变量的作用是帮助系统找到指定的动态链接库文件，这些文件是编译php服务源码包的必须元素之一。编译php服务源码包时，除了定义要安装到的目录以外，还需要依次定义配置php服务程序配置文件的保存目录、MySQL数据库服务程序所在目录、MySQL数据库服务程序配置文件所在目录，以及libpng、jpeg、freetype、libvpx、zlib、t1lib等服务程序的安装目录路径，并通过参数启动php服务程序的诸多默认功能：</p>
<pre><code>[root@linuxprobe t1lib-5.1.2]# cd ..
[root@linuxprobe src]# tar -zvxf php-5.5.14.tar.gz
[root@linuxprobe src]# cd php-5.5.14
[root@linuxprobe php-5.5.14]# export LD_LIBRARY_PATH=/usr/local/libgd/lib
[root@linuxprobe php-5.5.14]# ./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --with-mysql=/usr/local/mysql --with-mysqli=/usr/local/mysql/bin/mysql_config --with-mysql-sock=/tmp/mysql.sock --with-pdo-mysql=/usr/local/mysql --with-gd --with-png-dir=/usr/local/libpng --with-jpeg-dir=/usr/local/jpeg --with-freetype-dir=/usr/local/freetype --with-xpm-dir=/usr/ --with-vpx-dir=/usr/local/libvpx/ --with-zlib-dir=/usr/local/zlib --with-t1lib=/usr/local/t1lib --with-iconv --enable-libxml --enable-xml --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --enable-opcache --enable-mbregex --enable-fpm --enable-mbstring --enable-ftp --enable-gd-native-ttf --with-openssl --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-gettext --enable-session --with-mcrypt --with-curl --enable-ctype 
[root@linuxprobe php-5.5.14]# make
[root@linuxprobe php-5.5.14]# make install</code></pre>
<p>第11步：在php源码包程序安装完成后，需要删除当前默认的配置文件，然后将php服务程序目录中相应的配置文件复制过来：</p>
<pre><code>[root@linuxprobe php-5.5.14]# rm -rf /etc/php.ini
[root@linuxprobe php-5.5.14]# ln -s /usr/local/php/etc/php.ini /etc/php.ini
[root@linuxprobe php-5.5.14]# cp php.ini-production /usr/local/php/etc/php.ini
[root@linuxprobe php-5.5.14]# cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf
[root@linuxprobe php-5.5.14]# ln -s /usr/local/php/etc/php-fpm.conf /etc/php-fpm.conf</code></pre>
<p>第12步：php-fpm.conf是php服务程序重要的配置文件之一，我们需要启用该配置文件中第25行左右的pid文件保存目录，然后分别将第148和149行的user与group参数分别修改为www账户和用户组名称：</p>
<pre><code>[root@linuxprobe php-5.5.14]# vim /usr/local/php/etc/php-fpm.conf
1 ;;;;;;;;;;;;;;;;;;;;;
2 ; FPM Configuration ;
3 ;;;;;;;;;;;;;;;;;;;;;
4 
5 ; All relative paths in this configuration file are relative to PHP&#39;s instal l
6 ; prefix (/usr/local/php). This prefix can be dynamically changed by using t he
7 ; &#39;-p&#39; argument from the command line.
8 
9 ; Include one or more files. If glob(3) exists, it is used to include a bunc h of
10 ; files from a glob(3) pattern. This directive can be used everywhere in the
11 ; file.
12 ; Relative path can also be used. They will be prefixed by:
13 ; - the global prefix if it&#39;s been set (-p argument)
14 ; - /usr/local/php otherwise
15 ;include=etc/fpm.d/*.conf
16 
17 ;;;;;;;;;;;;;;;;;;
18 ; Global Options ;
19 ;;;;;;;;;;;;;;;;;;
20 
21 [global]
22 ; Pid file
23 ; Note: the default prefix is /usr/local/php/var
24 ; Default Value: none
25 pid = run/php-fpm.pid
26 
………………省略部分输出信息………………
145 ; Unix user/group of processes
146 ; Note: The user is mandatory. If the group is not set, the default user&#39;s g roup
147 ; will be used.
148 user = www
149 group = www
150 
………………省略部分输出信息………………</code></pre>
<p>第13步：配置妥当后便可把用于管理php服务的脚本文件复制到/etc/rc.d/init.d中了。为了能够执行脚本，请记得为脚本赋予755权限。最后把php-fpm服务程序加入到开机启动项中：</p>
<pre><code>[root@linuxprobe php-5.5.14]# cp sapi/fpm/init.d.php-fpm /etc/rc.d/init.d/php-fpm
[root@linuxprobe php-5.5.14]# chmod 755 /etc/rc.d/init.d/php-fpm
[root@linuxprobe php-5.5.14]# chkconfig php-fpm on</code></pre>
<p>第14步：由于php服务程序的配置参数直接会影响到Web服务服务的运行环境，因此，如果默认开启了一些不必要且高危的功能（如允许用户在网页中执行Linux命令），则会降低网站被入侵的难度，入侵人员甚至可以拿到整台Web服务器的管理权限。因此我们需要编辑php.ini配置文件，在305行的disable_functions参数后面追加上要禁止的功能。下面的禁用功能名单是刘遄老师依据网站运行的经验而定制的，不见得适合每个生产环境，建议大家在此基础上根据自身工作需求酌情删减：</p>
<pre><code>[root@linuxprobe php-5.5.14]# vim /usr/local/php/etc/php.ini
………………省略部分输出信息………………
300 
301 ; This directive allows you to disable certain functions for security reasons.
302 ; It receives a comma-delimited list of function names. This directive is
303 ; *NOT* affected by whether Safe Mode is turned On or Off.
304 ; http://php.net/disable-functions
305 disable_functions = passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_alter,ini_restor e,dl,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,escapeshellcmd,dll,popen,disk_free_space,checkdnsrr,checkdnsrr,g etservbyname,getservbyport,disk_total_space,posix_ctermid,posix_get_last_error,posix_getcwd,posix_getegid,posix_geteuid,posix_getgid,po six_getgrgid,posix_getgrnam,posix_getgroups,posix_getlogin,posix_getpgid,posix_getpgrp,posix_getpid,posix_getppid,posix_getpwnam,posix_ getpwuid,posix_getrlimit,posix_getsid,posix_getuid,posix_isatty,posix_kill,posix_mkfifo,posix_setegid,posix_seteuid,posix_setgid,posix_ setpgid,posix_setsid,posix_setuid,posix_strerror,posix_times,posix_ttyname,posix_uname
306 
………………省略部分输出信息………………
这样就把php服务程序配置妥当了。最后，还需要编辑Nginx服务程序的主配置文件，把第2行的井号（#）删除，然后在后面写上负责运行Nginx服务程序的账户名称和用户组名称；在第45行的index参数后面写上网站的首页名称。最后是将第65～71行参数前的井号（#）删除来启用参数，主要是修改第69行的脚本名称路径参数，其中$document_root变量即为网站信息存储的根目录路径，若没有设置该变量，则Nginx服务程序无法找到网站信息，因此会提示“404页面未找到”的报错信息。在确认参数信息填写正确后便可重启Nginx服务与php-fpm服务。

[root@linuxprobe php-5.5.14]# vim /usr/local/nginx/conf/nginx.conf
 1 
 2 user www www;
 3 worker_processes 1;
 4 
 5 #error_log logs/error.log;
 6 #error_log logs/error.log notice;
 7 #error_log logs/error.log info;
 8 
 9 #pid logs/nginx.pid;
 10 
 11 
………………省略部分输出信息………………
 40 
 41 #access_log logs/host.access.log main;
 42 
 43 location / &#123;
 44 root html;
 45 index index.html index.htm index.php;
 46 &#125;
 47 
………………省略部分输出信息………………
 62 
 63 #pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
 64 
 65 location ~ \.php$ &#123;
 66 root html;
 67 fastcgi_pass 127.0.0.1:9000;
 68 fastcgi_index index.php;
 69 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
 70 include fastcgi_params;
 71 &#125;
 72 
………………省略部分输出信息………………
[root@linuxprobe php-5.5.14]# systemctl restart nginx
[root@linuxprobe php-5.5.14]# systemctl restart php-fpm</code></pre>
<p>至此，LNMP动态网站环境架构的配置实验全部结束。</p>
<p>在启动Nginx服务时，报错：Failed to start The nginx HTTP and reverse proxy server；报错原因是由于：有可能80端口被占用，或者有死进程；</p>
<img src="/2021/02/27/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-20%EF%BC%9A%E4%BD%BF%E7%94%A8LNMP%E6%9E%B6%E6%9E%84%E9%83%A8%E7%BD%B2%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%8E%AF%E5%A2%83/1.png" class>

<img src="/2021/02/27/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-20%EF%BC%9A%E4%BD%BF%E7%94%A8LNMP%E6%9E%B6%E6%9E%84%E9%83%A8%E7%BD%B2%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%8E%AF%E5%A2%83/2.png" class>

<p>解决方法：查看端口或者查看进程；停掉80端口服务，或者杀死进程；再启动nginx服务！</p>
<img src="/2021/02/27/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-20%EF%BC%9A%E4%BD%BF%E7%94%A8LNMP%E6%9E%B6%E6%9E%84%E9%83%A8%E7%BD%B2%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%8E%AF%E5%A2%83/3.png" class>

<h1 id="3-搭建Discuz论坛"><a href="#3-搭建Discuz论坛" class="headerlink" title="3. 搭建Discuz论坛"></a>3. 搭建Discuz论坛</h1><p>为了检验LNMP动态网站环境是否配置妥当，可以使用在上面部署Discuz!系统，然后查看结果。如果能够在LNMP动态网站环境中成功安装使用Discuz!论坛系统，也就意味着这套架构是可用的。Discuz! X3.2是国内最常见的社区论坛系统，在经过十多年的研发后已经成为了全球成熟度最高、覆盖率最广的论坛网站系统之一。</p>
<p>Discuz! X3.2软件包的后缀是.zip格式，因此应当使用专用的unzip命令来进行解压。解压后会在当前目录中出现一个名为upload的文件目录，这里面保存的就是Discuz！论坛的系统程序。我们把Nginx服务程序网站根目录的内容清空后，就可以把这些这个目录中的文件都复制进去了。记得把Nginx服务程序的网站根目录的所有者和所属组修改为本地的www用户，并为其赋予755权限以便于能够读、写、执行该论坛系统内的文件。</p>
<pre><code>[root@linuxprobe php-5.5.14 ]# cd /usr/local/src/
[root@linuxprobe src]# unzip Discuz_X3.2_SC_GBK.zip
[root@linuxprobe src]# rm -rf /usr/local/nginx/html/&#123;index.html,50x.html&#125;*
[root@linuxprobe src]# mv upload/* /usr/local/nginx/html/
[root@linuxprobe src]# chown -Rf www:www /usr/local/nginx/html
[root@linuxprobe src]# chmod -Rf 755 /usr/local/nginx/html</code></pre>
<p>第1步：接受Discuz!安装向导的许可协议。在把Discuz!论坛系统程序（即刚才upload目录中的内容）复制Nginx服务网站根目录后便可刷新浏览器页面，这将自动跳转到Discuz! X3.2论坛系统的安装界面，此处需单击“我同意”按钮，进入下一步的安装过程中：</p>
<img src="/2021/02/27/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-20%EF%BC%9A%E4%BD%BF%E7%94%A8LNMP%E6%9E%B6%E6%9E%84%E9%83%A8%E7%BD%B2%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%8E%AF%E5%A2%83/4.jpg" class>

<p>第2步：检查Discuz! X3.2论坛系统的安装环境及目录权限。我们部署的LNMP动态网站环境版本和软件都与Discuz!论坛的要求相符合，如果图20-5框中的目录状态为不可写，请自行检查目录的所有者和所属组是否为www用户，以及是否对目录设置了755权限，然后单击“下一步”按钮。</p>
<img src="/2021/02/27/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-20%EF%BC%9A%E4%BD%BF%E7%94%A8LNMP%E6%9E%B6%E6%9E%84%E9%83%A8%E7%BD%B2%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%8E%AF%E5%A2%83/5.jpg" class>

<p>第3步：选择“全新安装Discuz! X（含UCenter Server）”。UCenter Server是站点的管理平台，能够在多个站点之间同步会员账户及密码信息，单击“下一步”按钮：</p>
<img src="/2021/02/27/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-20%EF%BC%9A%E4%BD%BF%E7%94%A8LNMP%E6%9E%B6%E6%9E%84%E9%83%A8%E7%BD%B2%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%8E%AF%E5%A2%83/6.jpg" class>

<p>第4步：填写服务器的数据库信息与论坛系统管理员信息。网站系统使用由服务器本地（localhost）提供的数据库服务，数据名称与数据表前缀可由用户自行填写，其中数据库的用户名和密码则为用于登录MySQL数据库的信息（以初始化MySQL服务程序时填写的信息为准）。论坛系统的管理员账户为今后登录、管理Discuz!论坛时使用的验证信息，其中账户可以设置得简单好记一些，但是要将密码设置得尽可能复杂一下。在信息填写正确后单击“下一步”按钮：</p>
<img src="/2021/02/27/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-20%EF%BC%9A%E4%BD%BF%E7%94%A8LNMP%E6%9E%B6%E6%9E%84%E9%83%A8%E7%BD%B2%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%8E%AF%E5%A2%83/7.jpg" class>

<p>第5步：等待Discuz! X3.2论坛系统安装完毕，如图20-8所示。这个安装过程是非常快速的，大概只需要30秒左右，然后就可看到论坛安装完成的欢迎界面了。由于虚拟机主机可能并没有连接到互联网，因此该界面中可能无法正常显示Discuz!论坛系统的广告信息。在接入了互联网的服务器上成功安装完Discuz! X3.2论坛系统之后，随后单击“您的论坛已完成安装，点此访问”按钮，即可访问到论坛首页</p>
<img src="/2021/02/27/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-20%EF%BC%9A%E4%BD%BF%E7%94%A8LNMP%E6%9E%B6%E6%9E%84%E9%83%A8%E7%BD%B2%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%8E%AF%E5%A2%83/8.jpg" class>

<img src="/2021/02/27/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-20%EF%BC%9A%E4%BD%BF%E7%94%A8LNMP%E6%9E%B6%E6%9E%84%E9%83%A8%E7%BD%B2%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%8E%AF%E5%A2%83/9.jpg" class>

<img src="/2021/02/27/linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6-20%EF%BC%9A%E4%BD%BF%E7%94%A8LNMP%E6%9E%B6%E6%9E%84%E9%83%A8%E7%BD%B2%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%8E%AF%E5%A2%83/10.jpg" class>
















]]></content>
      <categories>
        <category>linux就该这么学</category>
      </categories>
      <tags>
        <tag>第20章节：使用LNMP架构部署动态网站环境</tag>
      </tags>
  </entry>
</search>
